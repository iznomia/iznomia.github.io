[{"title":"PyTorch 深度学习简论（一）：初探茅庐","path":"/posts/d259e7d7/","content":"参考的教材： 《Pytorch 深度学习简论》：https://m-tob.jd.com/ebook/30806450 《机器学习》：西瓜书 1. 猴王出世 首先一个观点是，“智能”和“自我意识”没什么关联，不要去思考这个问题。 深度学习的目的是用数学手段，使用大量数据来近似输入和输出差距很远的函数。比如输入一张图片，输出一段文字来描述这个图片。 1.1 绪论 机器学习是从数据中产生模型（model）的算法，即 learning algorithm。 数据集 D={x1,⋯ ,xn}D=\\{\\bm{x_1},\\cdots,\\bm{x_n}\\}D={x1​,⋯,xn​} 包含了 mmm 个示例（instance）或样本（sample），或者叫“特征向量”（feature vector），每个示例是 ddd 维样本空间 X\\mathcal XX 中的一个元素，ddd 称为维数（dimensionality）。 学得模型对应了关于数据的某种潜在规律，称为“假设”（hypothesis），规律自身称为“真相”（ground-truth），学习的过程是在逼近真相。 (xi,yi)(\\bm x_i,\\bm y_i)(xi​,yi​) 表示一个“样例”（example），yi\\bm y_iyi​ 称为“标记”（label），yi∈Y\\bm y_i\\in \\mathcal Yyi​∈Y，如果 Y\\mathcal YY 是离散的，那么这个工作称为“分类”（classification），连续的则称为“回归”（regression），这两者都属于“监督学习”。 若没有标记信息，我们可以对样本进行“聚类”（clustering），即将样本分成若干组，每组称为一个“簇”（cluster），这是“无监督学习”的一种。 学得模型能适用于新样本的能力称为“泛化”（generalization）能力。 假设空间 H\\mathcal HH 指的是模型 fff 的集合，而版本空间指符合样例的模型集合。版本空间大概率不只一个元素，那么我们应该选择哪个作为我们的模型呢？ “奥卡姆剃刀”是一种常用的原则，即选择最简单的那个。但事实上，总存在一种样本空间，使得那些看上去非常离谱的拟合实际上是更优秀的。 这就是“没有免费的午餐”的定理。NFL 定理的前提是每个问题出现的概率相同。 1.2 模型评估与选择 我们偏向于选择泛化误差尽可能小的模型。 留出法：2/3∼4/52/3\\sim 4/52/3∼4/5 的样本用于训练，剩下的用于测试。 交叉验证法：将数据集 DDD 划为大小相似的 kkk 个互斥子集，进行 mmm 次，称为“mmm 次 kkk 折交叉验证”，常见的有 k=m=10k=m=10k=m=10；当 k=mk=mk=m 时得到“留一法”，训练出的模型往往与直接用 DDD 训练出的模型很相似。 自助法：在数据集较小时，可以将取出的样本再扔回数据集，重复 mmm 次得到一个 D′DD′。 我们用均方误差描述学习器 fff 的性能： E(f;D)=∫x∼D(f(x)−y)2p(x)dxE(f;\\mathcal D)=\\int_{\\bm x\\sim \\mathcal D} (f(\\bm x)-y)^2p(\\bm x)\\d x E(f;D)=∫x∼D​(f(x)−y)2p(x)dx 接下来我们介绍 classification 时常用的性能度量。 错误率 E(f;D)=∫x∼DI(f(x)≠y)p(x)dxE(f;\\mathcal D)=\\int_{\\bm x\\sim \\mathcal D}\\mathbb I(f(\\bm x) e y)p(\\bm x)\\d xE(f;D)=∫x∼D​I(f(x)=y)p(x)dx，精度 acc⁡(f;D)=1−E(f;D)\\operatorname{acc}(f;\\mathcal D)=1-E(f;\\mathcal D)acc(f;D)=1−E(f;D)。 对于二分类问题，将样例根据其真实类别和学习器预测的类别划分为真正例、假正例、真反例和假反例（TP,FP,TN,FNTP,FP,TN,FNTP,FP,TN,FN）。查准率 precision 定义为 P=TPTP+FPP=\\frac{TP}{TP+FP}P=TP+FPTP​，查全率 recall 定义为 R=TPTP+FNR=\\frac{TP}{TP+FN}R=TP+FNTP​。一般来说，两者时矛盾的，除非任务非常简单。 很多情形下最终会对预测结果进行排序，从前到后我们认为其是正例的概率越低。这样，以查准率为纵轴、查全率为横轴可以绘制 P-R 曲线，将 R=PR=PR=P 的点视为平衡点（Break-Event Point, BEP），可以通过比较 BEP 来判断学习器性能。 但是 BEP 有点过于简单了，常用的是 F1=2PRP+R=2TP2TP+FN+FPF1=\\dfrac{2PR}{P+R}=\\dfrac{2TP}{2TP+FN+FP}F1=P+R2PR​=2TP+FN+FP2TP​，即 P,RP,RP,R 的调和平均数。 F1 度量的一般形式是 Fβ=(1+β2)PRβ2P+RF_{\\beta}=\\dfrac{(1+\\beta^2)PR}{\\beta^2 P+R}Fβ​=β2P+R(1+β2)PR​，当 β1\\beta1β1 时查全率影响更大，β1\\beta1β1 时查准率影响更大。 如果对所有 P,RP,RP,R 取平均值，可以算得“宏 F1”（macro⁡−F1\\operatorname{macro}-F1macro−F1），对所有 TP,FP,TN,FNTP,FP,TN,FNTP,FP,TN,FN 取平均值可以算得“微 F1”（micro⁡−F1\\operatorname{micro}-F1micro−F1）。 “排序”本身的质量好坏很大程度上决定了学习器的“期望泛化性能”，预测概率越大说明我们的模型认为其更可能是正例。纵轴为真正例率（True Positive Rate）TPR⁡=TPTP+FN\\operatorname{TPR}=\\dfrac{TP}{TP+FN}TPR=TP+FNTP​，横轴为假正例率 FPR⁡=FPTN+FP\\operatorname{FPR}=\\dfrac{FP}{TN+FP}FPR=TN+FPFP​，得到 ROC 曲线。在绘制 ROC 曲线时，假定有 m+m^+m+ 个正例和 m−m^-m− 个反例，首先会把所有样例预测为反例，得到坐标 (0,0)(0,0)(0,0)，然后扫描排序后的序列作为预测阈值，当前为真正例则得到坐标 (x,y+1m+)(x,y+\\frac 1{m^+})(x,y+m+1​)，当前为假正例得到坐标 (x+1m−,y)(x+\\frac 1{m^-},y)(x+m−1​,y)。比较模型的好坏就会计算 ROC 曲线下的面积，即 AUC⁡=12∑i=1m(xi+1−xi)(yi+yi+1)\\displaystyle\\operatorname{AUC}=\\frac 1 2\\sum_{i=1}^m(x_{i+1}-x_i)(y_i+y_{i+1})AUC=21​i=1∑m​(xi+1​−xi​)(yi​+yi+1​)。模型的损失为 ℓrank=1∣D+∣∣D−∣∑x+∈D+∑x−∈D−(I(f(x+)f(x−))+12I(f(x+)=f(x−)))\\displaystyle\\ell_{rank}=\\frac{1}{|D^+||D^-|}\\sum_{\\bm x^+\\in D^+}\\sum_{\\bm x^-\\in D^-}\\left(\\mathbb I(f(\\bm x^+)f(\\bm x^-))+\\frac 1 2 \\mathbb I(f(\\bm x^+)=f(\\bm x^-))\\right)ℓrank​=∣D+∣∣D−∣1​x+∈D+∑​x−∈D−∑​(I(f(x+)f(x−))+21​I(f(x+)=f(x−)))，不难发现 ℓrank=1−AUC⁡\\ell_{rank}=1-\\operatorname{AUC}ℓrank​=1−AUC。 2. 线性模型","tags":["PyTorch","深度学习","机器学习"],"categories":["计算机科学"]},{"title":"2026-01-16(#10)：いとし調べ乗せ光る風","path":"/posts/ef8530e1/","content":"BlackY feat. Risa Yuzuki —— 華神樂 10 P14960 「KWOI R1」XOR and Sliding Window 不难发现每一位是独立的，因此考虑 01 怎么做。 把 bbb 做一遍前缀异或和，发现 n/gcd⁡(n,k)n/\\gcd(n,k)n/gcd(n,k) 个元素会被绑定在一起，也就是说你能修改 aia_iai​ 和 ai+ka_{i+k}ai+k​。每一组是可以直接异或在一起的，因为这样一定比做加法更优。 我们还能对 kkk 个同余类做翻转操作，而只有 gcd⁡(n,k)\\gcd(n,k)gcd(n,k) 个同余类，因此只有 2∣(k/g)2\\mid (k/g)2∣(k/g) 时才能实现翻转。 Petrozavodsk Summer 2020. Day 6. Korean Contest. 11 G. Solo Tree Game 是 Nim 游戏。 12. D. Non-Decreasing Subarray Game 由于是两个单调函数取 max 得到的单谷函数，因此是要尽可能找两个函数相等的点，无需三分，二分即可。 13. E. Observer Game 如果先手能终结掉那就先手获胜。 否则，一直拖，拖到剩下两个 k×kk\\times kk×k 的完整区域时就结束了。因此看 nm−2k2nm-2k^2nm−2k2 的奇偶性。 14. A. Mango 代码能力有点菜了。 虽然整个题很简单，就是有两个 $ 的时候是最多只有 606060 个有效串，然后递归下去，每次二分出长度从第几个 $ 开始计算。 15 K. Determinant 这不是特征多项式模板吗。 16 F. Rhythm Game 决策单调性。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"英语中情态动词的用法","path":"/posts/14d9ca7e/","content":"本文可能不适合作为比较系统性的总结，但如果你想看看玩玩还是没什么问题的。我不知道我为什么 2026 年发的第一篇文章是这个，但是算了。 我是标题党，因此文章中还有一部分我不认识的词的记录。 期末周复习英语！虽然我觉得这个科目复不复习都是要完蛋的（） 情态动词 英语中的情态动词是一类特殊的辅助动词，用于表达说话者的态度、能力、可能性、必要性、许可、义务等，而不是描述具体的动作。它们不能单独作谓语，必须与主动词的原形一起使用。 做疑问句时要提到句首。 一些常见的情态动词： can/could：可能，能够，请求（此时 could 更礼貌） may/might 许可：May I come in? 可能性（might 更小）：She might not come to out party. May I help you? will/would 表将来时/意愿：He wouldn’t help us. 表请求（would 更礼貌，一般都是这个） shall/should 征求意见 应该 must 必要 半情态动词： need dare：敢，用法同 need ought to：应该，比 should 强，比 must 弱，用法是 ought + 动词不定式。 have to：客观，必须 had better be able to 常用的一个结构是 情态动词 + have + 过去分词，用于推测、评论或想象过去可能发生或本应发生的事情。 I could have passed the exam, but I didn’t study enough. 如果时态是过去时，那么应该用情态动词的过去形式。 附录 brutal: adj. violent and cruel, direct and clear about sth. unpleasant（冷酷的）, not thinking of people’s feelings He eliminated his rivals in a brutal struggle for power. rival n. 竞争对手 v. 与…相匹敌 If you say that someone or something has no rivals or is without rival, you mean that it is best of its type. If you say that one thing rivals another, you mean that they are both of the same standard or quality. Their smaller rival is battling to end their duopoly（两强垄断）. 垄断是 monopoly，The company has a virtual monopoly in this area of trade. 我怎么突然不认识 struggle 了，这不是 testify 中的歌词吗，然后 struggle 可以做名词和不及物动词，如 The government struggled to maintain law and order. weed n. 杂草 v. 除草","tags":["英语"],"categories":["语言","英语"]},{"title":"2025-12-31(#9)：甚至不明白 这泪水的意义 / 2025 年度总结","path":"/posts/8d6b7bc5/","content":"Essbee —— 悔_ 今年最后一篇了！ 8 [2025 Shenyang] The Bond Beyond Time 我感觉我需要提高我自己写代码的能力。代码。 9 [USACO23JAN P] Mana Collection 反复走来走去是没有意义的，在最后一次经过一个点的时候收集魔力即可。因此不难发现，统计最少损失多少魔力明显是更好做的。 因此我们先处理所有的行走路径。假设时间充分大，设 dps,idp_{s,i}dps,i​ 代表走过的点的集合为 sss，终点为 iii，那么答案是 (∑k∈smk)×time−dps,i(\\sum_{k\\in s} m_k)\\times time -dp_{s,i}(∑k∈s​mk​)×time−dps,i​。如果时间不足够大，那么虽然这个式子没有意义，但相当于它起点的贡献是个负的，一定是不优的，不用管它。也正因如此，如果有一种方式可以让 dps,idp_{s,i}dps,i​ 变大但使得所需要的最小时间更小，是没有用的，一定可以通过调整之前的 dps,idp_{s,i}dps,i​ 的经过集合（把负的贡献删掉），形成大概这样的东西： 因此把所有东西处理出来之后扔进 nnn 棵李超线段树查询即可。 既然标题有年度总结那还是稍微写一点，虽然不是很想写！ 不知道自己在干什么！ 寒假写完《狂乱繁星》和《CRYPTO》！然后学点新的东西（可能是非计算机相关的，比如学点乐理甚至作曲）！ 其实还是走一步看一步吧，有句话是，总是追忆过去是对未来迷茫的一种表现。不清楚，可能说的有道理。不管了我觉得我还是适合走一步看一步，元旦期间还是为期末考试准备一下比较好，感觉学过的东西又忘光了。 我很喜欢那句话：“动力源于创作，创作源于生活。”然而今年我并没有完成什么有效的创作，我觉得这还是需要完成的。明年争取一周发一篇有效文章，如果在写 wiki 至少发个动态说明一下。不能再拖更了，拖更是没有前途的。 希望明年能活得更像理想中的自己一点！","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"算法竞赛中的 python（一）","path":"/posts/5c7f8dbe/","content":"来简单学习一下 python 如何在算法竞赛中使用。寒假想拿学习更多的东西。 创建一个二维数组 https://www.luogu.com.cn/problem/P11450. 做法很简单，看代码。 if __name__ == __main__: n, q = map(int, input().split()) i = 0 X = [[n] * n for _ in range(n)] Y = [[n] * n for _ in range(n)] Z = [[n] * n for _ in range(n)] ans = 0 while i q: x, y, z = map(int, input().split()) X[y][z] -= 1 Y[x][z] -= 1 Z[x][y] -= 1 if X[y][z] == 0: ans += 1 if Y[x][z] == 0: ans += 1 if Z[x][y] == 0: ans += 1 i += 1 print(ans) 读入一个数组 https://qoj.ac/contest/1427/problem/7810. 记得要加上 list()。 if __name__ == __main__: n, d = map(int, input().split()) v = list(map(int, input().split())) a = list(map(int, input().split())) ans = 0 cnt = 0 mn = 1e9 for i in range(n - 1): if i: v[i] += v[i - 1] val = (v[i] - cnt * d + d - 1) // d cnt += val mn = min(mn, a[i]) ans += val * mn print(ans) 让我们学会输出！ https://www.luogu.com.cn/problem/P9750. 分类讨论。 from math import *def solve(): a, b, c = map(int, input().split()) if a 0: a, b, c = -a, -b, -c delta = b * b - 4 * a * c if delta 0: print(NO) return x1 = ceil((-b + sqrt(delta)) / (2 * a)) # print(x1) if a * x1 * x1 + b * x1 + c == 0: print(int(x1)) return p, q = -b, 2 * a val = floor(sqrt(delta)) if val * val == delta: delta = 0 p += val g = gcd(p, q) p /= g q /= g if p: if p * q 0: print(-, end = ) p, q = abs(p), abs(q) print(int(p), end = ) if q != 1: print(/, end = ) print(int(q), end = ) if delta: print(+, end = ) if delta: val = floor(sqrt(delta)) while val = 1: if delta % (val * val) == 0: delta /= val * val break val -= 1 p, q = val, 2 * a g = gcd(p, q) p /= g q /= g if p != 1: print(int(p), end = *) print(sqrt(, end = ) print(int(delta), end = )) if q != 1: print(/, end = ) print(int(q), end = ) print()if __name__ == __main__: T, M = map(int, input().split()) for _ in range(T): solve()","tags":["算法竞赛"],"categories":["算法竞赛"]},{"title":"2025 ICPC 上海站 & Arcaea NextStage 线上观感","path":"/posts/f79d0940/","content":"你不能总是一直逃避某些事情。 总结 比赛当天早上感觉扁桃体有些发炎。 为啥能不会这个 A 呢。 O(n2klog⁡m)O(n^2k\\log m)O(n2klogm) 真的卡不过这个 E 吗，等 ucup 上了我再研究一下。 所以还是单核强度最重要。下学期还是多学习一点有用的东西吧，算法竞赛也不能断就是了，感觉会很有挑战性。 主要影响是没拿到金牌，然后没 EC 去了。有一种没进省队的空虚感。 NextStage 第一次参加这种活动，虽然是线上。 Gram 抬手好帅，削除射线好酷炫。 第一次知道 TG 是个法师，有点帅的。期待和 Laur 的新曲。 期待 Ashrount 和打打的新曲。后面那段 kick 太震惊了，太厉害了，真的不是 Myosuke 或者 Gram 吗。 象征性地放个图 ak+q vs onoken，我的天哪。 我就说 Xterfusion 是个不错的曲子，你看这效果不非常好吗。 看情况确实想在寒假开始学习乐理了。 上海旅行 赛后晚上打算去外滩看看，但是地铁坐到一般发现自己的感冒其实不是很轻，早上的感觉是对的，赛时只是在硬撑罢了。 在前往外滩的路上遇到了巧克力博物馆，有巧克力造的东方明珠塔。据我观察墙壁好像也是用巧克力造的（或者只是颜色很像），有点厉害的。 在外滩使用破烂手机拍照，并未被东方明珠塔攻击。未尝试饮用蜜雪冰城。","tags":["游记"],"categories":["记录","游记"]},{"title":"2025-11-11(#8)：四重性","path":"/posts/dcc604a/","content":"LucaProject / NeLiME —— Quadruplicity 2 [ICPC 2022 Jinan R] Tower 很好猜，不想证了。 3 [ICPC 2022 Jinan R] Frozen Scoreboard 模拟。 4 [CCPC 2025 Harbin] 01 背包 猜。 5 [CCPC 2025 Harbin] 六边形翻转 猜。 6 [CCPC 2025 Harbin] 液压机 模拟。 7 [Xi’an Regional 2025] Catch the Monster Portal. 不难画出来，如果有一个点满足它有至少三个儿子，每个儿子都不是叶子，那么就完蛋了。 使用双指针维护所有的答案为 Yes 的区间，移动指针的时候稍微剪剪枝。复杂度好像是对的，不管了。代码。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-25(#7)：一遍又一遍将它全部燃烧","path":"/posts/a497f773/","content":"Onlap —— Burn [4th ucup s3] Disjoint Set Splitting 只能离线做。因此直接假设所有答案都是 111，一条一条将删除的边加回来，看什么时候图是联通的，说明删掉这之前的边都没有问题。 1 [4th ucup s3] Christmas Tree 见 NOI 一轮复习：状态设计。 [Nanjing Regional 2024] Strips 简单。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-20(#6)：能拯救他人的梦想","path":"/posts/5d67ad62/","content":"ナナツカゼ —— アリア trio https://qoj.ac/contest/2551，怎么马上就要打正赛了啊？ solo https://qoj.ac/contest/1828 B. Birthday Gift 发现不太能做，转化成删除相邻两个不同的，这样 222 就可以转化为 0,10,10,1，最后必定会删到只剩一个数的情况。 qoj14572 Mex Hex 这个条件非常奇妙，不太能 DP。但是可以维护上一个保护范围终止点的可行区间，这样下一个区间的合法范围是可以简单地更新的。 qoj4888 Decoding The Message 首先模 655356553565535 很诡异，注意到 65535=3×5×7×25765535=3\\times 5\\times 7\\times 25765535=3×5×7×257，因此对于 256256256 进制，前三个都是所有数的和（256 mod 3=1256\\bmod 3=1256mod3=1），后面这个 做点杂题，感觉这个挺杂的：2023 Multi-University Training Contest 1。 A. Hide-And-Seek Game 不是你怎么能调这么久的。 B. City Upgrading 直接 DP 就可以了。 C. Mr. Liang play Card Game 比较简单。 E. Cyclically Isomorphic 向模板库中添加了最小表示法。 I. Assertion 你在搞笑吗。 J. Easy Problem I 不是你怎么能调这么久的。 K. Easy Problem II 不是你怎么能调这么久的。 不如 Today’s Computer is very Fast. L. Play on Tree AGC017D 的换根 DP 版。 [ARC207B] Balanced Neighbors 2 先考虑 nnn 为偶数，不难想到让 iii 无法到达 n−i+1n-i+1n−i+1。构造二分图容易做到这件事情，如果 nnn 为奇数，那么 nnn 可以在两步之内走到所有点。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-05(#5)：不死的太阳耀斑","path":"/posts/Infinity/","content":"Ashrount —— Undying Macula 10 月 2 日体验了 Arcaea 的新主线，也是我第一次跟着更新体验主线。确实好玩好吧。 隐藏曲我就这么翻译了，感觉这么粗暴的翻译比较有史诗感。 谢谢你回应我的呼唤。 duo https://qoj.ac/contest/2539 F. Yet Another MST Problem 就你要注意到一个事情，两个区间连起来之后，新的区间相当于这两个区间的交集。 E. Coffee Shops B. Domain Compression K. Robot Construction trio https://qoj.ac/contest/1741，真补不完了啊。 E. Building a Fence 考场上就应该直接写拍子。 B. Bookshelf Tracking 注意到读书操作相当于左右两半段排序，因此直接模拟即可。 C. Painting Fences D. Function with Many Maximums F. Teleports G. Exponent Calculator I. Marks Sum 萌萌的。 K. Train Depot L. Array Spread trio https://qoj.ac/contest/1780。 我觉得我就是菜。 H. Permutation 事实证明小局部 DP，大范围按照 2/32/32/3 来划分即可。 E. Team Arrangement 我勒个直接枚举拆分数之后跑 O(n2)O(n^2)O(n2) 暴力啊。 L. Challenge Matrix Multiplication 考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。 trio https://qoj.ac/contest/1901。 我觉得需要好好训练一下。 K. Knapsack 莫名其妙的科技题，这里稍微写点东西。 如果直接那个数少然后将当前数加到某个值里是没有道理的，因为你不会使这三个数的差值变小。于是你考虑每次将两个当前三元组 (A,B,C)(A,B,C)(A,B,C) 合并，用 A+CA+CA+C 来算值，这样大概率是可以减小差值的。 最终我也是不知道真遇到这种题怎么办，感觉只能听天由命。 H. Have You Seen This Subarray? 这场为数不多的好题了，这个比赛给我的感觉非常愚人节。 相邻两个数靠在一起的时间为若干个连续段，因为交换随机，所以段数很少，询问的时候直接暴力合并段即可。 但是 nnn 小的时候不满足这一点，需要暴力哈希做掉。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-30(#4)：我却以为 终有一日 能回想起来","path":"/posts/b060879/","content":"JYOCHO —— 互いの宇宙 国庆会多更新一点，但是我还没做线性代数的标准化作业。 trio https://qoj.ac/contest/1480，红了。 J. Middle Race 假交互其实猜对了，但问题是我暴力写挂了。 但为什么会想着去硬解不等式啊。 就是你要选的尽可能接近 n(A+B+C)÷3n(A+B+C)\\div 3n(A+B+C)÷3，然后直接枚举就行了。 D. Gambler’s Ruin L. Por Una Cabeza trio https://qoj.ac/contest/1236，绿了。 A. Oops, It’s Yesterday Twice More D. Paimon Sorting H. Crystalfly I. Cloud Retainer’s Game L. Secret of Tianqiu Valley M. Windblume Festival K. Ancient Magic Circle in Teyvat 大无语题。 休息很久了，来打 CF！希望能上分！https://codeforces.com/contest/2152 妈的破防了。 E. Monotone Subsequence F. Triple Attack G. Query Jungle","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"夜行","path":"/posts/71998f63/","content":"打完了 CF，但是确实卡 F 了。手速还是需要练的啊。 然后吃了点夜宵，明天下午才有课，因此可以稍微放松一下。原本的打算是稍微玩一会儿，然后在机房睡两三个小时，等早上学校门开了再回宿舍睡觉（我宿舍在校外）。 但发生了一些意料之外的情况。我之前没有注意到机房的窗没有纱窗，便直接将其打开以便通风——这邀请了大量的蚊子进入机房做客，导致我无法入睡。 于是无事可做，扫了一辆车在校园里乱逛。夜晚给人的体感还是比较冷的，把手冻到有点发寒的程度。我尝试寻找可能出去的门（没有找到），在北门找到了没有人要的外卖（放了一天的汉堡），穿越了正在施工的医学楼，如此。 最后以在机房睡了大概半个小时，大拇指被蚊子咬了一下的结局迎来了天亮。温度仍然很低，我离开了学校。 图片 王湘浩楼 于北苑拍摄的拂晓","tags":["闲话"],"categories":["记录","闲话"]},{"title":"2025-09-22(#3)：让我们再次解答 对着那被吞噬的黑暗","path":"/posts/ec78c757/","content":"ARForest feat. Sennzai —— 星になって 队友太强了！！ https://qoj.ac/contest/2534 G. 序列与整数对 这个复杂度怎么拿不等式写出来啊qwq 多做点数据结构。由队长的建议，要补区域赛的数据结构题。 A. 整点正方形计数2 赛时队友写了一个非常诡异的做法过掉了，赛后看来想复杂了。 M. 并行计算 为啥能不去想这个题啊。 首先先把前缀和算出来，然后再减去上一个最近是 111 的位置的前缀和值，也就是 yi×siy_i\\times s_iyi​×si​ 的前缀最大值。 由于 1024=3221024=32^21024=322，因此直接将序列分块，即可比分治更优地完成前缀操作。 C. 造桥与砍树 F. 连线博弈 Fun Fact：我之前做过 SG 函数的递推式长得跟这个一样得题，但是一点瞪不出 SG 函数的规律。感谢队友神力了。 H. 教师 trio https://qoj.ac/contest/1252 也算是勉强打上金牌线了，主要是我的 I 分类讨论讨错了，我在干什么🤣 I. Linear Fractional Transformation 硬解方程，由于 c,dc,dc,d 中至多只有一个是零，分别尝试将所有数用 c,dc,dc,d 表示即可。 来打 CF，用的小号，打 Div.2，https://codeforces.com/contest/2151。 怎么 C 都不会了，还是要充满决心啊！ C. Limited Edition Shop 其实一开始想的就是对的，唉。 搞了新的小号来打 Div.3。james2StormEye！ https://codeforces.com/contest/2149 无语了，怎么能卡 F。 某些小事情：/posts/71998f63/。 补 https://qoj.ac/contest/2238。 G. 矩阵 for (int i = 1; i = n; ++i) for (int j = 1; j = n; ++j) cout j + (i - 1) * p [j == n]; pnpnpn。 trio https://qoj.ac/contest/1305 打的还可以吧。 E. Buy and Delete 被队友想出做法后遥控我写完了，然后发现这个东西很对。 唉怎么每天都有一万道题需要做。 感觉是时候寻找一些全新的可能性了，iznomia。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-15(#2)：漂浮于重力之上","path":"/posts/c967b560/","content":"AxR —— Levitation [EC Online 2025 II] DAG Query 我了个假 DAG 啊。 忘了拉格朗日插值怎么推的了。 有板子真的，最多三分钟。 无语了，只能说幸好没掉出前六。 solo https://qoj.ac/contest/1799 G. Game 直接模拟即可，需要等比数列求和。 L. 502 Bad Gateway 我的写法需要开 int128。 另外我推得的答案总是小 111😂，不知道为什么，可能题读错了，直接加上就好了。 D. Query on Tree K. Match 有一百万道题需要补。 trio https://qoj.ac/contest/1053 E. Identical Parity 被硬控了😭 我觉得还是需要写出 exgcd 的通解。 D. Frozen Scoreboard C. DFS Order 2 这真的比 G 简单吗😨 肯定要树形 DP，但是不难发现一个事情：关注子树内的信息是极其诡异的，因为 DFS 序只和子树外面是怎么走的有关。 G. Quick Sort 快速排序的答案是 O(nlog⁡n)O(n\\log n)O(nlogn) 级别的，只是暴力找比哨兵大 / 小的数交换到 右 / 左边很慢，搞个数据结构优化一下即可。 L. Tree Distance 加强代码能力，加强体力（以及读题能力）。学数学，做 DP，练数据结构，如果可以还需要学图论和串。 妈的干不完了，我想打金。 要不找机会 VP 一场 CF。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-08-30(#1)：重新开始","path":"/posts/cfb4593d/","content":"又回来了，又能持续多久呢？ Sakuzyo —— Lost Memory CF2128D Sum of LDS 注意到以 iii 为右端点的区间的 LDS，一定可以以 iii 或者 i−1i-1i−1 结尾，然后就完成了。 做 https://qoj.ac/contest/1986 A. 删除01串 分讨。 C. 砝码 分讨。 G. 萤火虫难题 注意 111 和任何数都互质。 D. 最近公共祖先 来写简单数据结构！感觉比 H、I、J 都要简单啊。 总结一下两棵树类的问题：在一棵树上进行操作（点分治等），然后统计另一棵树上的信息。 LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。 CF2135B For the Champion 记得使用演算纸而不是 iPad。 qoj 11736 Three Arrays STL 二分记得判断二分出来的东西是否在答案区间内。 感觉 https://qoj.ac/contest/1885 很不错。 [EC Online 2025 I] Moving on the Plane 为啥不会啊。 见 NOI 一轮复习 I：杂项。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"一场因神秘力量影响而发生的事故","path":"/posts/9b7cfc66/","content":"源于一场使用 XeLaTeX 编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。最后切换至 LuaTeX 解决了该问题。 问题概述 最近在准备假期给小朋友讲课用的课件，但是遇到了一个问题：编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。我查阅了曾经做过的课件（只能找到 pdf，源码已丢失），发现它们的大小是正常的。 这让人很苦恼，因为一个课件有上百页，对于一张 2MB 的背景来说，会使得这个课件膨胀至 300MB 的大小，非常的恐怖。所以这是一个继续修复的问题。 有趣的是，如果把这个膨胀的 pdf 打成 zip 那么它没怎么被压缩，而打成 7z 可以压缩至正常大小。原来 zip 这么菜的，以后有机会要研究一下。 问题分析 deepsleep 给出了使用 background 的解决方式。经过我的尝试这好像不起作用。我认为这应该是给 LaTeX 文档用的而不是 beamer。如果是我的问题，请在评论区告诉我。 我曾经在其它环境上使用过 XeTeX 并没有出现上述情况，可能是我现在使用的环境的 XeTeX 有点问题。反正很神秘。 经测试 pdfTeX 可以正常工作，但是因为我需要改字体，所以最终换成了 LuaTeX，问题得以解决。 总结 感觉自己没有解决实际问题的能力。需要学会如何高效地使用搜索引擎寻找答案，并适当的使用 AI 辅助来解决问题。 否则到时候遇到一点自己不会的东西，忙了一个下午不知道自己在忙什么，那就有点搞笑了！","tags":["TeX"]},{"title":"继续寻找人生的下一块拼图","path":"/posts/57c4317c/","content":"图片来源：高考之后人生第一次打凋灵风暴，图为准备进行第二次共生体战以获取用于制作恐怖炸弹的指令附魔书。 令人迷茫的现状 你应该知道我位于辽宁省，昨天查完 2025 年高考的分数。和我的估分差不多，但这个结果也确实不能令人满意。按照曾经的标准就是“没学上了”。 我可以说我拆括号拆错（你可以简单的理解为我计算出了 2(x+3)=2x+32(x+3)=2x+32(x+3)=2x+3）丢了 101010 分很糖，也可以说少刷 505050 套数学卷数学也是这个分，省下来的时间去学物理显然更赚。但不管怎样高考已经结束，复读也是不可能的。只能祝愿还没高考的同学不要犯糖。 只能安慰自己都一样了！自己就是一个普通人而已啦~ 动力源于创作，创作源于生活 后记 不要问我去了哪里。如果某天我想说出来，我会自己写出来的。 就这样吧，要做的事情还有很多，可是自己总是很懒。"},{"title":"CodeTON Round 4 题解","path":"/posts/4ded5892/","content":"避雷：H 我不会。 随便写写吧：https://codeforces.com/contest/1810. 终于更完了，james1 你也是够懒的。 A. Beautiful Sequence 如果有一个数满足 ai≥ia_i\\geq iai​≥i 即可。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n, flag = 0; cin n; for (int i = 1, x; i = n; ++i) cin x; if (x = i) flag = 1; cout (flag ? YES : NO );int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; B. Candies 不难发现决策是唯一的。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n; cin n; vectorint ans; while (n % 2 n 1) if ((n 1) 1) ans.push_back(2), n = 1; else ans.push_back(1), n = (n 1) + 1; if (n != 1) return cout -1 , void(); reverse(ans.begin(), ans.end()); cout ans.size() ; for (int i : ans) cout i ; cout ;int main(void) ios::sync_with_stdio(0); int T = 1; cin T; while (T--) solve(); return 0; C. Make It Permutation 枚举结束的数字即可。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 1e5 + 5;int n, c, d;int a[N];void solve(void) cin n c d; for (int i = 1; i = n; ++i) cin a[i]; sort(a + 1, a + n + 1); int m = unique(a + 1, a + n + 1) - (a + 1); i64 ans = 1ll * m * c + d; for (int i = 1; i = m; ++i) ans = min(ans, 1ll * (a[i] - i) * d + 1ll * (m - i) * c); cout ans + 1ll * c * (n - m) ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; D. Climbing the Tree 蜗牛爬水井是小学时非常常见的脑筋急转弯题，要注意蜗牛可能会直接爬出水井。 对于本题来说，我们需要用更为一般的代数手段，也就是不等式组描述这个问题。给条件相当于要解出一组取值范围看能否与之前的合并，问能否爬出相当于要对于当前的高度取值范围 [L,R][L,R][L,R]，分别看高度为 L,RL,RL,R 时所需的爬出天数（显然这个函数是单调递增的）。 先来看第一个问题。什么时候高度最大？第 nnn 天需要爬 aaa 时，即 (n−1)×(a−b)+a(n-1)\\times (a-b) + a(n−1)×(a−b)+a。最小呢？第 n−1n-1n−1 天白天爬完之后还剩 111 的高度没有爬完，以至于需要第 nnn 天接着爬。 再来看第二个问题。不妨设高度为 hhh，那么要满足 an−b(n−1)≥han - b(n-1) \\geq han−b(n−1)≥h，将 nnn 解出向上取整即可。 有点小细节但不多，比如天数为 111 需要特判之类的。样例非常友好，写挂了全能调出来。 #include bits/stdc++.husing namespace std;typedef long long i64;i64 calc(i64 h, int a, int b) if (a = h) return 1; // (a - b)n = h - b return (h - b + a - b - 1) / (a - b);void solve(void) int q; cin q; i64 L = 1, R = 2e18; while (q--) int op, a, b; i64 n; cin op a b; if (op == 1) cin n; i64 r = (n - 1) * (a - b) + a; i64 l = (n == 1 ? 1 : (n - 2) * (a - b) + a + 1); if (l R || r L) cout 0 ; else cout 1 ; L = max(L, l); R = min(R, r); else // cerr L R E$TD ; i64 n1 = calc(L, a, b), n2 = calc(R, a, b); if (n1 != n2) cout -1 ; else cout n1 ; cout ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; E. Monsters 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 2e5 + 5;int n, m, a[N], vis[N];vectorint G[N];bool work(int x) #define pii pairint, int priority_queuepii, vectorpii, greaterpii q; q.emplace(0, x); int cnt = 0; while (!q.empty()) int u = q.top().second; q.pop(); if (vis[u] == x) continue; vis[u] = x; ++cnt; if (a[u] = cnt) return 0; for (int v : G[u]) if (vis[v] != x) q.emplace(a[v], v); return cnt == n;void solve(void) cin n m; for (int i = 1; i = n; ++i) vectorint().swap(G[i]), cin a[i]; while (m--) int u, v; cin u v; G[u].emplace_back(v); G[v].emplace_back(u); memset(vis, 0, sizeof vis); for (int i = 1; i = n; ++i) if (a[i] == 0 vis[i] == 0) if (work(i)) return cout YES , void(); cout NO ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; G. The Maximum Prefix 直接做怎么做？设 fif_ifi​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后刷表转移对于每个状态是 O(1)O(1)O(1) 的，炸了。 需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。 #include bits/stdc++.husing namespace std;typedef long long i64;const int P = 1000000007;const int N = 5e3 + 5;inline int poww(int a, int b) int r = 1; for (; b; b = 1, a = 1ll * a * a % P) if (b 1) r = 1ll * r * a % P; return r;inline int inv(int x) return poww(x, P - 2); inline void add(int x, i64 k) x = (x + k) % P; int n;int p[N];int f[N][N];void solve(void) cin n; for (int i = 1; i = n; ++i) int x, y; cin x y; p[i] = 1ll * x * inv(y) % P; for (int i = 0; i = n + 2; ++i) for (int j = 0; j = n + 2; ++j) f[i][j] = 0; for (int i = 0; i = n; ++i) cin f[0][i]; for (int i = 0; i n; ++i) for (int j = 0; j = n; ++j) if (f[i][j]) // i + 1 位置填 1 if (j) add(f[i + 1][j - 1], 1ll * p[i + 1] * f[i][j]); // i + 1 位置填 -1 add(f[i + 1][j + 1], 1ll * (1 + P - p[i + 1]) * f[i][j]); if (j == 0) add(f[i + 1][0], 1ll * (1 + P - p[i + 1]) * f[i][j]); for (int i = 1; i = n; ++i) cout f[i][0] [i == n];int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0;","tags":["算法竞赛","Codeforces"],"categories":["算法竞赛","Codeforces"]},{"title":"我回来了","path":"/posts/a5aedc5a/","content":"搬家了！这里是新博客。以前的内容会逐步搬迁。 这里主要测试一些内容，回归文章一段时间之后会写。 公式部分 ap−1≡1(modp) a^{p-1}\\equiv 1 \\pmod p ap−1≡1(modp) ∇⋅D=ρf∇⋅B=0∇×E=−∂B∂t∇×H=Jf+∂D∂t\\begin{array}{l} abla \\cdot \\mathbf{D} =\\rho _f \\\\ abla \\cdot \\mathbf{B} = 0 \\\\ abla \\times \\mathbf{E} = -\\cfrac{\\partial \\mathbf{B}}{\\partial t } \\\\ abla \\times \\mathbf{H} = \\mathbf{J}_f + \\cfrac{\\partial \\mathbf{D}}{\\partial t } \\end{array} ∇⋅D=ρf​∇⋅B=0∇×E=−∂t∂B​∇×H=Jf​+∂t∂D​​ 代码部分 这里测试一些代码。 cpp #include bits/stdc++.husing namespace std;int main(void) cout Hello World! ; return 0; yaml stellar: version: 1.30.1 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar main_css: /css/main.css main_js: /js/main.js"},{"title":"探索者笔记","path":"/explore/index/index.html","content":"你若问我这里是什么，只是 iznomia 无聊时写的一点文字而已啦~ 如果你找到了某些共鸣，欢迎在评论区与我交流~"},{"title":"探索者笔记","path":"/explore/music/index.html","content":"曲名 艺术家 Löschen BlackY feat. Risa Yuzuki Infection ARForest Impossible Two Steps From Hell Glacier Laur The Promise Globus world.execute (me) ; Mili 虚幻与现实 华晨宇 Poet of the Stars Cre-sc3NT #1f1e33 (Another long “#ant1p01e” version) かめりあ Floating Star Kirara Magic feat. Shion Lee 喜欢的音乐家 华晨宇Two Steps From HellThomas BergersenCamelliaLaurSakuzyoAshrount打打だいずvoid (Mournfinale)BlackYa_hisaAxRARForestCre-sc3NTKirara Magic月下散落出世"},{"title":"探索者笔记","path":"/explore/todo/index.html","content":"暂时没有内容。"},{"title":"微积分 A2","path":"/wiki/maths/0-2.html","content":"1. 多元函数微分学 在多元函数中，邻域泛指圆邻域和方邻域。任意一个点 A∈R2A\\in \\mathbb R^2A∈R2 都可以被归类为 E⊂R2E\\sub \\mathbb R^2E⊂R2 的内点、外点和界点。界点的集合称为边界，记作 ∂E\\partial E∂E。 如果 EEE 中的每一个点都是内点，则 EEE 为开集。若 EEE 为连通的开集，那么 EEE 称为 R2\\mathbb R^2R2 中的开区域，简称区域，E‾=E∪∂E\\overline E=E\\cup \\partial EE=E∪∂E 称作闭区域。 聚点：点 AAA 的任意 U˚(A)\\mathring U(A)U˚(A) 内都含有 EEE 中的点，则称 AAA 为聚点，等价于任何 U(A)U(A)U(A) 包含 EEE 的无穷多个点。 孤立点：A∈EA\\in EA∈E，但是 AAA 不是聚点。比如 E={(1,1)}E=\\{(1,1)\\}E={(1,1)}，就只含有一个孤立点。 显然，孤立点一定是界点，内点和非孤立的界点一定是聚点，既不是聚点又不是孤立点一定是外点。 如果 EEE 的所有聚点都属于 EEE，那么 EEE 是闭集。可以证明，E⊂R2E\\sub \\mathbb R^2E⊂R2 是开集，则 EcE^cEc 是闭集，反之同理。 重极限：f(P)f(P)f(P) 是定义在 DDD 上的多元函数，设 P0P_0P0​ 是 DDD 的一个聚点，∀ϵ0,∃δ0,i.e.⁡P∈D∩U˚(P0,δ),∣f(P)−A∣ϵ\\forall \\epsilon0,\\exist \\delta 0,\\ie P\\in D\\cap \\mathring U(P_0,\\delta),|f(P)-A|\\epsilon∀ϵ0,∃δ0,i.e.P∈D∩U˚(P0​,δ),∣f(P)−A∣ϵ，则 lim⁡P→P0f(P)=A\\lim_{P\\to P_0} f(P)=AlimP→P0​​f(P)=A。 若重极限和所有累次极限都存在时，它们必然相等。 多元函数连续是多元函数关于单变量连续的充分不必要条件。 1.1 偏导数 偏导数的符号 fx(x0,y0)=∂z∂xf_{x}(x_0,y_0)=\\dfrac{\\partial z}{\\partial x}fx​(x0​,y0​)=∂x∂z​ 是一个整体，不能当作“微分算子”之类的东西进行约分之类的操作。 ∂2z∂x∂y\\dfrac{\\partial^2 z}{\\partial x \\partial y}∂x∂y∂2z​ 代表先对 xxx 再对 yyy 求偏导。若所有混合偏导数连续时，则调换偏导顺序不会对结果产生影响。 1.2 全微分 若全增量可以表示为 Δz=f(x0+Δx,y0+Δy)−f(x0,y0)=AΔx+BΔy+o(ρ)\\Delta z=f(x_0+\\Delta x,y_0+\\Delta y)-f(x_0,y_0)=A\\Delta x+B\\Delta y+o(\\rho)Δz=f(x0​+Δx,y0​+Δy)−f(x0​,y0​)=AΔx+BΔy+o(ρ)，其中 ρ=(Δx)2+(Δy)2\\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}ρ=(Δx)2+(Δy)2​，那么函数在 (x0,y0)(x_0,y_0)(x0​,y0​) 可微，且 dz=AΔx+BΔy\\d z=A\\Delta x+B\\Delta ydz=AΔx+BΔy。 二元函数在可微的必要不充分条件是连续且两个偏导存在，若可微则 dz=fx(x0,y0)dx+fy(x0,y0)dy\\d z=f_x(x_0,y_0)\\d x+f_y(x_0,y_0)\\d ydz=fx​(x0​,y0​)dx+fy​(x0​,y0​)dy。 在一点偏导数连续是可微的充分不必要条件。 dnz=∑k=0n(nk)∂nz∂kx∂n−kydkxdn−ky\\d^n z=\\sum_{k=0}^n\\binom n k \\frac{\\partial ^n z}{\\partial^k x\\partial ^{n-k}y}\\d^k x \\d^{n-k} y dnz=k=0∑n​(kn​)∂kx∂n−ky∂nz​dkxdn−ky 1.4 方向导数和梯度 el=(cos⁡α,cos⁡β)\\bm e_l=(\\cos \\alpha,\\cos\\beta)el​=(cosα,cosβ) 方向的方向导数定义为 ∂f∂l∣(x0,y0)=lim⁡t→0+f(x0+tcos⁡α,y0+tcos⁡β)−f(x0,y0)t\\displaystyle \\frac{\\partial f}{\\partial l}\\Big |_{(x_0,y_0)}=\\lim_{t\\to 0^+}\\frac{f(x_0+t\\cos\\alpha,y_0+t\\cos\\beta)-f(x_0,y_0)}{t}∂l∂f​​(x0​,y0​)​=t→0+lim​tf(x0​+tcosα,y0​+tcosβ)−f(x0​,y0​)​，当函数在 (x0,y0)(x_0,y_0)(x0​,y0​) 可微时，∂f∂l∣(x0,y0)=fx(x0,y0)cos⁡α+fy(x0,y0)cos⁡β\\displaystyle \\frac{\\partial f}{\\partial l}\\Big |_{(x_0,y_0)}=f_x(x_0,y_0)\\cos\\alpha+f_y(x_0,y_0)\\cos\\beta∂l∂f​​(x0​,y0​)​=fx​(x0​,y0​)cosα+fy​(x0​,y0​)cosβ。 二元函数的梯度定义为 grad⁡f=∇f=(fx(x0,y0),fy(x0,y0))\\operatorname{grad} f= abla f=(f_x(x_0,y_0),f_y(x_0,y_0))gradf=∇f=(fx​(x0​,y0​),fy​(x0​,y0​))。 因此不难发现，∂f∂l∣(x0,y0)=∇f⋅el=∣∇f∣cos⁡θ\\displaystyle \\frac{\\partial f}{\\partial l}\\Big |_{(x_0,y_0)}= abla f\\cdot \\bm e_l=| abla f|\\cos \\theta∂l∂f​​(x0​,y0​)​=∇f⋅el​=∣∇f∣cosθ，因此方向导数的最大值为梯度方向。"},{"title":"微积分 A1","path":"/wiki/maths/0-1.html","content":"1. 前置知识 邻域：U(a,δ)=(a−δ,a+δ),U˚(a,δ)=(a−δ,a)∪(a,a+δ)U(a,\\delta)=(a-\\delta,a+\\delta),\\mathring{U}(a,\\delta)=(a-\\delta,a)\\cup(a,a+\\delta)U(a,δ)=(a−δ,a+δ),U˚(a,δ)=(a−δ,a)∪(a,a+δ)。 用 inf⁡(S),sup⁡(S)\\inf(S),\\sup(S)inf(S),sup(S) 来表示 SSS 的下确界和上确界。 1.1 集合的势 对于集合 A,BA,BA,B，如果存在一个从 AAA 到 BBB 的一一映射，则称集合 AAA 和 BBB 对等，记作 A∼BA\\sim BA∼B，称 AAA 和 BBB 有相同的势（基数）。 设 N\\mathbb NN 的基数是 ℵ0\\aleph_0ℵ0​（阿列夫零），如果一个集合 AAA 的势是 ℵ0\\aleph_0ℵ0​，那么 AAA 是可数集。 1.2 实数 若 ∀ϵ0,∃N,i.e.⁡nN,∣xn−a∣ϵ\\forall \\epsilon0,\\exist N,\\ie nN,|x_n-a|\\epsilon∀ϵ0,∃N,i.e.nN,∣xn​−a∣ϵ，则记 lim⁡n→∞xn=a\\lim_{n\\to\\infty}x_n=alimn→∞​xn​=a。 夹逼定理：给定三个数列 xn,yn,zn{x_n},{y_n},{z_n}xn​,yn​,zn​，若满足： ∃K,s.t.⁡nK,yn≤xn≤zn\\exist K,\\operatorname{s.t.} nK,y_n\\le x_n\\le z_n∃K,s.t.nK,yn​≤xn​≤zn​， lim⁡n→∞yn=lim⁡n→∞zn=a\\lim\\limits_{n\\to\\infty}y_n=\\lim\\limits_{n\\to\\infty}z_n=an→∞lim​yn​=n→∞lim​zn​=a， 则 lim⁡n→∞xn=a\\lim\\limits_{n\\to\\infty}x_n=an→∞lim​xn​=a。 Cauchy 收敛准则：数列收敛的充要条件是 ∀ϵ0,∃N,i.e.⁡n,mN,∣xn−xm∣ϵ\\forall \\epsilon0,\\exist N,\\ie n,mN,|x_n-x_m|\\epsilon∀ϵ0,∃N,i.e.n,mN,∣xn​−xm​∣ϵ。 两个重要极限： lim⁡x→0sin⁡xx=1\\displaystyle \\lim_{x\\to 0} \\frac{\\sin x}{x}=1x→0lim​xsinx​=1； lim⁡x→∞(1+1x)x=e\\displaystyle \\lim_{x\\to\\infty}\\left(1+\\frac 1 x\\right)^x=ex→∞lim​(1+x1​)x=e。 复合函数的极限：若 lim⁡x→x0u(x)=u0,lim⁡u→u0f(u)=A\\displaystyle\\lim_{x\\to x_0} u(x)=u_0,\\lim_{u\\to u_0}f(u)=Ax→x0​lim​u(x)=u0​,u→u0​lim​f(u)=A，且在 U˚(x0,δ)\\mathring{U}(x_0,\\delta)U˚(x0​,δ) 内 u(x)≠u0u(x) e u_0u(x)=u0​，则 lim⁡x→x0f[u(x)]=A\\lim\\limits_{x\\to x_0}f[u(x)]=Ax→x0​lim​f[u(x)]=A。也就是说，内层函数的值一定不能是常数（但可以是无穷）。 1.1 反函数 假设函数 y=f(x)y=f(x)y=f(x) 从 DDD 映射到 WWW，那么反函数 y=f−1(x)y=f^{-1}(x)y=f−1(x) 从 WWW 映射到 DDD。因此，存在反函数的充要条件每个 DDD 映射到的 WWW 都不相同。对于连续函数来说，就需要单调。 1.2 初等函数 cot⁡x=cos⁡xsin⁡x≠1tan⁡xcot⁡x=1tan⁡xsec⁡x=1cos⁡xcsc⁡x=1sin⁡x\\begin{aligned} \\cot x = \\frac{\\cos x}{\\sin x} e \\frac{1}{\\tan x}\\\\ \\cot x = \\frac 1 {\\tan x}\\\\ \\sec x = \\frac 1 {\\cos x}\\\\ \\csc x =\\frac {1}{\\sin x} \\end{aligned} cotx=sinxcosx​=tanx1​cotx=tanx1​secx=cosx1​cscx=sinx1​​ arcsin⁡\\arcsinarcsin 从 [−1,1][-1,1][−1,1] 映射到 [−π2,π2][-\\frac \\pi 2,\\frac \\pi 2][−2π​,2π​]，arccos⁡\\arccosarccos 从 [−1,1][-1,1][−1,1] 映射到 [0,π][0,\\pi][0,π]，arctan⁡\\arctanarctan 从 R\\RR 映射到 (−π2,π2)(-\\frac \\pi 2,\\frac \\pi 2)(−2π​,2π​)，arccot⁡\\arccotarccot 从 R\\RR 映射到 (0,π)(0,\\pi)(0,π)。 sinh⁡x=ex−e−x2cosh⁡x=ex+e−x2tanh⁡x=ex−e−xex+e−x\\sinh x=\\frac{e^x-e^{-x}}{2}\\\\ \\cosh x=\\frac{e^x+e^{-x}}{2}\\\\ \\tanh x=\\frac{e^x-e^{-x}}{e^x+e^{-x}} sinhx=2ex−e−x​coshx=2ex+e−x​tanhx=ex+e−xex−e−x​ 因此： cosh⁡2x−sinh⁡2x=1sinh⁡2x=2sinh⁡xcosh⁡xcosh⁡2x=cosh⁡2x+sinh⁡2x\\cosh^2 x -\\sinh^2 x=1\\\\ \\sinh 2x=2\\sinh x \\cosh x\\\\ \\cosh 2x=\\cosh^2 x +\\sinh^2 x cosh2x−sinh2x=1sinh2x=2sinhxcoshxcosh2x=cosh2x+sinh2x 1.3 连续 若 ∀ϵ0,∃δ0,i.e.⁡∀x∈U(x0,δ),∣f(x)−f(x0)∣ϵ\\forall \\epsilon 0,\\exist \\delta 0,\\ie \\forall x\\in U(x_0,\\delta),|f(x)-f(x_0)|\\epsilon∀ϵ0,∃δ0,i.e.∀x∈U(x0​,δ),∣f(x)−f(x0​)∣ϵ，那么 f(x)f(x)f(x) 在 x0x_0x0​ 连续。也就是 lim⁡x→x0f(x)=f(x0)\\lim_{x\\to x_0} f(x)=f(x_0)limx→x0​​f(x)=f(x0​)。 若 f(x)f(x)f(x) 在 x0x_0x0​ 不连续（f(x0)f(x_0)f(x0​) 无定义，f(x0)f(x_0)f(x0​) 有定义但是极限不存在，有定义且极限存在但是不等于 f(x0)f(x_0)f(x0​)），但是 x0x_0x0​ 左右极限都存在（这里约定极限为无穷则是不存在），那么这是第一类间断点，否则是第二类间断点。 若极限存在，那么是可去间断点。如果左右极限不相等，那么是跳跃间断点，左右极限之差为跃度。若是震荡的（如 f(x)=sin⁡1xf(x)=\\sin \\frac 1 xf(x)=sinx1​），则是震荡间断点，若左或右极限为无穷，则是无穷间断点。若 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续，(a,b)(a,b)(a,b) 可导，则 f′(x)f(x)f′(x) 只可能存在震荡间断点[1]。 f(x)=sin(1/x) 连续函数做四则运算后在定义域范围内依然是连续函数。 若 f(x)f(x)f(x) 是 IxI_xIx​ 上单调的连续函数，那么 f−1(x)f^{-1}(x)f−1(x) 是 IyI_yIy​ 上单调性与原函数相同的连续函数。 复合函数的连续性：若 lim⁡x→x0g(x)=u0\\displaystyle \\lim_{x\\to x_0} g(x)=u_0x→x0​lim​g(x)=u0​（也就是说 g(x)g(x)g(x) 在 x0x_0x0​ 处连续），且 y=f(u)y=f(u)y=f(u) 在 u0u_0u0​ 连续，那么 lim⁡x→x0f(g(x))=f(u0)\\displaystyle \\lim_{x\\to x_0} f(g(x)) = f(u_0)x→x0​lim​f(g(x))=f(u0​)，f(g(x))f(g(x))f(g(x)) 在 x0x_0x0​ 处连续。 我们通常用 f(x)∈C[a,b]f(x)\\in C[a,b]f(x)∈C[a,b] 表示 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上连续，f(x)∈Ck[a,b]f(x)\\in C^k[a,b]f(x)∈Ck[a,b] 表示其 kkk 阶导函数在 [a,b][a,b][a,b] 上连续。 一致连续：f(x)f(x)f(x) 在区间 III 上有定义，∀ϵ0,∃δ0,∀∣x1−x2∣δ,∣f(x1)−f(x2)∣ϵ\\forall \\epsilon 0,\\exist \\delta 0,\\forall |x_1-x_2| \\delta,|f(x_1)-f(x_2)|\\epsilon∀ϵ0,∃δ0,∀∣x1​−x2​∣δ,∣f(x1​)−f(x2​)∣ϵ，那么 f(x)f(x)f(x) 在 III 一致连续。 若 f(x)f(x)f(x) 在闭区间上连续，那么也一致连续。 证明：f(x)=1xf(x)=\\frac 1 xf(x)=x1​ 在 (0,1)(0,1)(0,1) 不一致连续。在 δ\\deltaδ 确定的情况下，取 x1=1n,x2=1n+1x_1=\\frac 1 n,x_2=\\frac 1 {n+1}x1​=n1​,x2​=n+11​，而且要求 1n2δ\\frac 1 {n^2} \\deltan21​δ，那么 ∣x1−x2∣=1n(n+1)1n2δ|x_1-x_2| = \\frac 1 {n(n+1)}\\frac 1 {n^2}\\delta∣x1​−x2​∣=n(n+1)1​n21​δ，此时 ∣f(x1)−f(x2)∣=1|f(x_1)-f(x_2)|=1∣f(x1​)−f(x2​)∣=1。若 ϵ=0.9\\epsilon=0.9ϵ=0.9，则不满足定义。 1.4 无穷小与无穷大 若 lim⁡x→x0βα=C\\lim_{x\\to x_0}\\frac \\beta\\alpha=Climx→x0​​αβ​=C，则 β=O(α)\\beta =O(\\alpha)β=O(α)，同阶无穷小； 若 lim⁡x→x0βα=0\\lim_{x\\to x_0}\\frac \\beta\\alpha=0limx→x0​​αβ​=0，则 β=o(α)\\beta =o(\\alpha)β=o(α)； 若 lim⁡x→x0βαk=C(C≠0)\\lim_{x\\to x_0}\\frac \\beta{\\alpha ^k}=C(C e 0)limx→x0​​αkβ​=C(C=0)，则 β=O(αk)\\beta =O(\\alpha^k)β=O(αk)，β\\betaβ 是 α\\alphaα 的 kkk 阶无穷小。 等价无穷小可以在乘除法中替换。 x→0x\\to 0x→0 时，sin⁡x∼x,tan⁡x∼x,arcsin⁡x∼x,arctan⁡x∼x,ln⁡(1+x)∼x,ex−1∼x,1−cos⁡x∼x22\\sin x\\sim x,\\tan x\\sim x,\\arcsin x\\sim x,\\arctan x\\sim x,\\ln(1+x)\\sim x,e^x-1\\sim x,1-\\cos x\\sim \\frac{x^2} 2sinx∼x,tanx∼x,arcsinx∼x,arctanx∼x,ln(1+x)∼x,ex−1∼x,1−cosx∼2x2​。 αn×o(αm)=o(αn+m)\\alpha^n \\times o(\\alpha^m)=o(\\alpha^{n+m})αn×o(αm)=o(αn+m)。 2. 导数与微分 与切线垂直的直线为法线。 可导需要连续，且左导数等于右导数。 2.1 求导与微分 初等函数的导数： (ax)′=axln⁡a(log⁡ax)′=1xln⁡asin⁡′x=cos⁡xcos⁡′x=−sin⁡xtan⁡′x=sec⁡2xcot⁡′x=−csc⁡2xsec⁡′x=sec⁡xtan⁡xcsc⁡′x=−csc⁡xcot⁡xarcsin⁡′x=11−x2arccos⁡′x=−11−x2arctan⁡′x=11+x2arccot⁡′x=−11+x2sinh⁡′x=cosh⁡xcosh⁡′x=sinh⁡x\\begin{aligned} (a^x)=a^x\\ln a (\\log_a x)=\\frac{1}{x\\ln a}\\\\ \\sinx =\\cos x \\cos x=-\\sin x\\\\ \\tanx =\\sec^2 x \\cotx =-\\csc^2 x\\\\ \\secx =\\sec x\\tan x \\csc x=-\\csc x\\cot x\\\\ \\arcsinx =\\frac{1}{\\sqrt{1-x^2}} \\arccosx =-\\frac{1}{\\sqrt{1-x^2}}\\\\ \\arctanx =\\frac{1}{1+x^2} \\arccotx =-\\frac{1}{1+x^2}\\\\ \\sinhx = \\cosh x \\coshx = \\sinh x \\end{aligned} (ax)′=axlnasin′x=cosxtan′x=sec2xsec′x=secxtanxarcsin′x=1−x2​1​arctan′x=1+x21​sinh′x=coshx​​​​​​(loga​x)′=xlna1​cos′x=−sinxcot′x=−csc2xcsc′x=−cscxcotxarccos′x=−1−x2​1​arccot′x=−1+x21​cosh′x=sinhx​ 反函数求导法则：若函数 x=φ(y)x=\\varphi(y)x=φ(y) 单调可导，且 φ′(y)≠0\\varphi(y) e 0φ′(y)=0，则反函数 y=f(x)y=f(x)y=f(x) 可导，f′(x)=dydx=1dxdy=1φ′(y)∣y=f(x)=1φ′(f(x))\\displaystyle f(x)=\\frac{\\d y}{\\d x}=\\frac{1}{\\frac{\\d x}{\\d y}}=\\frac{1}{\\varphi(y)}\\Bigg |_{y=f(x)} =\\frac{1}{\\varphi(f(x))}f′(x)=dxdy​=dydx​1​=φ′(y)1​​y=f(x)​=φ′(f(x))1​。 计算 y=arcsin⁡xy=\\arcsin xy=arcsinx 的导数。x=sin⁡yx=\\sin yx=siny，因此 y′=1dxdy=1cos⁡y=11−sin⁡2y=11−x2y=\\dfrac{1}{\\frac{\\d x}{\\d y}}=\\dfrac{1}{\\cos y}=\\dfrac{1}{\\sqrt{1-\\sin^2 y}}=\\dfrac{1}{\\sqrt{1-x^2}}y′=dydx​1​=cosy1​=1−sin2y​1​=1−x2​1​。 复合函数求导法则：y=f(u),u=g(x)y=f(u),u=g(x)y=f(u),u=g(x)，那么 y=f(g(x))y=f(g(x))y=f(g(x)) 求导为 dydx=dydu⋅dudx=f′(u)g′(x)\\displaystyle\\frac{\\d y}{\\d x}=\\frac{\\d y}{\\d u}\\cdot \\frac{\\d u}{\\d x}=f(u)g(x)dxdy​=dudy​⋅dxdu​=f′(u)g′(x)。 f′′(x)=df′(x)dx=ddydxdx=d2ydx2\\displaystyle f(x)=\\frac{\\d f(x)}{\\d x}=\\frac{\\d \\frac{\\d y}{\\d x}}{\\d x}=\\frac{\\d^2 y}{\\d x^2}f′′(x)=dxdf′(x)​=dxddxdy​​=dx2d2y​。 (xμ)(n)=μn‾xμ−n(ax)(n)=axln⁡na(sin⁡x)(n)=sin⁡(x+n⋅π2)(cos⁡x)(n)=cos⁡(x+n⋅π2)(x^\\mu)^{(n)}=\\mu^{\\underline{n}} x^{\\mu - n}\\\\ (a^x)^{(n)}=a^x \\ln^n a\\\\ (\\sin x)^{(n)}=\\sin\\left(x+n\\cdot \\frac \\pi 2\\right)\\\\ (\\cos x)^{(n)}=\\cos\\left(x+n\\cdot \\frac \\pi 2\\right) (xμ)(n)=μn​xμ−n(ax)(n)=axlnna(sinx)(n)=sin(x+n⋅2π​)(cosx)(n)=cos(x+n⋅2π​) Leibniz 公式：(uv)(n)=∑i=0n(ni)u(n−i)v(i)\\displaystyle (uv)^{(n)}=\\sum_{i=0}^n\\binom{n}{i}u^{(n-i)} v^{(i)}(uv)(n)=i=0∑n​(in​)u(n−i)v(i)。 隐函数求导：等式两边求导，等式两边取对数。 若给定参数方程： {x=x(t),y=y(t),\\begin{cases} x=x(t),\\\\ y=y(t), \\end{cases} {x=x(t),y=y(t),​ 如果可以确定 yyy 是 xxx 的函数，那么 dydx=dydt1dxdt=y′(t)x′(t)\\displaystyle\\frac{\\d y}{\\d x}=\\frac{\\d y}{\\d t}\\frac{1}{\\frac{\\d x}{\\d t}}=\\frac{y(t)}{x(t)}dxdy​=dtdy​dtdx​1​=x′(t)y′(t)​。 也有 d2ydx2=ddx(y′(t)x′(t))=ddt(y′(t)x′(t))dtdx=y′′(t)x′(t)−y′(t)x′′(t)(x′(t))3\\displaystyle\\frac{\\d^2 y}{\\d x^2}=\\frac{\\d}{\\d x}\\left(\\frac{y(t)}{x(t)}\\right)=\\frac{\\d}{\\d t}\\left(\\frac{y(t)}{x(t)}\\right)\\frac{\\d t}{\\d x}=\\frac{y(t)x(t)-y(t)x(t)}{\\left(x(t)\\right)^3}dx2d2y​=dxd​(x′(t)y′(t)​)=dtd​(x′(t)y′(t)​)dxdt​=(x′(t))3y′′(t)x′(t)−y′(t)x′′(t)​。 已知 {x=a(t−sin⁡t),y=a(1−cos⁡t),\\begin{cases}x=a(t-\\sin t),\\\\ y=a(1-\\cos t),\\end{cases}{x=a(t−sint),y=a(1−cost),​ 求 d2ydx2\\frac{\\d^2 y}{\\d x^2}dx2d2y​。∵dydx=asin⁡ta(1−cos⁡t)=cot⁡t2,∴d2ydx2=ddxcot⁡t2=ddtcot⁡t2dtdx=−csc⁡2t22⋅1a(1−cos⁡t)=−14acsc⁡4t2.\\displaystyle\\because \\frac{\\d y}{\\d x}=\\frac{a\\sin t}{a(1-\\cos t)}=\\cot \\frac t 2,\\\\\\therefore \\frac{\\d^2 y}{\\d x^2}=\\frac{\\d}{\\d x}\\cot \\frac t 2=\\frac{\\d}{\\d t}\\cot \\frac t 2\\frac{\\d t}{\\d x}=-\\frac{\\csc^2 \\frac t 2}{2}\\cdot \\frac{1}{a(1-\\cos t)}=-\\frac 1{4a}\\csc^4\\frac t 2.∵dxdy​=a(1−cost)asint​=cot2t​,∴dx2d2y​=dxd​cot2t​=dtd​cot2t​dxdt​=−2csc22t​​⋅a(1−cost)1​=−4a1​csc42t​. f′(x)f(x)f′(x) 为微商，dy\\d ydy 为微分。 2.2 微分中值定理 罗尔中值定理：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续，在 (a,b)(a,b)(a,b) 可导，且 f(a)=f(b)f(a)=f(b)f(a)=f(b)，那么 ∃ξ∈(a,b),i.e.⁡f′(ξ)=0\\exist \\xi\\in (a,b),\\ie f(\\xi)=0∃ξ∈(a,b),i.e.f′(ξ)=0。如果要证明 f′(ξ)=kf(\\xi)=kf′(ξ)=k，经常构造 F(x)=f(x)−kxF(x)=f(x)-kxF(x)=f(x)−kx. 拉格朗日中值定理：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续，在 (a,b)(a,b)(a,b) 可导，那么 ∃ξ∈(a,b),i.e.⁡f′(ξ)=f(b)−f(a)b−a\\exist \\xi\\in (a,b),\\ie f(\\xi)=\\dfrac{f(b)-f(a)}{b-a}∃ξ∈(a,b),i.e.f′(ξ)=b−af(b)−f(a)​。 柯西中值定理：f(x),g(x)f(x),g(x)f(x),g(x) 在 [a,b][a,b][a,b] 连续，在 (a,b)(a,b)(a,b) 可导，那么 ∃ξ∈(a,b),i.e.⁡f′(ξ)g′(ξ)=f(b)−f(a)g(b)−g(a)\\exist \\xi\\in (a,b),\\ie \\dfrac{f(\\xi)}{g(\\xi)}=\\dfrac{f(b)-f(a)}{g(b)-g(a)}∃ξ∈(a,b),i.e.g′(ξ)f′(ξ)​=g(b)−g(a)f(b)−f(a)​。 中值定理辅助函数的构造是一门学问，可能不打算研究。 2.3 泰勒公式 当 f(x)f(x)f(x) 在 x0x_0x0​ 处有 nnn 阶导数： Pn(x)=a0+a1(x−x0)+a2(x−x0)2+⋯+an(x−x0)n. P_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)^2+\\cdots+a_n(x-x_0)^n. Pn​(x)=a0​+a1​(x−x0​)+a2​(x−x0​)2+⋯+an​(x−x0​)n. 其中满足 Pn(k)(x0)=f(k)(x0),k∈NP_n^{(k)}(x_0)=f^{(k)}(x_0),k\\in \\NPn(k)​(x0​)=f(k)(x0​),k∈N，因此 i!ai=f(i)(x0)i! a_i=f^{(i)}(x_0)i!ai​=f(i)(x0​)。 f(x)f(x)f(x) 在 x0x_0x0​ 处的 nnn 阶 Taylor 公式：f(x)=Pn(x)+Rn(x)=∑k=0nf(k)(x0)k!(x−x0)k+Rn(x)\\displaystyle f(x)=P_n(x)+R_n(x)=\\sum_{k=0}^n \\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)f(x)=Pn​(x)+Rn​(x)=k=0∑n​k!f(k)(x0​)​(x−x0​)k+Rn​(x)。当 x0=0x_0=0x0​=0 时，退化为麦克劳林公式。 拉格朗日余项：Rn(x)=f(n+1)(ξ)(n+1)!(x−x0)n+1,ξ∈[min⁡(x0,x),max⁡(x0,x)]\\displaystyle R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{n+1}, \\xi\\in [\\min(x_0,x),\\max(x_0,x)]Rn​(x)=(n+1)!f(n+1)(ξ)​(x−x0​)n+1,ξ∈[min(x0​,x),max(x0​,x)]。 Peano 余项：Rn(x)=o((x−x0)n),x→x0R_n(x)=o((x-x_0)^n), x\\to x_0Rn​(x)=o((x−x0​)n),x→x0​。 设 f(x)f(x)f(x) 在 R\\RR 内有二阶导，且 f′′(x)0f(x)0f′′(x)0，且 lim⁡x→0f(x)x2\\lim\\limits_{x\\to 0}\\frac{f(x)}{x^2}x→0lim​x2f(x)​ 存在。证明：∀x≠0,f(x)0\\forall x e 0,f(x)0∀x=0,f(x)0。f(0)=lim⁡x→0f(x)=lim⁡x→0f(x)x2⋅lim⁡x→0x2=0,f′(0)=lim⁡Δx→0f(Δx)−f(0)Δx−0=lim⁡x→0f(x)x=0,f(x)=f(0)+f′(0)+12f′′(ξ)x2,ξ∈[min⁡(0,x),max⁡(0,x)],∵f′′(x)0,∴∀x≠0,f(x)0.f(0)=\\lim\\limits_{x\\to 0}f(x)=\\lim\\limits_{x\\to 0}\\frac{f(x)}{x^2}\\cdot \\lim\\limits_{x\\to 0}x^2 = 0,\\\\f(0)=\\lim\\limits_{\\Delta x\\to 0}\\frac{f(\\Delta x)-f(0)}{\\Delta x - 0}=\\lim\\limits_{x\\to 0}\\frac{f(x)}{x}=0,\\\\f(x)=f(0)+f(0)+\\frac 1 2 f(\\xi)x^2,\\xi\\in[\\min(0,x),\\max(0,x)],\\because f(x)0,\\therefore \\forall x e 0,f(x)0.f(0)=x→0lim​f(x)=x→0lim​x2f(x)​⋅x→0lim​x2=0,f′(0)=Δx→0lim​Δx−0f(Δx)−f(0)​=x→0lim​xf(x)​=0,f(x)=f(0)+f′(0)+21​f′′(ξ)x2,ξ∈[min(0,x),max(0,x)],∵f′′(x)0,∴∀x=0,f(x)0. 2.4 极值、凸性、渐近线 若 f′(x0)=0f(x_0)=0f′(x0​)=0，则称 x0x_0x0​ 为驻点。 若 x0x_0x0​ 是 f(x)f(x)f(x) 的极值点，那么 f′(x0)=0f(x_0)=0f′(x0​)=0 或不存在。 取极值第一充分条件：设连续函数 f(x)f(x)f(x) 在 U˚(x0,δ)\\mathring U(x_0,\\delta)U˚(x0​,δ) 可导，且 f′(x0)=0f(x_0)=0f′(x0​)=0 或 f′(x0)f(x_0)f′(x0​) 不存在，则根据 xx0xx_0xx0​ 和 xx0xx_0xx0​ 的正负性来判断 x0x_0x0​ 是否为极值点。 取极值第二充分条件：二阶导存在且不为 000，看二阶导正负性。 函数的凸性有两种：下凸和上凸。设 f(x)f(x)f(x) 在 III 上连续，∀x1,x2∈I(x1≠x2),λ∈(0,1)\\forall x_1,x_2\\in I(x_1 e x_2),\\lambda\\in (0,1)∀x1​,x2​∈I(x1​=x2​),λ∈(0,1)，总有 f(λx1+(1−λ)x2)λf(x1)+(1−λ)f(x2)f(\\lambda x_1+(1-\\lambda)x_2)\\lambda f(x_1)+(1-\\lambda)f(x_2)f(λx1​+(1−λ)x2​)λf(x1​)+(1−λ)f(x2​)，那么 f(x)f(x)f(x) 在 III 上下凸，若大于则是上凸。判定的条件分别是二阶导为正和为负。 如果函数下凸那么 f(x+Δx)f(x)+f′(x)Δxf(x+\\Delta x)f(x)+f(x)\\Delta xf(x+Δx)f(x)+f′(x)Δx，上凸同理。 连续函数上凸和下凸区间的分界点称为曲线的拐点，拐点的二阶导为 000 或者不存在。 x,y0x,y0x,y0，证明 xln⁡x+yln⁡y(x+y)ln⁡x+y2x\\ln x+y\\ln y (x+y)\\ln\\frac{x+y}{2}xlnx+ylny(x+y)ln2x+y​。设 f(x)=xln⁡xf(x)=x\\ln xf(x)=xlnx，即证 f(x)+f(y)≥2f(x+y2)f(x)+f(y)\\ge 2f\\left(\\frac{x+y}{2}\\right)f(x)+f(y)≥2f(2x+y​)。由于 f′′(x)0f(x)0f′′(x)0，因此 f(x)f(x)f(x) 在 (0,+∞)(0,+\\infty)(0,+∞) 下凸，取 λ=12\\lambda = \\frac 1 2λ=21​，有 f(x+y2)12f(x)+12f(y)f\\left(\\frac{x+y}{2}\\right)\\frac 1 2 f(x)+\\frac 1 2 f(y)f(2x+y​)21​f(x)+21​f(y)。 若 lim⁡x→+∞f(x)=A\\lim\\limits_{x\\to +\\infty}f(x)=Ax→+∞lim​f(x)=A 或 lim⁡x→−∞f(x)=A\\lim\\limits_{x\\to -\\infty}f(x)=Ax→−∞lim​f(x)=A，则称 y=Ay=Ay=A 为 y=f(x)y=f(x)y=f(x) 的水平渐近线。 若 lim⁡x→x0+f(x)=∞\\lim\\limits_{x\\to x_0^+}f(x)=\\inftyx→x0+​lim​f(x)=∞ 或 lim⁡x→x0−f(x)=∞\\lim\\limits_{x\\to x_0^-}f(x)=\\inftyx→x0−​lim​f(x)=∞，则称 x=x0x=x_0x=x0​ 为 y=f(x)y=f(x)y=f(x) 的竖直渐近线。 由于 d=∣f(x)−kx−b∣1+k2d=\\dfrac{|f(x)-kx-b|}{\\sqrt{1+k^2}}d=1+k2​∣f(x)−kx−b∣​，我们以 x→+∞x\\to +\\inftyx→+∞ 为例，若 lim⁡x→+∞d=0\\lim\\limits_{x\\to +\\infty}d=0x→+∞lim​d=0，那么 lim⁡x→+∞(f(x)−kx−b)=0\\lim\\limits_{x\\to +\\infty} (f(x)-kx-b)=0x→+∞lim​(f(x)−kx−b)=0，于是 k=lim⁡x→+∞f(x)xk=\\lim\\limits_{x\\to+\\infty}\\dfrac{f(x)} xk=x→+∞lim​xf(x)​，此时 b=lim⁡x→+∞(f(x)−kx)b=\\lim\\limits_{x\\to +\\infty}(f(x)-kx)b=x→+∞lim​(f(x)−kx)，此时 y=kx+by=kx+by=kx+b 为斜渐近线。 2.5 弧微分 弧微分 ds=dx2+dy2=1+y′2dx\\d s=\\sqrt{\\d x^2+\\d y^2}=\\sqrt{1+y^2}\\d xds=dx2+dy2​=1+y′2​dx，因此如果用参数方程表示曲线，那么 ds=(x′(t))2+(y′(t))2dt\\d s=\\sqrt{(x(t))^2+(y(t))^2}\\d tds=(x′(t))2+(y′(t))2​dt。 切线的转角代表 Δα\\Delta \\alphaΔα，平均曲率 K‾=∣ΔαΔs∣\\overline K=\\left|\\frac{\\Delta \\alpha}{\\Delta s}\\right|K=​ΔsΔα​​，当 Δs→0\\Delta s\\to 0Δs→0，得到曲率 KKK。 由于 α=arctan⁡y′\\alpha = \\arctan yα=arctany′，因此 dα=darctan⁡y′=darctan⁡u=11+u2du=11+y′2dy′=y′′dx1+y′2\\d \\alpha=\\d \\arctan y=\\d \\arctan u=\\frac{1}{1+u^2}\\d u=\\frac{1}{1+y^2}\\d y=\\frac{y\\d x}{1+y^2}dα=darctany′=darctanu=1+u21​du=1+y′21​dy′=1+y′2y′′dx​，于是 K=∣y′′∣(1+y′2)3/2K=\\dfrac{|y|}{(1+y^2)^{3/2}}K=(1+y′2)3/2∣y′′∣​。用参数方程表示时，K=∣y′′x′−y′x′′∣(x′2+y′2)3/2K=\\dfrac{|yx-yx|}{(x^2+y^2)^{3/2}}K=(x′2+y′2)3/2∣y′′x′−y′x′′∣​。 设曲线 y=f(x)y=f(x)y=f(x) 在 MMM 点处的曲率为 K(K≠0)K(K e 0)K(K=0)，过该点作曲线的法线，圆心为 CCC，且 ∣MC∣=1K|MC|=\\frac 1 K∣MC∣=K1​，得到曲率圆，圆心为曲率中心。 3. 不定积分 f(x)f(x)f(x) 在 III 内的全体原函数称为 f(x)f(x)f(x) 在 III 内的不定积分，记作 ∫f(x)dx\\displaystyle\\int f(x)\\d x∫f(x)dx。也就是说，已知原函数的微分是 f(x)dxf(x)\\d xf(x)dx，求原函数。 连续函数的原函数一定存在，但不一定是初等函数，比如 ∫sin⁡xx\\displaystyle \\int \\frac{\\sin x}{x}∫xsinx​ 就不初等可积。关于是否初等可积的充要条件，非常复杂。对于工科来说，最简单的方式是将积分输到一个求解器里看能否给出答案。 3.1 第一换元法（凑微分法） 如果 ∫g(x)dx\\displaystyle\\int g(x)\\d x∫g(x)dx 是难求的，但是 ∫f(u)du\\displaystyle\\int f(u)\\d u∫f(u)du 是好求的，我们想办法把 dx\\d xdx 改写为 du\\d udu，这里 du=φ′(x)dx\\d u=\\varphi(x)\\d xdu=φ′(x)dx，u=φ(x)u=\\varphi(x)u=φ(x)。相当于复合函数求导的逆运算，目的在于改写 dx\\d xdx，使得微分算子里的东西和外面长得一样来换元。这里要求 φ(x)\\varphi(x)φ(x) 连续可导。 也就是说找到 f(x)f(x)f(x) 中的某一部分乘进 dx\\d xdx 里。 计算 ∫sin⁡3xdx\\displaystyle\\int \\sin^3 x \\d x∫sin3xdx。原式=∫(1−cos⁡2x)sin⁡xdx=∫(1−cos⁡2x)dcos⁡x=∫(1−u2)du=u33−u+C=cos⁡3x3−cos⁡x+C原式=\\displaystyle\\int (1-\\cos^2 x)\\sin x \\d x=\\int (1-\\cos^2 x)\\d \\cos x=\\int (1-u^2)\\d u=\\frac{u^3}{3}-u+C=\\frac{\\cos^3 x}{3}-\\cos x+C原式=∫(1−cos2x)sinxdx=∫(1−cos2x)dcosx=∫(1−u2)du=3u3​−u+C=3cos3x​−cosx+C. 计算 ∫sec⁡xdx\\displaystyle\\int \\sec x \\d x∫secxdx。∫sec⁡xdx=∫cos⁡x1−sin⁡2xdx=∫dsin⁡x1−sin⁡2x,令 u=sin⁡x,=∫du1−u2=12(∫du1+u−∫duu−1)=12(ln⁡∣1+u∣−ln⁡∣u−1∣)+C=12ln⁡∣1+u1−u∣+C=12ln⁡∣1+sin⁡x1−sin⁡x∣+C=12ln⁡∣(1+sin⁡x)2cos⁡2x∣+C=ln⁡∣1+sin⁡xcos⁡x∣+C=ln⁡∣sec⁡x+tan⁡x∣+C.\\displaystyle\\int \\sec x \\d x=\\int \\frac{\\cos x}{1-\\sin^2 x} \\d x=\\int \\frac{\\d \\sin x}{1-\\sin^2 x},\\\\令\\ u=\\sin x,\\\\=\\int \\frac{\\d u}{1-u^2}=\\frac 1 2\\left(\\int \\frac{\\d u}{1+u}-\\int \\frac{\\d u}{u-1}\\right)\\\\=\\frac 1 2\\left(\\ln|1+u|-\\ln|u-1|\\right)+C=\\frac 1 2 \\ln\\left|\\frac{1+u}{1-u}\\right|+C\\\\=\\frac 1 2 \\ln\\left|\\frac{1+\\sin x}{1-\\sin x}\\right|+C\\\\=\\frac 1 2 \\ln\\left|\\frac{(1+\\sin x)^2}{\\cos^2 x}\\right|+C\\\\=\\ln\\left|\\frac{1+\\sin x}{\\cos x}\\right|+C\\\\=\\ln|\\sec x+\\tan x|+C.∫secxdx=∫1−sin2xcosx​dx=∫1−sin2xdsinx​,令 u=sinx,=∫1−u2du​=21​(∫1+udu​−∫u−1du​)=21​(ln∣1+u∣−ln∣u−1∣)+C=21​ln​1−u1+u​​+C=21​ln​1−sinx1+sinx​​+C=21​ln​cos2x(1+sinx)2​​+C=ln​cosx1+sinx​​+C=ln∣secx+tanx∣+C. 3.2 第二换元法（变量代换法） 直接改写 xxx 为 ψ(t)\\psi(t)ψ(t)，也就是将 ∫f(x)dx\\displaystyle\\int f(x)\\d x∫f(x)dx 改写为 ∫f(ψ(t))ψ′(t)dt\\displaystyle\\int f(\\psi(t))\\psi(t)\\d t∫f(ψ(t))ψ′(t)dt。具体来说，当 f(x)f(x)f(x) 在 III 内的原函数存在，x=ψ(t)x=\\psi(t)x=ψ(t) 要取到 III，对应的定义域 ItI_tIt​ 内 ψ(t)\\psi(t)ψ(t) 单调连续可导，那么在解出换元的积分后，直接令 t=ψ−1(x)t=\\psi^{-1}(x)t=ψ−1(x) 即可。 含有 a2−x2,a0\\sqrt{a^2-x^2},a0a2−x2​,a0，考虑 x=asin⁡t,acos⁡tx=a\\sin t,a\\cos tx=asint,acost； 含有 x2+a2,a0\\sqrt{x^2+a^2},a0x2+a2​,a0，考虑 x=atan⁡t,acot⁡tx=a\\tan t,a\\cot tx=atant,acott； 含有 x2−a2,a0\\sqrt{x^2-a^2},a0x2−a2​,a0，考虑 x=asec⁡t,acsc⁡tx=a\\sec t,a\\csc tx=asect,acsct； 根式代换：含有 ax+bn\\sqrt[n]{ax+b}nax+b​，考虑 t=ax+bnt=\\sqrt[n]{ax+b}t=nax+b​； 倒代换：被积函数分母最高次数大于分子最高次数时，可尝试 t=1xt=\\frac 1 xt=x1​； 万能代换：关于 sin⁡x,cos⁡x\\sin x,\\cos xsinx,cosx 的有理式，可以令 t=tan⁡x2t=\\tan \\frac x 2t=tan2x​。 计算 ∫a2−x2dx\\displaystyle \\int \\sqrt{a^2-x^2}\\d x∫a2−x2​dx。令 x=asin⁡tx=a\\sin tx=asint，需单调，取 t∈(−π2,π2)t\\in (-\\frac \\pi 2,\\frac \\pi 2)t∈(−2π​,2π​)，那么原式化为 ∫acos⁡td(asin⁡t)=a2∫cos⁡2tdt\\displaystyle \\int a\\cos t \\d (a\\sin t)=a^2\\int \\cos^2 t\\d t∫acostd(asint)=a2∫cos2tdt。cos⁡2t=cos⁡2t+12\\cos^2 t=\\frac{\\cos 2t+1}{2}cos2t=2cos2t+1​，之后容易通过第一换元法得到 a24sin⁡2t+a2t2+C\\frac {a^2} 4\\sin 2t+\\frac {a^2t} 2 + C4a2​sin2t+2a2t​+C。可求得 xa2−x22+a22arcsin⁡xa+C\\frac{x\\sqrt{a^2-x^2}}{2}+\\frac{a^2}{2}\\arcsin\\frac x a+C2xa2−x2​​+2a2​arcsinax​+C。 计算 ∫1x2x2+1dx\\displaystyle \\int \\frac 1{x^2\\sqrt{x^2+1}}\\d x∫x2x2+1​1​dx。考虑倒代换，得 −∫tt2+1dt-\\displaystyle\\int \\frac{t}{\\sqrt{t^2+1}}\\d t−∫t2+1​t​dt。得到 −t2+1+C=−1+x2x+C-\\sqrt{t^2+1}+C=-\\frac{\\sqrt{1+x^2}}{x}+C−t2+1​+C=−x1+x2​​+C。 3.3 分部积分法 设 u(x),v(x)u(x),v(x)u(x),v(x) 具有连续的导数 u′(x),v′(x)u(x),v(x)u′(x),v′(x)，那么： ∵d(uv)=udv+vdu,∴∫udv=uv−∫vdu,∴∫uv′dx=uv−∫vu′dx. \\because \\d(uv)=u\\d v+v\\d u,\\\\ \\therefore \\displaystyle \\int u\\d v=uv - \\int v\\d u,\\\\ \\therefore \\int uv\\d x=uv-\\int vu\\d x. ∵d(uv)=udv+vdu,∴∫udv=uv−∫vdu,∴∫uv′dx=uv−∫vu′dx. 计算 ∫xcos⁡xdx\\displaystyle\\int x\\cos x\\d x∫xcosxdx。设 u=x,v=sin⁡xu=x,v=\\sin xu=x,v=sinx，则原式化为 xsin⁡x−∫sin⁡xdx=xsin⁡x+cos⁡x+Cx\\sin x-\\displaystyle\\int \\sin x\\d x=x\\sin x+\\cos x+Cxsinx−∫sinxdx=xsinx+cosx+C。 计算 ∫arcsin⁡xdx\\displaystyle \\int \\arcsin x\\d x∫arcsinxdx。令 u=arcsin⁡x,v=xu=\\arcsin x,v=xu=arcsinx,v=x，则等于 xarcsin⁡x−∫x1−x2dx=xarcsin⁡x+1−x2+Cx\\arcsin x-\\displaystyle\\int \\frac{x}{\\sqrt{1-x^2}}\\d x=x\\arcsin x+\\sqrt{1-x^2}+Cxarcsinx−∫1−x2​x​dx=xarcsinx+1−x2​+C。 计算 ∫ln⁡xdx\\displaystyle \\int \\ln x\\d x∫lnxdx。u=ln⁡x,v=xu=\\ln x,v=xu=lnx,v=x，则答案为 xln⁡x−xx\\ln x -xxlnx−x。 计算 ∫sec⁡3dx\\displaystyle\\int \\sec^3 \\d x∫sec3dx。令 u=tan⁡x,v=sec⁡xu=\\tan x,v=\\sec xu=tanx,v=secx，则化为 tan⁡xsec⁡x−∫sec⁡xtan⁡2xdx\\tan x\\sec x-\\displaystyle\\int \\sec x \\tan^2 x \\d xtanxsecx−∫secxtan2xdx，第二坨等于 ∫sec⁡x(sec⁡2x−1)dx\\displaystyle\\int \\sec x(\\sec^2 x-1)\\d x∫secx(sec2x−1)dx，于是有：∫sec⁡3dx=tan⁡xsec⁡x−∫sec⁡3xdx+∫sec⁡xdx∫sec⁡3dx=tan⁡xsec⁡x−∫sec⁡3xdx+ln⁡∣sec⁡x+tan⁡x∣∫sec⁡3dx=12(tan⁡xsec⁡x+ln⁡∣sec⁡x+tan⁡x∣)+C\\int \\sec^3 \\d x=\\tan x\\sec x-\\int\\sec^3 x\\d x+\\int \\sec x\\d x\\\\\\int \\sec^3 \\d x=\\tan x\\sec x-\\int\\sec^3 x\\d x+\\ln|\\sec x+\\tan x|\\\\\\int \\sec^3 \\d x=\\frac 1 2 (\\tan x\\sec x+\\ln|\\sec x+\\tan x|)+C∫sec3dx=tanxsecx−∫sec3xdx+∫secxdx∫sec3dx=tanxsecx−∫sec3xdx+ln∣secx+tanx∣∫sec3dx=21​(tanxsecx+ln∣secx+tanx∣)+C 3.4 积分表 需要背诵的内容： 1.∫tan⁡xdx=−ln⁡∣cos⁡x∣+C2.∫cot⁡xdx=ln⁡∣sin⁡x∣+C3.∫sec⁡xdx=ln⁡∣sec⁡x+tan⁡x∣+C4.∫csc⁡xdx=ln⁡∣csc⁡x−cot⁡x∣+C5.∫1x2+a2dx=1aarctan⁡xa+C6.∫1x2−a2dx=12aln⁡∣x−ax+a∣+C7.∫1a2−x2dx=arcsin⁡xa+C8.∫1x2+a2dx=ln⁡(x+x2+a2)+C9.∫1x2−a2dx=ln⁡∣x+x2−a2∣+C \\displaystyle 1. \\int \\tan x\\d x = -\\ln|\\cos x|+C\\\\ 2. \\int \\cot x\\d x = \\ln|\\sin x|+C\\\\ 3. \\int \\sec x\\d x=\\ln|\\sec x+\\tan x|+C\\\\ 4. \\int \\csc x\\d x=\\ln|\\csc x-\\cot x|+C\\\\ 5. \\int \\frac 1{x^2+a^2}\\d x=\\frac 1 a \\arctan \\frac x a +C\\\\ 6. \\int \\frac 1{x^2-a^2}\\d x=\\frac 1{2a} \\ln\\left|\\frac{x-a}{x+a}\\right| +C\\\\ 7. \\int \\frac 1{\\sqrt{a^2-x^2}}\\d x=\\arcsin \\frac x a +C\\\\ 8. \\int \\frac 1{\\sqrt{x^2+a^2}}\\d x=\\ln\\left(x+\\sqrt{x^2+a^2}\\right) +C\\\\ 9. \\int \\frac 1{\\sqrt{x^2-a^2}}\\d x=\\ln\\left|x+\\sqrt{x^2-a^2}\\right| +C 1.∫tanxdx=−ln∣cosx∣+C2.∫cotxdx=ln∣sinx∣+C3.∫secxdx=ln∣secx+tanx∣+C4.∫cscxdx=ln∣cscx−cotx∣+C5.∫x2+a21​dx=a1​arctanax​+C6.∫x2−a21​dx=2a1​ln​x+ax−a​​+C7.∫a2−x2​1​dx=arcsinax​+C8.∫x2+a2​1​dx=ln(x+x2+a2​)+C9.∫x2−a2​1​dx=ln​x+x2−a2​​+C 3.5 例题选解 已知 f′(ex)=xe−x,f(1)=0f(e^x)=xe^{-x},f(1)=0f′(ex)=xe−x,f(1)=0，求 fff。f′(u)=ln⁡uuf(u)=\\frac{\\ln u}{u}f′(u)=ulnu​，两边求不定积分得到 f(u)=12ln⁡2u+Cf(u)=\\frac 1 2 \\ln^2 u+Cf(u)=21​ln2u+C，因此 f(x)=12ln⁡2xf(x)=\\frac 1 2 \\ln^2 xf(x)=21​ln2x。 计算 ∫xexex−1dx\\displaystyle\\int \\frac{xe^x}{\\sqrt{e^x-1}}\\d x∫ex−1​xex​dx。令 u=x,v=ex−1,v′=ex2ex−1u=x,v=\\sqrt{e^x-1},v=\\frac{e^x}{2\\sqrt{e^x-1}}u=x,v=ex−1​,v′=2ex−1​ex​，那么原式 =∫2uv′dx=2uv−2∫u′vdx=\\displaystyle\\int 2uv\\d x=2uv-2\\int uv\\d x=∫2uv′dx=2uv−2∫u′vdx。其中 ∫u′vdx=∫ex−1dx\\displaystyle\\int uv\\d x=\\int \\sqrt{e^x-1}\\d x∫u′vdx=∫ex−1​dx，考虑根式代换，令 t=ex−1,x=ln⁡(t2+1)t=\\sqrt{e^x-1},x=\\ln(t^2+1)t=ex−1​,x=ln(t2+1)，那么 dx=2tt2+1dt\\d x=\\frac{2t}{t^2+1}\\d tdx=t2+12t​dt。计算课得 2∫t2+1−1t2+1dt=2(t−arctan⁡t)+C2\\displaystyle\\int \\frac{t^2+1-1}{t^2+1}\\d t=2(t-\\arctan t)+C2∫t2+1t2+1−1​dt=2(t−arctant)+C。于是答案为 2xex−1−4ex−1+4arctan⁡ex−1+C2x\\sqrt{e^x-1}-4\\sqrt{e^x-1}+4\\arctan\\sqrt{e^x-1}+C2xex−1​−4ex−1​+4arctanex−1​+C。 计算 ∫x+sin⁡x1+cos⁡xdx\\displaystyle\\int \\frac{x+\\sin x}{1+\\cos x}\\d x∫1+cosxx+sinx​dx。∫x1+cos⁡xdx+∫sin⁡x1+cos⁡xdx=∫x2cos⁡2x2dx−∫d(1+cos⁡x)1+cos⁡x令 u=x,v=tan⁡x2,=uv−∫u′vdx−ln⁡(1+cos⁡x)=xtan⁡x2−2∫tan⁡x2dx2−ln⁡(1+cos⁡x)=xtan⁡x2+2ln⁡∣cos⁡x2∣−ln⁡(1+cos⁡x)+C.\\begin{aligned}\\displaystyle\\int \\frac{x}{1+\\cos x}\\d x+\\int\\frac{\\sin x}{1+\\cos x}\\d x=\\displaystyle\\int \\frac{x}{2\\cos^2 \\frac x 2}\\d x-\\int\\frac{\\d(1+\\cos x)}{1+\\cos x}\\\\ 令\\ u=x,v=\\tan \\frac x 2,\\\\=uv-\\int uv\\d x-\\ln(1+\\cos x)\\\\=x\\tan \\frac x 2-2\\int \\tan \\frac x 2\\d \\frac x 2-\\ln(1+\\cos x)\\\\=x\\tan \\frac x 2+2\\ln\\left|\\cos \\frac x 2\\right|-\\ln(1+\\cos x)+C.\\end{aligned}∫1+cosxx​dx+∫1+cosxsinx​dx​=∫2cos22x​x​dx−∫1+cosxd(1+cosx)​令 u=x,v=tan2x​,=uv−∫u′vdx−ln(1+cosx)=xtan2x​−2∫tan2x​d2x​−ln(1+cosx)=xtan2x​+2ln​cos2x​​−ln(1+cosx)+C.​ 4. 定积分 定积分表示为 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上与 xxx 轴相交范围的面积，记作 ∫abf(x)dx\\displaystyle\\int_{a}^b f(x)\\d x∫ab​f(x)dx。如果 ababab，那么实际上是 swap a,ba,ba,b 之后求定积分再取相反数。 严格意义上来说，就是 lim⁡∣∣Δ∣∣→0f(ξi)Δxi\\lim\\limits_{||\\Delta||\\to 0} f(\\xi_i)\\Delta x_i∣∣Δ∣∣→0lim​f(ξi​)Δxi​ 存在，则称 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上黎曼可积，该极限的值为定积分。注意这里并不要求函数连续。因此，黎曼可积的必要条件是函数有界。 积分中值定理的一种特殊形式：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上连续，∃ξ∈[a,b],i.e.⁡∫abf(x)dx=f(ξ)(b−a)\\exist \\xi\\in [a,b],\\ie \\displaystyle\\int_{a}^b f(x)\\d x=f(\\xi)(b-a)∃ξ∈[a,b],i.e.∫ab​f(x)dx=f(ξ)(b−a)。 4.1 微积分基本定理 积分上限函数 Φ(x)=∫axf(t)dt\\Phi(x)=\\displaystyle\\int_{a}^x f(t)\\d tΦ(x)=∫ax​f(t)dt 是连续的。若 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续，那么 Φ(x)\\Phi(x)Φ(x) 在 [a,b][a,b][a,b] 上可导，且 Φ′(x)=f(x)\\Phi(x)=f(x)Φ′(x)=f(x)。注意在求解积分上限函数时，一定要保证被积函数和上限无关，如果有，一定要转化。 微积分基本定理：若 f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上连续，且 F(x)F(x)F(x) 为原函数，那么 ∫abf(x)dx=F(b)−F(a)=[F(x)]ab=F(x)∣ab\\displaystyle\\int_a^b f(x)\\d x=F(b)-F(a)=[F(x)]_a^b=F(x)|_a^b∫ab​f(x)dx=F(b)−F(a)=[F(x)]ab​=F(x)∣ab​。 值得注意的是，在使用第二换元法计算时，不再要求函数单调，假定将 ∫abf(x)dx\\displaystyle\\int_{a}^b f(x)\\d x∫ab​f(x)dx 换成 ∫αβf(φ(t))φ′(t)dt\\displaystyle\\int_\\alpha^\\beta f(\\varphi(t))\\varphi(t)\\d t∫αβ​f(φ(t))φ′(t)dt 时，只需要满足 a=φ(α),b=φ(β)a=\\varphi(\\alpha),b=\\varphi(\\beta)a=φ(α),b=φ(β)，且在 [α,β][\\alpha,\\beta][α,β] 上 φ(t)\\varphi(t)φ(t) 的值域为 [a,b][a,b][a,b]，且连续可导即可。但实际上很难遇到不单调的情况。 点火公式：In=∫0π/2sin⁡nxdx=∫0π/2cos⁡nxdxI_n=\\displaystyle\\int_{0}^{\\pi/2} \\sin^n x\\d x=\\int_{0}^{\\pi/2} \\cos^n x\\d xIn​=∫0π/2​sinnxdx=∫0π/2​cosnxdx，有 In=n−1nIn−2I_n=\\frac{n-1}{n} I_{n-2}In​=nn−1​In−2​。 求：lim⁡n→+∞∑i=1nnn2+i2\\displaystyle\\lim_{n\\to +\\infty}\\sum_{i=1}^n \\frac{n}{n^2+i^2}n→+∞lim​i=1∑n​n2+i2n​。lim⁡n→+∞∑i=1nnn2+i2=lim⁡n→+∞1n∑i=1n11+(in)2=∫0111+x2dx=arctan⁡x∣01=π4.\\lim_{n\\to +\\infty}\\sum_{i=1}^n \\frac{n}{n^2+i^2} = \\lim_{n\\to +\\infty} \\frac{1}{n} \\sum_{i=1}^n \\frac{1}{1+\\left(\\frac{i}{n}\\right)^2} = \\int_0^1 \\frac{1}{1+x^2} \\d x = \\arctan x \\Big|_0^1 = \\frac{\\pi}{4}.n→+∞lim​i=1∑n​n2+i2n​=n→+∞lim​n1​i=1∑n​1+(ni​)21​=∫01​1+x21​dx=arctanx​01​=4π​.转化为定积分的过程相当于取 xi=inx_i=\\frac i nxi​=ni​。实际上常用的形式是 ∫01f(x)dx=lim⁡n→∞1n∑i=1nf(in)\\displaystyle\\int_0^1 f(x)\\d x=\\lim_{n\\to\\infty}\\frac 1 n\\sum_{i=1}^nf\\left(\\frac i n\\right)∫01​f(x)dx=n→∞lim​n1​i=1∑n​f(ni​)。但是遇到这类问题别想黎曼和想傻了，记得还有夹逼定理这个东西。 4.2 积分中值定理 积分第一中值定理：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上连续，g(x)g(x)g(x) 在 [a,b][a,b][a,b] 上不变号且黎曼可积，则 ∃ξ∈[a,b],i.e.⁡∫abf(x)g(x)dx=f(ξ)∫abg(x)dx\\exist \\xi\\in [a,b],\\ie \\displaystyle\\int_a^b f(x)g(x)\\d x=f(\\xi)\\int_{a}^b g(x)\\d x∃ξ∈[a,b],i.e.∫ab​f(x)g(x)dx=f(ξ)∫ab​g(x)dx。 积分第二中值定理：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 上黎曼可积，g(x)g(x)g(x) 在 [a,b][a,b][a,b] 单调，则存在 ξ∈[a,b],i.e.⁡∫abf(x)g(x)dx=g(a)∫aξf(x)dx+g(b)∫ξbf(x)dx\\xi \\in [a,b],\\ie \\displaystyle\\int_{a}^b f(x)g(x)\\d x=g(a)\\int_{a}^\\xi f(x)\\d x+g(b)\\int_{\\xi}^bf(x)\\d xξ∈[a,b],i.e.∫ab​f(x)g(x)dx=g(a)∫aξ​f(x)dx+g(b)∫ξb​f(x)dx。 证明积分第二中值定理 设 Φ(x)=∫axf(t)dt\\Phi(x)=\\displaystyle\\int_{a}^x f(t)\\d tΦ(x)=∫ax​f(t)dt，则 dΦ(x)=f(x)dx\\d \\Phi(x)=f(x)\\d xdΦ(x)=f(x)dx，于是等式左边化为 ∫abg(x)dΦx=[g(x)Φ(x)]ab−∫abΦ(x)g′(x)dx\\displaystyle\\int_a^b g(x)\\d \\Phi_x=[g(x)\\Phi(x)]_a^b-\\int_a^b \\Phi(x)g(x)\\d x∫ab​g(x)dΦx​=[g(x)Φ(x)]ab​−∫ab​Φ(x)g′(x)dx。其中 [g(x)Φ(x)]ab=g(b)∫abf(x)dx[g(x)\\Phi(x)]_a^b=g(b)\\displaystyle\\int_a^bf(x)\\d x[g(x)Φ(x)]ab​=g(b)∫ab​f(x)dx。 由于 Φ(x)\\Phi(x)Φ(x) 连续，因此 ∫abΦ(x)g′(x)dx=Φ(ξ)∫abg′(x)dx=Φ(ξ)(g(b)−g(a)),ξ∈[a,b]\\displaystyle \\int_a^b \\Phi(x)g(x)\\d x=\\Phi(\\xi)\\int_a^b g(x)\\d x=\\Phi(\\xi)(g(b)-g(a)),\\xi \\in[a,b]∫ab​Φ(x)g′(x)dx=Φ(ξ)∫ab​g′(x)dx=Φ(ξ)(g(b)−g(a)),ξ∈[a,b]。 代回原式即可。 4.3 定积分的应用 4.4 广义积分 瑕积分的定义是 aaa 或 bbb 是瑕点，不满足这一点需要拆开。 广义积分的被积函数取绝对之后，若积分仍然收敛，则称原积分绝对收敛。不绝对收敛但收敛称为条件收敛。 A. 常微分方程与差分方程 本部分是吉林大学微积分教材的最后一章，但是按照合理顺序它确实应该放在这里。 A.1 常微分方程 未知函数是一元函数的微分方程称为常微分方程。 5. 试卷选做 5.1 吉林大学 微积分A1 2022 期末 选择题 B，极限为 000，但是左导数是 −π2-\\frac \\pi 2−2π​，右导数是 π2\\frac \\pi 22π​，因此不可导。D，lim⁡x→01−cos⁡(x2)x3=0\\lim\\limits_{x\\to 0}\\frac{1-\\cos(x^2)}{x^3}=0x→0lim​x31−cos(x2)​=0。C，f(0)=0f(0)=0f(0)=0，lim⁡x→0+f(x)=lim⁡n→+∞1−en1+en=−1\\lim\\limits_{x\\to 0^+}f(x)=\\lim\\limits_{n\\to +\\infty}\\frac{1-e^n}{1+e^n}=-1x→0+lim​f(x)=n→+∞lim​1+en1−en​=−1，左极限同理等于 111，因此 x=0x=0x=0 第一类间断点。B，f′′(x)f(x)f′′(x) 和 ∣x∣|x|∣x∣ 在 x→0x\\to 0x→0 时是等价无穷小，f′′(x)=0f(x)=0f′′(x)=0，而由于极限的保号性因此二阶导为正，一阶导单调递增，故 f(0)f(0)f(0) 极小；A，拆成两个积分上限函数，求导是容易的。D，MMM 是一个奇函数，NNN 拆成两个定积分前者是奇函数后者是正的，PPP 前者是奇函数后者是负的。填空题 000，∣f(x)∣∣x∣≤∣x∣\\frac{|f(x)|}{|x|}\\le |x|∣x∣∣f(x)∣​≤∣x∣，因此 f(x)x=0\\frac{f(x)}{x}=0xf(x)​=0。e2e^2e2，[−1,1][-1,1][−1,1] 是奇函数，[1,2][1,2][1,2] 算不定积分是 (x−1)ex(x-1)e^x(x−1)ex。2xcos⁡x2f(sin⁡x2)2x\\cos x^2f(\\sin x^2)2xcosx2f(sinx2)，先换元 u=sin⁡x2u=\\sin x^2u=sinx2，然后把 uuu 扔到定积分里，令 v=utv=utv=ut，定积分上下限变为 u,0u,0u,0，然后直接积分上限函数求导。−32-\\frac 3 2−23​，看到一大只复合函数别傻眼了，注意把 12\\frac 1 221​ 从指数头上拿出来，然后好求导多了。y=xy=xy=x，但是记得要验证两个方向。x44+x22+C\\frac{x^4}{4}+\\frac{x^2}{2}+C4x4​+2x2​+C，两边求导即可。三 x→0x\\to 0x→0，于是 sin⁡x∼ln⁡(1+x)∼x\\sin x\\sim \\ln(1+x)\\sim xsinx∼ln(1+x)∼x，然后洛必达两次得到 222。四 根式里配方成 1−(x−1)21-(x-1)^21−(x−1)2，于是 x−1=sin⁡tx-1=\\sin tx−1=sint，然后拆成三个定积分去算。记得高次三角函数要降次，将 sin⁡2t\\sin^2 tsin2t 用 cos⁡2t\\cos 2tcos2t 写出来，最终答案是 3π4−2\\frac {3\\pi}{4}-243π​−2。五 默写求导过程，三问分别是 tan⁡t,sin⁡t2cos⁡4t,12\\tan t,\\frac{\\sin t}{2\\cos^4 t},\\frac 1 2tant,2cos4tsint​,21​。六 直接把面积写出来，积分上限函数求导得到 2η(2η−1)2\\eta(2\\eta - 1)2η(2η−1)，然后 η=12\\eta = \\frac 1 2η=21​，面积是 14\\frac 1 441​。七 有点简单，t=ext=e^xt=ex，然后得到 ∫arctan⁡tt2dt\\displaystyle\\int \\frac{\\arctan t}{t^2}\\d t∫t2arctant​dt，令 u=arctan⁡t,v=−12t−2u=\\arctan t,v=-\\frac 1 2 t^{-2}u=arctant,v=−21​t−2，然后最终答案就是 −12(arctan⁡exe2x+1ex+arctan⁡ex)+C-\\frac 1 2(\\frac{\\arctan e^x}{e^{2x}}+\\frac 1 {e^x} +\\arctan e^x) +C−21​(e2xarctanex​+ex1​+arctanex)+C。八 第一次做不太会。应该构造 F(x)=f(x)−xF(x)=f(x)-xF(x)=f(x)−x，因为要证明等于 111。九 这不比前面简单多了。额有界还收敛就证单调性，很好证，求极限就直接 xn+1=xnx_{n+1}=x_nxn+1​=xn​，然后就 12\\frac 1 221​。 5.2 吉林大学 微积分A1 2024 期末 选择题 A，定义。A，右极限是 111，左极限是 000。B，洛必达法则。注意 A、C 不对的原因是甚至不知道 000 处是否可导，D 也不知道导函数是否连续。B，做过。C，略。D，45 直接让数列正负交替填空题 666，套路地将改写为 eln⁡(1+ax2)sin⁡x−1x3\\frac{e^{\\ln(1+ax^2)\\sin x}-1}{x^3}x3eln(1+ax2)sinx−1​，分子的指数是 000，等价无穷小成 ln⁡(1+ax2)sin⁡x\\ln(1+ax^2)\\sin xln(1+ax2)sinx，然后怎么搞都行。(x−12)2+y2=14\\left(x-\\frac 1 2\\right)^2 +y^2=\\frac 1 4(x−21​)2+y2=41​，由于算出来个除以 000，因此把 x,yx,yx,y 坐标互换再算。y=x−1y=x-1y=x−1，略。31e31e31e，莱布尼茨公式展开。arctan⁡ex+C\\arctan e^x + Carctanex+C，略。sin⁡x2\\sin x^2sinx2，令 u=t−xu=t-xu=t−x 即可。三 洛三次得到 −2-2−2。四 2e22e^22e2，直接隐函数求导两次，没了。五 123,(−1,0)\\frac{1}{\\sqrt[3]{2}},(-1,0)32​1​,(−1,0)，注意驻点、零点、极值是横坐标，拐点是点。六 显然偶函数，之后平凡，2(2−1)2(\\sqrt{2} - 1)2(2​−1)。七 坏了好像有点难。首先被积函数求导更好积分，于是 u=x,v=ln⁡(1+1+xx)u=x,v=\\ln\\left(1+\\sqrt{\\frac{1+x}{x}}\\right)u=x,v=ln(1+x1+x​​)，化为 xln⁡(1+1+xx)+∫dx2(x+1+x)1+x\\displaystyle x\\ln \\left(1+\\sqrt{\\frac{1+x}{x}}\\right)+\\int \\frac{\\d x}{2\\left(\\sqrt x+\\sqrt{1+x}\\right)\\sqrt{1+x}}xln(1+x1+x​​)+∫2(x​+1+x​)1+x​dx​。后面这坨根式代换，令 t=1+x,x=t2−1t=\\sqrt{1+x},x=t^2-1t=1+x​,x=t2−1，则积分里变成 dtt2−1+t=(t−t2−1)dt\\dfrac{\\d t}{\\sqrt{t^2-1}+t}=(t-\\sqrt{t^2-1})\\d tt2−1​+tdt​=(t−t2−1​)dt，后面是经典三角代换。最终得到：xln⁡(1+1+xx)+12(x−x(1+x)+ln⁡(x+1+x))+Cx \\ln \\left( 1 + \\sqrt{\\frac{1+x}{x}} \\right) + \\frac{1}{2} \\left( x - \\sqrt{x(1+x)} + \\ln\\left( \\sqrt{x} + \\sqrt{1+x} \\right) \\right) + Cxln(1+x1+x​​)+21​(x−x(1+x)​+ln(x​+1+x​))+C八 令 t=π−xt=\\pi - xt=π−x，然后易证。f(cos⁡x)=(1−cos⁡2x)3/21+cos⁡2xf(\\cos x)=\\frac{(1-\\cos^2 x)^{3/2}}{1+\\cos^2 x}f(cosx)=1+cos2x(1−cos2x)3/2​。然后后面是平凡的，得到 π(π−2)2\\frac{\\pi(\\pi - 2)}{2}2π(π−2)​。九 我能在中值定理证明的拦截下通过微积分 A1 吗 5.3 吉林大学 微积分A1 2023 期末 小题最难的一集。 选择题 D，略。C，两条斜和一条 x=0x=0x=0。A，洛完之后震荡。D，略。A，注意内层函数不能取到常数 u0u_0u0​，所以 BD 不一定对。C，第二个极限可以未定义，第三个可以有跳跃间断点，第四个让其震荡到无穷即可，第五个随便搞一个跳跃的函数就炸了。官方答案认为第一个也是错的，我觉得这里不能是 x=y2x=y^2x=y2 这种。填空题 2ln⁡2−12\\ln 2-12ln2−1，略。2f′(x0)2f(x_0)2f′(x0​)，略。1+x2dx\\sqrt{1+x^2}\\d x1+x2​dx，略。aaa，略。111，略。5π16\\frac{5\\pi}{16}165π​，这里比较好用的思路是暴力降次，然后利用对称性能消掉大部分的项。三 333，略。四 sin⁡t1−cos⁡t,−1a(1−cos⁡t)2\\displaystyle\\frac{\\sin t}{1-\\cos t},-\\frac{1}{a(1-\\cos t)^2}1−costsint​,−a(1−cost)21​。五 x2arctan⁡x−x+arctan⁡x+Cx^2\\arctan x-x+\\arctan x+Cx2arctanx−x+arctanx+C，略。六 π2\\frac \\pi 22π​，略。七 取对数，求导之后就是下凸函数的性质。八 取对数后直接泰勒展开，e1/2e^{1/2}e1/2。九 我怎么这么菜。 可以参考 https://zhuanlan.zhihu.com/p/651443880。 ↩︎"},{"title":"线性代数","path":"/wiki/maths/1-1.html","content":"1. 前置知识 1.1 集合 集合的笛卡尔积对交并运算具有分配律。 1.2 代数结构 GGG 是非空集合，其上有二元运算 ⋅\\cdot⋅：G×G→GG\\times G\\rightarrow GG×G→G，满足如下性质： 结合律 存在幺元 ϵ\\epsilonϵ（注意幺元左乘右乘都要满足，因此可定义出左幺元和右幺元） 每个元素都存在逆元（也可以定义出左右逆元） 则 (G,⋅)(G,\\cdot)(G,⋅) 是群。如果满足上述条件，那么可以证明，幺元是唯一的，对于任何元素其逆元都是唯一的。但实际上 2、3 条只需要单边定义即可。 (G,⋅)(G,\\cdot)(G,⋅) 只要封闭就是一个原群，若满足结合律则是半群，存在幺元的半群是幺半群，满足交换律的群是阿贝尔群。 群满足消去律，即 a⋅c=b⋅ca\\cdot c=b\\cdot ca⋅c=b⋅c 或者 c⋅a=c⋅bc\\cdot a=c\\cdot bc⋅a=c⋅b 可以得到 a=ba=ba=b。 若 (R,+)(R,+)(R,+) 是阿贝尔群，(R,⋅)(R,\\cdot)(R,⋅) 是半群，且满足分配律 a⋅(b+c)=a⋅b+a⋅ca\\cdot(b+c)=a\\cdot b + a\\cdot ca⋅(b+c)=a⋅b+a⋅c 和 (a+b)⋅c=a⋅c+b⋅c(a+b)\\cdot c=a\\cdot c+b\\cdot c(a+b)⋅c=a⋅c+b⋅c。则 (R,+,⋅)(R,+,\\cdot)(R,+,⋅) 是一个环，+++ 的幺元记作 000，逆元记作 −a-a−a。 如果 (R,⋅)(R,\\cdot)(R,⋅) 是幺半群则得到幺环，乘法对于非零元素都有逆元则是除环，而满足交换律则是交换环。 若 (F,+),(F\\{0},\\cdot) 都是阿贝尔群，那么 (F,+,⋅)(F,+,\\cdot)(F,+,⋅) 是一个域。 2. 一元多项式理论 3. 线性空间 1. 矩阵与向量 若 A,B\\bm{A},\\bm{B}A,B 都为 nnn 行 mmm 列的矩阵，则 A,B\\bm{A},\\bm{B}A,B 称为同型矩阵； 用 eie_iei​ 表示基本列向量，fif_ifi​ 表示基本行向量； 矩阵的行和列互换，称为转置矩阵，记作 A⊤\\bm{A}^\\topA⊤，当 A=A⊤\\bm{A}=\\bm{A}^\\topA=A⊤ 时，A\\bm{A}A 是对称矩阵，若 A⊤=−A\\bm{A}^\\top=-\\bm{A}A⊤=−A，则 A\\bm{A}A 是反称矩阵； 矩阵的分块，我对它的理解是：矩阵的元素是矩阵；如果分块后其主对角线上的矩阵是方阵（阶数可以不同），其余子块均为零矩阵，那么它是分块对角矩阵； 对角矩阵：只有主对角线有值的方阵，记为 A=diag⁡{a11,a22,⋯ ,ann}\\bm{A}=\\operatorname{diag}\\{a_{11},a_{22},\\cdots,a_{nn}\\}A=diag{a11​,a22​,⋯,ann​}，全相等时称为标量矩阵； 1.1 矩阵的初等变换 三种初等变换 倍法变换：给某一行或列（接下来只写行）乘上一个非零数，A→ri×kB\\bm{A}\\xrightarrow{r_i\\times k}\\bm{B}Ari​×k​B； 消法变换：用一个数乘上某一行后再加到另一行上，A→ri×k+rjB\\bm{A}\\xrightarrow{r_i\\times k+r_j}\\bm{B}Ari​×k+rj​​B； 换法变换：交换两行，A→ri↔rjB\\bm{A}\\xrightarrow{r_i\\leftrightarrow r_j}\\bm{B}Ari​↔rj​​B； 对单位矩阵实施一次初等变换得到初等矩阵。 等价关系： 经过有限次初等变换后相等，A≅B\\bm{A}\\cong \\bm{B}A≅B。 任意一个矩阵都可以经过若干次初等变换变为标准形矩阵，是一个 2×22\\times 22×2 的分块矩阵，左上角为单位矩阵，其余三个子块为零矩阵。单位矩阵的阶就是原矩阵的秩。 R(A+B)≤R(A)+R(B)R(\\bm A + \\bm B)\\le R(\\bm A)+R(\\bm B)R(A+B)≤R(A)+R(B)， R(A)+R(B)−n≤R(AB)≤min⁡{R(A),R(B)}R(\\bm A)+R(\\bm B)-n\\le R(\\bm A\\bm B)\\le \\min\\{R(\\bm A),R(\\bm B)\\}R(A)+R(B)−n≤R(AB)≤min{R(A),R(B)}。 若只允许使用行初等变换，那么可以变成一个行阶梯形矩阵，即左下角有一个全 000 阶梯（而且每个台阶高为 111）。如果行首非零元素为 111，且这个 111 所在的列的其余元素为 000，那么它是行最简形矩阵。显然，行阶梯型矩阵的秩等于其行数。 使用初等矩阵左乘矩阵相当于行变换，右乘相当于列变换。 2. 行列式 ∣A∣=a11a22−a12a21|\\bm A| =a_{11}a_{22}-a_{12}a_{21}∣A∣=a11​a22​−a12​a21​。 ∣A∣=a11a22a33+a12a23a31+a13a21a32−a13a22a31−a12a21a33−a11a23a32|\\bm A| =a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}∣A∣=a11​a22​a33​+a12​a23​a31​+a13​a21​a32​−a13​a22​a31​−a12​a21​a33​−a11​a23​a32​。 ∣A∣=∑j为1∼n的排列(−1)τ(j1,j2,⋯ ,jn)∏i=1naiji|\\bm A|=\\sum_{j为 1\\sim n 的排列}(-1)^{\\tau(j_1,j_2,\\cdots,j_n)} \\prod_{i=1}^n a_{ij_i} ∣A∣=j为1∼n的排列∑​(−1)τ(j1​,j2​,⋯,jn​)i=1∏n​aiji​​ 每一个乘积都是一个均布项。 ∣A∣=∣A⊤∣|\\bm A|=|\\bm A^\\top|∣A∣=∣A⊤∣。三角矩阵的行列式等于主对角线的乘积。 行列式某一行的公因子可以提到行列式外面去，消法变换不会改变行列式的值，一次换法变换使得行列式的值变为相反数。这句话可以推出，如果行列式有两行（列）成比例，那么行列式的值是 000。 det⁡A≠0\\det \\bm A e 0detA=0 的充要条件是 A\\bm AA 满秩。 ∣A∣=∣B∣∣C∣|\\bm A|=|\\bm B||\\bm C|∣A∣=∣B∣∣C∣，其中 A=[B OD C]\\bm A= \\begin{bmatrix}\\bm B\\ \\bm O\\\\ \\bm D\\ \\bm C\\end{bmatrix}A=[B OD C​]，∣AB∣=∣A∣∣B∣|\\bm A\\bm B|=|\\bm A||\\bm B|∣AB∣=∣A∣∣B∣。 在矩阵中选取 kkk 行 kkk 列得到一个方阵，其行列式是一个 kkk 阶子式，记作 DkD_kDk​。如果 ∃Dr≠0\\exist D_r e 0∃Dr​=0，且 ∀Dr+1=0\\forall D_{r+1}=0∀Dr+1​=0，则 R(A)=rR(\\bm A)=rR(A)=r。 也正因如此，如果 R(A)≤n−2R(\\bm A)\\le n-2R(A)≤n−2，证明任意一个 n−1n-1n−1 阶子式都为 000，也就是所有代数余子式都为 000，因此 R(A∗)=0R(\\bm A^*)=0R(A∗)=0。也有 R(A)=n⇒R(A∗)=n,R(A)=n−1⇒R(A∗)=1R(\\bm A)=n\\Rightarrow R(\\bm A^*)=n,R(\\bm A)=n-1\\Rightarrow R(\\bm A^*)=1R(A)=n⇒R(A∗)=n,R(A)=n−1⇒R(A∗)=1。 证明第三条性质 因为 R(A)=n−1R(\\bm A)=n-1R(A)=n−1，证明至少有一个 n−1n-1n−1 阶子式不为 000，也就是至少一个代数余子式不为 000，因此 R(A∗)≥1R(\\bm A^*)\\ge 1R(A∗)≥1。 由于 AA∗=O\\bm A\\bm A^*=\\bm OAA∗=O，因此 A∗\\bm A^*A∗ 的每一列都是 Ax=0\\bm A\\bm x=\\bm 0Ax=0 的一个解，也就是说齐次线性方程组有非零解，Ax=0\\bm A\\bm x=\\bm 0Ax=0 的基础解系大小为 n−R(A)=1n-R(\\bm A)=1n−R(A)=1，因此 A∗\\bm A^*A∗ 的列秩最多为 111，否则线性无关的解的个数就超过了。 因此结论得证。 2.1 行列式展开定理 将第 iii 行第 jjj 列划掉之后得到 aija_{ij}aij​ 的余子式，记作 MijM_{ij}Mij​。aija_{ij}aij​ 的代数余子式 Aij=(−1)i+jMijA_{ij}=(-1)^{i+j} M_{ij}Aij​=(−1)i+jMij​，代数余子式方阵转置后得到伴随矩阵，记作 A∗\\bm A^*A∗。 展开定理： ∑k=1naikAik=∑k=1nakiAki=∣A∣\\displaystyle\\sum_{k=1}^n a_{ik}A_{ik}=\\sum_{k=1}^n a_{ki}A_{ki}=|\\bm A|k=1∑n​aik​Aik​=k=1∑n​aki​Aki​=∣A∣； 当 i≠ji e ji=j 时，∑k=1naikAjk=∑k=1nakiAkj=0\\displaystyle\\sum_{k=1}^n a_{ik}A_{jk}=\\sum_{k=1}^n a_{ki}A_{kj}=0k=1∑n​aik​Ajk​=k=1∑n​aki​Akj​=0。 任意选定 kkk 行 kkk 列得到的行列式称为 kkk 阶子式 MMM，剩余部分的行列式称为 MMM 的余子式。假设选择的行、列编号分别为 i1,⋯ ,k,j1,⋯ ,ki_{1,\\cdots,k},j_{1,\\cdots,k}i1,⋯,k​,j1,⋯,k​，则 MMM 的代数余子式是余子式乘上 (−1)∑i+∑j(-1)^{\\sum i+\\sum j}(−1)∑i+∑j。 Laplace 定理：任意选择 kkk 行后，共 (nk)\\binom n k(kn​) 个 kkk 阶子式，每个子式都乘上其代数余子式，求和后得到原行列式。 证明：(det⁡A)−1=det⁡A−1(\\det\\bm A)^{-1}=\\det \\bm A^{-1}(detA)−1=detA−1。∵AA−1=E,∴det⁡(AA−1)=1,∴(det⁡A)−1=det⁡A−1.\\because \\bm A \\bm A^{-1}=\\bm E,\\\\\\therefore \\det(\\bm A \\bm A^{-1})=1,\\\\\\therefore (\\det\\bm A)^{-1}=\\det \\bm A^{-1}.∵AA−1=E,∴det(AA−1)=1,∴(detA)−1=detA−1. 范德蒙德行列式： ∣111...1a1a2a3...an⋮⋮⋮⋱⋮a1n−2a2n−2a3n−2...ann−2a1n−1a2n−1a3n−1...ann−1∣=∏1≤ij≤n(aj−ai)\\begin{vmatrix} 1 1 1 ... 1\\\\ a_1 a_2 a_3 ... a_n\\\\ \\vdots \\vdots \\vdots \\ddots \\vdots \\\\ a_1^{n-2} a_2^{n-2} a_3^{n-2} ... a_n^{n-2}\\\\ a_1^{n-1} a_2^{n-1} a_3^{n-1} ... a_n^{n-1} \\end{vmatrix} =\\prod_{1\\le ij\\le n}(a_j-a_i) ​1a1​⋮a1n−2​a1n−1​​1a2​⋮a2n−2​a2n−1​​1a3​⋮a3n−2​a3n−1​​......⋱......​1an​⋮ann−2​ann−1​​​=1≤ij≤n∏​(aj​−ai​) 3. 逆矩阵 (AB)−1=B−1A−1(\\bm A \\bm B)^{-1}=\\bm B^{-1}\\bm A^{-1}(AB)−1=B−1A−1。 AA∗=A∗A=∣A∣E\\bm A\\bm A^{*}=\\bm A^{*}\\bm A=|\\bm A|\\bm EAA∗=A∗A=∣A∣E，因此 ∣A∗∣=∣A∣n−1|\\bm A^*|=|\\bm A|^{n-1}∣A∗∣=∣A∣n−1。 方阵可逆的充要条件是 ∣A∣≠0|\\bm A| e 0∣A∣=0（即方阵满秩），且 A−1=A∗∣A∣\\bm A^{-1} = \\dfrac{\\bm A^*}{|\\bm A|}A−1=∣A∣A∗​。 在求解满秩矩阵的逆矩阵时，采用初等行变换将 A\\bm AA 化为单位矩阵，构造 [AE]\\begin{bmatrix}\\bm A \\bm E\\end{bmatrix}[A​E​]，最终单位矩阵就会变成逆矩阵。当然也可以上下拼接并采用初等列变换。 4. 线性方程组 考虑如下线性方程组： {a11x1+a12x2+⋯+a1nxn=b1a21x1+a22x2+⋯+a2nxn=b2…am1x1+am2x2+⋯+amnxn=bm\\begin{cases} a_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n = b_1 \\\\ a_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n = b_2 \\\\ \\dots\\\\ a_{m1}x_1 + a_{m2}x_2 + \\cdots + a_{mn}x_n = b_m \\end{cases} ⎩⎨⎧​a11​x1​+a12​x2​+⋯+a1n​xn​=b1​a21​x1​+a22​x2​+⋯+a2n​xn​=b2​…am1​x1​+am2​x2​+⋯+amn​xn​=bm​​ 可以写成矩阵形式： [a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮am1am2⋯amn][x1x2⋮xn]=[b1b2⋮bm]\\begin{bmatrix} a_{11} a_{12} \\cdots a_{1n} \\\\ a_{21} a_{22} \\cdots a_{2n} \\\\ \\vdots \\vdots \\ddots \\vdots \\\\ a_{m1} a_{m2} \\cdots a_{mn} \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_m \\end{bmatrix} ​a11​a21​⋮am1​​a12​a22​⋮am2​​⋯⋯⋱⋯​a1n​a2n​⋮amn​​​​x1​x2​⋮xn​​​=​b1​b2​⋮bm​​​ 称 mmm 行 n+1n+1n+1 列的矩阵 B=(A,b)\\bm B=(\\bm A,\\bm b)B=(A,b) 为增广矩阵。 当 b≠0\\bm b e 0b=0 时，为非齐次线性方程组，否则是齐次线性方程组。 线性方程组有解时说它是相容的。 Cramer 法则：对于有 nnn 个未知量 nnn 个方程的线性方程组，记 DjD_jDj​ 代表用 b\\bm bb 代替 A\\bm AA 中第 jjj 列所得到的行列式，若 ∣A∣≠0|\\bm A| e 0∣A∣=0，则 xj=Djdet⁡Ax_j=\\dfrac {D_j}{\\det \\bm A}xj​=detADj​​。 注意到对增广矩阵进行初等行变换对方程组没有改变。有关于解的个数的定理： 非齐次线性方程组有解当且仅当 R(A)=R(A,b)R(\\bm A)=R(\\bm A,\\bm b)R(A)=R(A,b)，齐次线性方程组一定有解； nnn 元线性方程组有无穷多解的充要条件是 R(A)=R(A,b)nR(\\bm A)=R(\\bm A,\\bm b)nR(A)=R(A,b)n，有唯一解的充要条件是 R(A)=R(A,b)=nR(\\bm A)=R(\\bm A,\\bm b)=nR(A)=R(A,b)=n。 因此，向量组线性无关的充要条件是 R(α1,α2,⋯ ,αs)=sR(\\bm\\alpha_1,\\bm\\alpha_2,\\cdots,\\bm\\alpha_s)=sR(α1​,α2​,⋯,αs​)=s。 对于齐次线性方程组，基础解系包含 n−R(A)n-R(\\bm A)n−R(A) 个解向量； 设 η0\\eta_0η0​ 是 Ax=b\\bm A \\bm x =\\bm bAx=b 的一个解，ξ1,⋯ ,ξn−r\\xi_1,\\cdots,\\xi_{n-r}ξ1​,⋯,ξn−r​ 是 Ax=0\\bm A\\bm x =\\bm 0Ax=0 的一个基础解系，那么方程的通解为 x=η0+∑kiξi\\bm x = \\eta_0+\\sum k_i\\xi_{i}x=η0​+∑ki​ξi​。 求解齐次线性方程组的基础解系时，将增广矩阵化为行最简形，那么如果一列不是 (0,⋯ ,0,1,0,⋯ ,0)⊤(0,\\cdots,0,1,0,\\cdots,0)^\\top(0,⋯,0,1,0,⋯,0)⊤ 列，那么该列表示的变量是自由的，此时用这些自由的变量表示非自由的变量，假设 xix_ixi​ 是自由的，那么基础解系中的一个解向量就是表达 x1∼xnx_1\\sim x_nx1​∼xn​ 中 xix_ixi​ 的系数。 证明：对于实矩阵 A\\bm AA，有 R(A⊤A)=R(A)R(\\bm A^\\top \\bm A)=R(\\bm A)R(A⊤A)=R(A)。假定 A\\bm AA 是 mmm 行 nnn 列的，那么构造 nnn 维列向量 x\\bm xx 使得 Ax=0\\bm A\\bm x=\\bm 0Ax=0，则 A⊤Ax=0\\bm A^\\top \\bm A\\bm x=\\bm 0A⊤Ax=0。若 A⊤Ax=0\\bm A^\\top \\bm A\\bm x=\\bm 0A⊤Ax=0，则 x⊤A⊤Ax=0\\bm x^\\top \\bm A^\\top \\bm A\\bm x=\\bm 0x⊤A⊤Ax=0，即 (Ax)⊤Ax=0(\\bm A\\bm x)^\\top \\bm A\\bm x=\\bm 0(Ax)⊤Ax=0，因此 Ax=0\\bm A\\bm x=\\bm 0Ax=0。因此两齐次线性方程组同解，那么 R(A⊤A)=R(A)R(\\bm A^\\top \\bm A)=R(\\bm A)R(A⊤A)=R(A)。 5. 方阵的特征值、特征向量与相似化简 方阵的迹（trace）：tr⁡A=∑i=1naii\\operatorname{tr} \\bm A=\\sum_{i=1}^n a_{ii}trA=∑i=1n​aii​。 5.1 方阵的特征值和特征向量 设 A\\bm AA 是 nnn 阶矩阵，若存在数 λ\\lambdaλ 和 nnn 维非零列向量 α\\bm\\alphaα，使得 Aα=λα\\bm A\\bm\\alpha=\\lambda\\bm\\alphaAα=λα，那么 λ\\lambdaλ 是特征值（特征根），α\\bm\\alphaα 为对应于 λ\\lambdaλ 的特征向量，λE−A\\lambda\\bm E-\\bm AλE−A 是特征矩阵，φ(λ)=det⁡(λE−A)\\varphi(\\lambda)=\\det(\\lambda\\bm E-\\bm A)φ(λ)=det(λE−A) 为特征多项式，φ(λ)=0\\varphi(\\lambda)=0φ(λ)=0 为特征方程。在复数域上，A\\bm AA 恰有 nnn 个特征值（可能有重根）。 已知特征根求特征向量时，只需要求解齐次线性方程组 (λE−A)α=0(\\lambda E-\\bm A)\\bm\\alpha=\\bm 0(λE−A)α=0。 不难得知，上（下）三角矩阵的特征根就是主对角线上的元素。也不难得知，φ(λ)\\varphi(\\lambda)φ(λ) 是一个 nnn 次多项式，其系数 cn=1,cn−1=−tr⁡A,c0=φ(0)=det⁡(−A)c_n=1,c_{n-1}=-\\operatorname{tr} \\bm A,c_0=\\varphi(0)=\\det(-\\bm A)cn​=1,cn−1​=−trA,c0​=φ(0)=det(−A)。 有 tr⁡A=∑i=1nλi,det⁡A=∏i=1nλi\\operatorname{tr} \\bm A=\\sum_{i=1}^n \\lambda_i,\\det \\bm A=\\prod_{i=1}^n \\lambda_itrA=∑i=1n​λi​,detA=∏i=1n​λi​。 设 λi\\lambda_iλi​ 是 nin_ini​ 重特征值，那么其对应的特征向量中线性无关组的大小最多为 nnn。不同特征根对应的特征向量一定线性无关。 证明幂等矩阵（即 A2=A\\bm A^2=\\bm AA2=A）的特征值只能是 000 或 111。∵Aα=λα,∴Aα=A2α=A(λα)=λ2α,∴λ2α=λα,∴λ=0,λ=1.\\because \\bm A\\bm\\alpha =\\lambda\\bm\\alpha, \\\\\\therefore \\bm A\\bm\\alpha =\\bm A^2\\bm\\alpha=\\bm A(\\lambda\\bm\\alpha)=\\lambda^2 \\bm\\alpha,\\\\\\therefore \\lambda^2\\bm\\alpha = \\lambda \\bm\\alpha,\\\\\\therefore \\lambda = 0,\\lambda=1.∵Aα=λα,∴Aα=A2α=A(λα)=λ2α,∴λ2α=λα,∴λ=0,λ=1. 5.2 方阵的相似 若存在 P\\bm PP 使得 P−1AP=B\\bm P^{-1}\\bm A\\bm P=\\bm BP−1AP=B，则 A∼B\\bm A\\sim \\bm BA∼B，这一操作称为相似变换，P\\bm PP 是相似因子（相似变换矩阵）。 若 A∼B\\bm A\\sim \\bm BA∼B，则可推出 R(A)=R(B),∣A∣=∣B∣,A⊤∼B⊤,A−1∼B−1,f(A)∼f(B)R(\\bm A)=R(\\bm B),|\\bm A|=|\\bm B|,\\bm A^\\top \\sim \\bm B^\\top,\\bm A^{-1}\\sim \\bm B^{-1},f(\\bm A)\\sim f(\\bm B)R(A)=R(B),∣A∣=∣B∣,A⊤∼B⊤,A−1∼B−1,f(A)∼f(B)，A\\bm AA 和 B\\bm BB 具有相同的特征多项式和特征根。 nnn 阶方阵 A\\bm AA 能和对角矩阵相似的充要条件是 A\\bm AA 存在 nnn 个线性无关的特征向量，而该对角矩阵主对角线的元素正是 A\\bm AA 的特征根，相似因子 P\\bm PP 的每一列都是一个特征向量，且与那些特征根所在的列一一对应。 求 [2213]100\\begin{bmatrix}2 2\\\\1 3\\end{bmatrix}^{100}[21​23​]100。φ(λ)=λ2−5λ+4,∴λ1=1,λ2=4,\\varphi(\\lambda)=\\lambda^2 -5\\lambda +4,\\\\\\therefore \\lambda_1=1,\\lambda_2=4,φ(λ)=λ2−5λ+4,∴λ1​=1,λ2​=4,对应的特征向量为：α1=[2−1],α2=[11],\\bm\\alpha_1=\\begin{bmatrix}2\\\\-1 \\end{bmatrix},\\\\\\bm\\alpha_2=\\begin{bmatrix}1\\\\1 \\end{bmatrix},α1​=[2−1​],α2​=[11​],因此 P=[21−11],B=[1004]\\bm P=\\begin{bmatrix}2 1 \\\\ -1 1\\end{bmatrix},\\bm B=\\begin{bmatrix}1 0 \\\\ 0 4\\end{bmatrix}P=[2−1​11​],B=[10​04​]，且 det⁡P=3,P∗=[1−112]\\det \\bm P=3,\\bm P^{*}=\\begin{bmatrix}1 -1 \\\\ 1 2\\end{bmatrix}detP=3,P∗=[11​−12​]，因此 P−1=13P∗\\bm P^{-1}=\\dfrac 1 3 \\bm P^{*}P−1=31​P∗。A100=(PBP−1)100=PB100P−1=13[4100+22×4100−24100−12×4100+1]\\begin{aligned}\\bm A^{100}=(\\bm P\\bm B\\bm P^{-1})^{100}\\\\=\\bm P\\bm B^{100}\\bm P^{-1}\\\\=\\frac 1 3 \\begin{bmatrix}4^{100}+2 2\\times 4^{100}-2 \\\\ 4^{100}-1 2\\times 4^{100}+1\\end{bmatrix}\\end{aligned}A100​=(PBP−1)100=PB100P−1=31​[4100+24100−1​2×4100−22×4100+1​]​ 证明非零矩阵的幂零矩阵（∃k,Ak=0\\exist k,\\bm A^k =\\bm 0∃k,Ak=0）不能相似对角化。假定 Aα=λα\\bm A\\bm\\alpha =\\lambda\\bm\\alphaAα=λα，那么 Akα=Ak−1λα=λAk−1α=λkα=0\\bm A^k\\bm\\alpha=\\bm A^{k-1}\\lambda\\bm\\alpha=\\lambda \\bm A^{k-1}\\bm\\alpha=\\lambda^k \\bm\\alpha=\\bm 0Akα=Ak−1λα=λAk−1α=λkα=0，因此 λ=0\\lambda=0λ=0。由于 R(A)0R(\\bm A)0R(A)0，因此齐次线性方程组 Aα=0\\bm A\\bm\\alpha=0Aα=0 的基础解系至多包含 n−R(A)nn-R(\\bm A)nn−R(A)n 个解向量，因此不存在 nnn 个线性无关的特征向量，于是不能相似对角化。 A=[12−3−14−31a5]\\bm A = \\begin{bmatrix}1 2 -3\\\\ -1 4 -3\\\\ 1 a 5\\end{bmatrix}A=​1−11​24a​−3−35​​ 有一个二重特征根，求 aaa，并讨论 A\\bm AA 是否可相似对角化。det⁡(λE−A)=[λ−1−231λ−43−1−aλ−5]\\det(\\lambda\\bm E-\\bm A)=\\begin{bmatrix}\\lambda-1 -2 3\\\\1 \\lambda-4 3\\\\-1 -a \\lambda-5\\end{bmatrix}det(λE−A)=​λ−11−1​−2λ−4−a​33λ−5​​对角线法则，(λ−1)(λ−4)(λ−5)+6−3a+3(λ−4)+3a(λ−2)+2(λ−5)=(λ2−6λ+8)(λ−4)+3a(λ−2)+2(λ−2)=(λ−2)(λ2−8λ+18+3a)(\\lambda-1)(\\lambda-4)(\\lambda-5)+6-3a+3(\\lambda-4)+3a(\\lambda-2)+2(\\lambda-5)=(\\lambda^2-6\\lambda+8)(\\lambda-4)+3a(\\lambda-2)+2(\\lambda-2)=(\\lambda-2)(\\lambda^2-8\\lambda+18+3a)(λ−1)(λ−4)(λ−5)+6−3a+3(λ−4)+3a(λ−2)+2(λ−5)=(λ2−6λ+8)(λ−4)+3a(λ−2)+2(λ−2)=(λ−2)(λ2−8λ+18+3a)。若 λ=2\\lambda=2λ=2 为二重根，则 a=−2a=-2a=−2。否则 a=−23a=-\\frac 2 3a=−32​，二重根为 444。若 a=−2a=-2a=−2，(2E−A)α=O(2\\bm E-\\bm A)\\bm\\alpha=\\bm O(2E−A)α=O，解齐次线性方程组得到 [1−23000000000]\\begin{bmatrix}1 -2 3 0\\\\0 0 0 0\\\\0 0 0 0\\end{bmatrix}​100​−200​300​000​​，R(A)=1R(\\bm A)=1R(A)=1，因此可相似对角化。类似的可知 a=−23a=-\\frac 2 3a=−32​ 不可相似对角化，不再赘述。 5.3 一些特殊矩阵 5.3.1 正交矩阵 若 αβ=0\\bm\\alpha\\bm\\beta=0αβ=0，则称 α,β\\bm\\alpha,\\bm\\betaα,β 正交，而正交向量组是线性无关组的充分不必要条件。如果每个向量都是单位向量，则是单位正交组。 Schmidt 单位正交化可以将一个线性无关的向量组化为单位正交组，我们先处理正交这一条件，单位化是好处理的（每个向量都除以它的模长）。想要正交，只需要令 bi=ai−∑j=1i−1bj⋅aibj⋅bjbj\\displaystyle b_i=a_i-\\sum_{j=1}^{i-1}\\frac{b_j\\cdot a_i}{b_j\\cdot b_j}b_jbi​=ai​−j=1∑i−1​bj​⋅bj​bj​⋅ai​​bj​。 如果 nnn 阶实矩阵 A\\bm AA 的列向量是单位正交组，那么其是正交矩阵，判定正交矩阵的充要条件是 AA⊤=E\\bm A\\bm A^{\\top}=\\bm EAA⊤=E。 若 A,B\\bm A,\\bm BA,B 是正交矩阵，那么 det⁡A=1 或 −1\\det \\bm A=1\\ 或\\ -1detA=1 或 −1，AB\\bm A \\bm BAB 是正交矩阵。用正交矩阵作为相似因子做正交变换称为正交变换。 5.3.2 共轭矩阵 每一个元素都换成其共轭复数得到共轭矩阵 A‾\\overline{\\bm A}A。 我们有 det⁡A‾=det⁡A‾,(A‾)−1=A−1‾\\det \\overline{\\bm A} = \\overline{\\det \\bm A},(\\overline{\\bm A})^{-1}=\\overline{\\bm A^{-1}}detA=detA,(A)−1=A−1。 5.4 实对称矩阵的相似对角化 实对称矩阵的所有特征根都是实数，且对应不同特征值的特征向量正交。相似对角化时，相似因子是一个正交矩阵，只需要在求解出一个特征根对应的基础解系后，将其单位正交化即可。 证明：nnn 阶实矩阵 A\\bm AA 的特征根都是实数，则 A\\bm AA 一定相似于上三角矩阵。 5.5 实矩阵的相似 6. 二次型 定义二次型为 f(x1,⋯ ,xn)=∑i=1n∑j=1naijxixj\\displaystyle f(x_1,\\cdots,x_n)=\\sum_{i=1}^n\\sum_{j=1}^n a_{ij}x_ix_jf(x1​,⋯,xn​)=i=1∑n​j=1∑n​aij​xi​xj​，其中 aij=ajia_{ij}=a_{ji}aij​=aji​，那么有唯一的对称 nnn 阶方阵 A\\bm AA，使得列向量 x\\bm xx 满足 f(x)=x⊤Axf(\\bm x)=\\bm x^\\top \\bm A\\bm xf(x)=x⊤Ax。其中 A\\bm AA 称为二次型 fff 的矩阵，矩阵的秩定义为二次型 fff 的秩。 已知列向量 y\\bm yy，若 x=Py\\bm x=\\bm P\\bm yx=Py，那么这是 y→x\\bm y\\rightarrow \\bm xy→x 的线性变换（因为满足线性），P\\bm PP 称为系数矩阵，当 P\\bm PP 可逆时，称为可逆线性变换（满秩线性变换、非退化线性变换），不可逆时可称为降秩线性变换。 若存在可逆矩阵 P\\bm PP，使得 P⊤AP=B\\bm P^\\top \\bm A \\bm P=\\bm BP⊤AP=B，那么称 A\\bm AA 和 B\\bm BB 合同，记为 A≃B\\bm A\\simeq \\bm BA≃B。 6.1 二次型的标准型 只含平方项的二次型称为标准形式的二次型，即标准型，它的矩阵是对角矩阵。我们的目的是通过可逆线性变换，将二次型 f(x)f(x)f(x) 化为标准型 g(y)g(y)g(y)。 二次型能用可逆线性变换 x=Py\\bm x=\\bm P \\bm yx=Py 化为标准型的充要条件是 ∃P,i.e.⁡P⊤AP=B=diag⁡(b1,⋯ ,bn)\\exist \\bm P,\\ie \\bm P^\\top \\bm A\\bm P=\\bm B=\\operatorname{diag}(b_1,\\cdots,b_n)∃P,i.e.P⊤AP=B=diag(b1​,⋯,bn​)，此时 x⊤Ax=y⊤By\\bm x^\\top \\bm A\\bm x=\\bm y^\\top \\bm B\\bm yx⊤Ax=y⊤By。相当于要通过合同变换将对称矩阵化为对角矩阵。 因此想要用将实二次型化为标准型，由于实对称矩阵相似对角化时一定可以搞一个正交矩阵，它的转置等于它的逆，因此直接将其相似对角化即可。其相似因子是一个正交矩阵，即为 P\\bm PP。 事实上，对于任意二次型都可以化标准型，因此，任意对称矩阵必合同于某一对角矩阵。 我们也可以使用配方法来化标准型，这种方法并没有使用线性代数的知识。但如果交叉项较多，计算量可能很大。因此接下来我们介绍另一种方法。 对于一个初等矩阵 P\\bm PP，搞一个 P⊤AP\\bm P^\\top \\bm A\\bm PP⊤AP，即初等合同变换。初等合同变换相当于是先进行初等行变换，再进行相对应的初等列变换。由于任意对称矩阵必然合同于对角矩阵，因此对 A\\bm AA 进行若干次初等合同变换便可完成化标准型。想要求出这个过程中的合同因子，只需要构造 2n×n2n\\times n2n×n 的矩阵 [AE]\\begin{bmatrix}\\bm A\\\\ \\bm E\\end{bmatrix}[AE​]，在进行行变换时只对前 nnn 行进行操作，进行列变换时 E\\bm EE 随之进行，最终就得到了 [BP]\\begin{bmatrix}\\bm B\\\\ \\bm P\\end{bmatrix}[BP​]。 求 [−12−1200−10−3]\\begin{bmatrix}-1 2 -1\\\\2 0 0\\\\-1 0 -3 \\end{bmatrix}​−12−1​200​−10−3​​ 的标准型。依次进行 2r1+r2,−r1+r3,12r2+r32r_1+r_2,-r_1+r_3,\\frac 1 2r_2+r_32r1​+r2​,−r1​+r3​,21​r2​+r3​ 的行消法变换，然后得到 [−10004000−31200112001]\\begin{bmatrix}-1 0 0\\\\0 4 0\\\\0 0 -3\\\\1 2 0\\\\0 1 \\dfrac 1 2\\\\ 0 0 1\\end{bmatrix}​−100100​040210​00−3021​1​​。因此 B\\bm BB 即为标准型，g(y)=−y12+4y22−3y32g(\\bm y)=-y_1^2+4y_2^2-3y_3^2g(y)=−y12​+4y22​−3y32​。 6.2 二次型的规范型 通过合同变换，可知二次型的标准型是无穷多的。但是对于实二次型来说，我们可以通过倍法变换和换法变换，得到一个形如 [E−EO]\\begin{bmatrix}\\bm E \\\\ -\\bm E \\\\ \\bm O \\end{bmatrix}​E​−E​O​​ 的标准型。这个东西被称为规范型。 其中 111 的个数 ppp 称为正惯性指数，−1-1−1 的个数 qqq 称为负惯性指数，p−qp-qp−q 称为符号差。实二次型的规范型是唯一的（惯性定理）。 对于复二次型，则必然可以化为 [EO]\\begin{bmatrix}\\bm E \\\\ \\bm O \\end{bmatrix}[E​O​]，也是唯一的。 6.3 实二次型的分类 ∀x≠0\\forall \\bm x e \\bm 0∀x=0，实二次型 fff 满足 f(x)0f(x) 0f(x)0 是正定二次型，满足 f(x)0f(x)0f(x)0 是负定二次型，f(x)≥0f(x)\\ge 0f(x)≥0 是半正定二次型，f(x)≤0f(x)\\le 0f(x)≤0 是半负定二次型，有正有负则是不定二次型。此时 A\\bm AA 称为正定矩阵等。 可逆线性变换不改变实二次型的正定性。 只需要研究正定二次型，其余的情况是对称的。正定的充要条件是符号差为 nnn（半正定负惯性指数为 000），也可以说是 A\\bm AA 的特征根全部为正（半正定全部不为负）。 kkk 阶子式强制要求选择前 kkk 行和前 kkk 列得到 kkk 阶顺序主子式，正定的另一个充要条件是所有的顺序主子式为正（半正定全部不为负）。 7. 线性空间 是不是应该先学抽象代数来着。 不管了，我先把教材朗读完。 7.1 线性空间 设 VVV 是一个非空集合，FFF 是一个数域，(V,+)(V,+)(V,+) 有幺元且满足交换律，还能定义一个 FFF 和 VVV 之间的数乘运算，那么 VVV 是在 FFF 上的一个线性空间。 若 V1V_1V1​ 是 VVV 的非空子集，且依然满足构成线性空间的性质，那么 V1V_1V1​ 是 VVV 的线性子空间。VVV 的幺元构成的集合称为零子空间，和 VVV 本身构成了平凡子空间。 定义 V1+V2={α1+α2∣,α1∈V1,α2∈V2}V_1+V_2=\\{\\bm\\alpha_1+\\bm\\alpha_2|,\\bm\\alpha_1\\in V_1,\\bm\\alpha_2\\in V_2\\}V1​+V2​={α1​+α2​∣,α1​∈V1​,α2​∈V2​}，V1∩V2V_1\\cap V_2V1​∩V2​ 称为交空间，V1+V2V_1+V_2V1​+V2​ 称为和空间，显然它们都是子空间。 线性空间基底的元素个数称为维度，记作 dim⁡V\\dim VdimV。 7.2 坐标与坐标变换 当已知一组基底时，我们可以确定一个向量的坐标，是一个列向量 \\hat\\bm\\alpha。向量组线性相关的充要条件是它们的坐标线性相关。 设 ϵi,ϵi′\\epsilon_i,\\epsilon_iϵi​,ϵi′​ 是 VVV 下的两组基底，有 (ϵ1′,⋯ ,ϵn′)=(ϵ1,⋯ ,ϵn)A(\\epsilon_1,\\cdots,\\epsilon_n)=(\\epsilon_1,\\cdots,\\epsilon_n)\\bm A(ϵ1′​,⋯,ϵn′​)=(ϵ1​,⋯,ϵn​)A，A\\bm AA 称为过渡矩阵（变换矩阵），矩阵 A\\bm AA 是唯一且可逆的。换基底时的坐标变换，也不难得到 [x1⋮xn]=A[x1′⋮xn′]\\begin{bmatrix}x_1\\\\ \\vdots \\\\ x_n\\end{bmatrix}=\\bm A\\begin{bmatrix}x_1\\\\ \\vdots \\\\ x_n\\end{bmatrix}​x1​⋮xn​​​=A​x1′​⋮xn′​​​。 7.3 变换 α→α′\\bm\\alpha\\rightarrow \\bm\\alphaα→α′，α′\\bm\\alphaα′ 为像，α\\bm\\alphaα 为一个原像（像源）。线性变换满足线性性质。 如果我们知道了线性变换对基的作用，就可以知道线性变换所有向量的作用。对于线性变换 σ\\sigmaσ，我们有 (σ(ϵ1),⋯ ,σ(ϵn))=(ϵ1,⋯ ,ϵn)A(\\sigma(\\epsilon_1),\\cdots,\\sigma(\\epsilon_n))=(\\epsilon_1,\\cdots,\\epsilon_n)\\bm A(σ(ϵ1​),⋯,σ(ϵn​))=(ϵ1​,⋯,ϵn​)A。也就是说，A\\bm AA 的第 iii 列就是 σ(ϵi)\\sigma(\\epsilon_i)σ(ϵi​) 在基底 ϵ\\epsilonϵ 下的坐标。不难得知 A\\bm AA 是唯一的。该矩阵可以描述线性变换，比如说 α\\bm\\alphaα 的坐标为 x\\bm xx，σ(α)\\sigma(\\bm\\alpha)σ(α) 的坐标则为 Ax\\bm A\\bm xAx。 线性变换的加乘法可以视作矩阵的加乘法，逆变换也为逆矩阵。 同一变换在不同基底下，矩阵是相似的，相似因子恰为基底的过渡矩阵。 A\\bm AA 的特征根称为 σ\\sigmaσ 的特征根，假定矩阵对应的特征向量为 x\\bm xx，则 σ\\sigmaσ 的特征向量为 α=∑i=1nxiϵi\\bm\\alpha=\\displaystyle\\sum_{i=1}^n x_i\\epsilon_iα=i=1∑n​xi​ϵi​。 8. 试卷选做 8.1 吉林大学 线性代数A 2024 期末 还挺简单。 选择题 A，将 2,4,22,4,22,4,2 的列系数扔到外面，按第一列展开，得到两个行列式的和。C，左行右列。C，反证，左乘 A\\bm AA 即可。B，略。D，略。D，略。填空题 555，这是一个幂等矩阵的性质，使用不等式夹出来。−15-15−15，略。−2-2−2，det⁡A=0\\det A=0detA=0 即可解出 −2,1-2,1−2,1，然后 111 是无解。−23-\\frac 2 3−32​，见 5.2 例题 3。(−2,2)(-\\sqrt{2},\\sqrt 2)(−2​,2​)，略。222，略。三 x1=x2=x3=0,x4=−(a1+a2+a3+a4)x_1=x_2=x_3=0,x_4=-(a_1+a_2+a_3+a_4)x1​=x2​=x3​=0,x4​=−(a1​+a2​+a3​+a4​)。略。四 记得两个转置矩阵相乘的性质，然后就是简单的求逆，答案是 [1000−21001−21001−21]\\begin{bmatrix}1 0 0 0\\\\-2 1 0 0\\\\1 -2 1 0\\\\0 1 -2 1\\end{bmatrix}​1−210​01−21​001−2​0001​​。五 该向量组秩为 333，然后 α3=α1+2α2\\bm\\alpha_3=\\bm\\alpha_1+2\\bm\\alpha_2α3​=α1​+2α2​。六 无聊，(1,1,2,2)⊤(1,1,2,2)^\\top(1,1,2,2)⊤，记得求逆矩阵的时候初等变换的顺序要倒过来。七 第一问易证。由于 R(A)=2R(\\bm A)=2R(A)=2，因此三阶子式为 000，得到 a=2,b=−3a=2,b=-3a=2,b=−3，然后平凡，不做了。八 无聊。λ=3,α=k(0,1,1)⊤,λ=9,α=k1(1,−1,0)⊤+k2(0,−2,1)⊤\\lambda=3,\\bm\\alpha=k(0,1,1)^\\top,\\lambda=9,\\bm\\alpha=k_1(1,-1,0)^\\top+k_2(0,-2,1)^\\topλ=3,α=k(0,1,1)⊤,λ=9,α=k1​(1,−1,0)⊤+k2​(0,−2,1)⊤。九 无聊。det⁡(A+E)=0\\det(\\bm A+\\bm E)=0det(A+E)=0 说明 λ=−1\\lambda=-1λ=−1，AB=2B\\bm A\\bm B=2\\bm BAB=2B，右乘单位列向量即可发现 λ=2\\lambda=2λ=2，且 B\\bm BB 的秩为 222，得到 (−1,1,0)⊤,(−1,0,1)⊤(-1,1,0)^\\top,(-1,0,1)^\\top(−1,1,0)⊤,(−1,0,1)⊤ 两个特征向量，然后单位正交化得到 (−22,22,0)⊤,(−66,−66,63)⊤\\left(-\\frac{\\sqrt{2}}{2},\\frac{\\sqrt{2}}{2},0\\right)^\\top,\\left(-\\frac{\\sqrt{6}}{6},-\\frac{\\sqrt{6}}{6},\\frac{\\sqrt{6}}{3}\\right)^\\top(−22​​,22​​,0)⊤,(−66​​,−66​​,36​​)⊤，最后一个特征向量利用不同特征根的特征向量正交解出 (33,33,33)⊤\\left(\\frac{\\sqrt{3}}{3},\\frac{\\sqrt{3}}{3},\\frac{\\sqrt{3}}{3}\\right)^\\top(33​​,33​​,33​​)⊤，然后算得 A=[1−1−1−11−1−1−11]\\bm A=\\begin{bmatrix}1 -1 -1\\\\-1 1 -1\\\\-1 -1 1\\end{bmatrix}A=​1−1−1​−11−1​−1−11​​。"},{"title":"概率论","path":"/wiki/maths/3-1.html","content":"1"},{"title":"数理统计","path":"/wiki/maths/4-1.html","content":"1"},{"title":"二分与倍增","path":"/wiki/oi-note/1-1.html","content":"两者的本质均基于单调性，寻找题目中具有单调性的函数关系，然后施展二分或者倍增。二分答案可以用来解决分数规划问题，三分法可以求解单峰/谷函数。同时，二分上界不确定的内容的最佳方式是倍增，通过先倍增到上界，再倍增答案来解决。 二分 一种二分写法 通过 l = r 之类的方法的二分笔者认为有些过于诡异，这里给出我自己的二分实现方式（我记得当时是在 B 站学的，但是出自哪个视频忘了）。 Luogu P2249int L = 0, R = n + 1;while (L + 1 != R) int mid = L + R 1; if (a[mid] = x) R = mid; else L = mid;if (a[R] == x) cout R ;else cout -1 ; 01 分数规划 用来求一个分式的极值，也就求一组 wi={0,1}w_i=\\{0,1\\}wi​={0,1}，最大化或者最小化： ∑ai×wi∑bi×wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} ∑bi​×wi​∑ai​×wi​​ 我们一般使用二分答案来解决这个问题。以最大值为例： ∑ai×wi∑bi×wimid⟹∑ai×wi−mid×∑bi×wi0⟹∑wi(ai−mid×bi)0\\begin{aligned} \\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}mid\\\\ \\Longrightarrow \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i 0\\\\ \\Longrightarrow \\sum w_i(a_i-mid\\times b_i)0 \\end{aligned} ⟹⟹​∑bi​×wi​∑ai​×wi​​mid∑ai​×wi​−mid×∑bi​×wi​0∑wi​(ai​−mid×bi​)0​ 于是排序即可确定 wiw_iwi​ 的值。有些时候会限制 ∑bi×wi\\sum b_i\\times w_i∑bi​×wi​ 的最小值之类的，例题，这时使用背包求解即可。 三分法 三分法可以用于求解单峰函数的极值点。对于常规的三分写法不再赘述，但值得注意的是，对于定义域为整数的实际问题，它们的答案可能真的是单峰的，但此时由于其不满足函数的连续性，会存在一大段平的区间，然后三分就炸了（鬼知道极值点在哪，你需要 O(n)O(n)O(n) 扫过去）。 不要错误的将某些函数视作可以三分，更不要将单峰函数视作凸函数而对导函数二分。单峰的证明是比较困难的，而且有时对于非单峰的问题也比较难找到反例（廊桥分配），要根据实际情况判断。 Luogu P1883 画图可知，两个单谷函数（一次函数的谷点视作在无穷远处）取 max⁡\\maxmax 后，得到的新函数仍然是单谷函数，因此直接三分即可。 但很阴的是，这题要求极值而不是极值点，精度会被 bbb 吃掉，因此 eps 要取小。 double L = 0, R = 1000;while (L + eps R) double Lmid = (L + R) / 2; double Rmid = (Lmid + R) / 2; if (calcF(Lmid) calcF(Rmid)) L = Lmid; else R = Rmid; wqs 二分 O(log⁡n)O(\\log n)O(logn) 倍增 ST 表 ST 表使用倍增结构来实现，支持在末尾插入一个数。大概长这样： f[0][n] = a[n]; // The new Nfor (int j = 1; 1 j = n; ++j) f[j][n - (1 j) + 1] = max(f[j - 1][n - (1 j) + 1], f[j - 1][n - (1 j - 1) + 1]); 在开头插入亦同理。 例题 [SCOI2016] 萌萌哒 Portal. 并查集？复杂度不对，考虑倍增并查集。使用类似于 ST 表的结构，操作时直接操作高层节点的并查集，处理完之后将高层内容下放，这样可以得到完整的答案。代码。 [USACO23JAN P] Tractor Paths Portal. 最短距离能走到更远肯定是更好的，因此第一问直接倍增。 第二问要求 dis(a,u)+dis(u,b)=dis(a,b)dis(a,u)+dis(u,b)=dis(a,b)dis(a,u)+dis(u,b)=dis(a,b) 的 uuu 的个数，假设从 aaa 向右跳 iii 步可以到达 rir_iri​，从 bbb 向左跳 ans−ians-ians−i 步可以到达 lil_ili​，那么必定 li≤ril_i\\le r_ili​≤ri​（否则你是怎么从 aaa 走到 bbb 的）。实际上画个图可以发现，l1≤r1≤l2≤r2⋯l_1\\le r_1\\le l_2\\le r_2\\cdotsl1​≤r1​≤l2​≤r2​⋯，因此就是若干个不相交的区间来贡献答案。 注意至少跳一步，否则会涉及到和 a,ba,ba,b 取 max、min 的问题。代码。 例题 刷基础 1 [3rd ucup s39] Array Similarity Portal。记录每个数向右跳几次可以到第一个大于等于它的数，倍增地查找答案，然后将这个跳跃次数序列哈希起来比较即可。代码。 刷提升 [AGC020D] Min Max Repetition Portal. 字符串填写的方式不难得出，最小连续长度 k=max⁡{⌈AB+1⌉,⌈BA+1⌉}k=\\max\\left\\{\\left\\lceil\\cfrac{A}{B+1}\\right\\rceil,\\left\\lceil\\cfrac{B}{A+1}\\right\\rceil\\right\\}k=max{⌈B+1A​⌉,⌈A+1B​⌉}。 字符串一定是 (AkB)(A^kB)(AkB) 的一个前缀加上 (ABk)(AB^k)(ABk) 的一个后缀。如何找到分界点？最优情况下分界点一定是一个 AAA，是前后缀公用的。假设分界点之前有 bbb 个 BBB 和 aaa 个 AAA，那么应满足 b≤max⁡{0,⌊a−1k⌋}b\\le \\max\\left\\{0,\\left\\lfloor\\cfrac{a-1}{k}\\right\\rfloor\\right\\}b≤max{0,⌊ka−1​⌋}，也就是 a=A−⌈B−bk⌉+1a=A-\\left\\lceil\\cfrac{B-b}{k}\\right\\rceil+1a=A−⌈kB−b​⌉+1。二分找到最大的 bbb 即可确定一切。代码。 ** [CF1764G] Doremy’s Perfect DS Class G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pnmidp_n midpn​mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pnmid′p_nmidpn​mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点浪费，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。代码。"},{"title":"杂项内容","path":"/wiki/oi-note/1-100.html","content":"曼哈顿与切比雪夫距离转化 曼哈顿距离是指 x,yx,yx,y 坐标的差的和，而切比雪夫距离指的是差的最大值。 从曼哈顿距离转化成切比雪夫距离，令 xi′=xi+yi,yi′=xi−yix_i=x_i+y_i,y_i=x_i-y_ixi′​=xi​+yi​,yi′​=xi​−yi​，反着转的时候反过来解一下二元一次方程组就行。 例题 [EC Online 2025 I] Moving on the Plane Portal. 首先转成切比雪夫，然后两维独立了。然后坐标范围很小，于是直接枚举最后点走到的坐标范围。然后你发现 KKK 更小，甚至可以直接枚举位置。注意会算重，于是改为钦定最小坐标，把没有点走到最小坐标的东西减去就好了。代码。"},{"title":"分治","path":"/wiki/oi-note/1-2.html","content":"分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 仿照分治的结构可以衍生出一大堆静态分治算法。 普通分治 [uoj979] 决战库尔斯克 Portal. 首先排序去重。如果选择钦定最小值，发现需要枚举最小值的倍数然后在一段中二分出最大值，但是值域很大，寄了。 那么钦定最大值，最小值可以选择严格比其一半大的，那么答案是差。假定最小的严格比一半大的是 amida_{mid}amid​。 考虑小于的部分对大于的部分的影响，枚举小数 aia_iai​，发现需要 ai−1ar−amida_i - 1 a_r - a_{mid}ai​−1ar​−amid​，这样就只有至多两段 aia_iai​ 的倍数了，直接二分。 于是递归下去即可，O(nlog⁡Vlog⁡n)O(n\\log V\\log n)O(nlogVlogn)，两个 log 都跑不满。代码。 * [CF1442D] Sum Portal.给定 nnn 个不降的数组。有一个值 ansansans，初始为 000。你需要进行如下操作 kkk 次：选择一个数组，把 ansansans 加上数组的第一个元素，之后把它删除。请求出 ansansans 最大是多少。所有数组的元素总个数 ≤106\\leq 10^6≤106，n,k≤3000n,k\\leq 3000n,k≤3000。 注意到数组是单调不降的，因此要取一个数组就会一直取下去直到不能取或者取光了。 所以可以想到一个暴力一点的做法：将一个数组视为一个有体积有价值的物品，然后正反做两遍 01 背包，枚举没取满的那个数组和这个数组取多少个，再枚举前面取的体积，这样就可以得出后面取的体积，并计算出总价值，时间复杂度为 O(nk2)O(nk^2)O(nk2)。 这样肯定过不去，发现就是合并太慢了，考虑使用分治算法合并：求解 (l,r)(l,r)(l,r) 时，我们先将 (l,mid)(l,mid)(l,mid) 加入背包，然后递归求解 (mid+1,r)(mid+1,r)(mid+1,r)，当 l=rl=rl=r 时就可以枚举当前体积了。时间复杂度 O(nklog⁡n)O(nk\\log n)O(nklogn)。 这个问题被称为缺一背包，意思是其中有一个可以取不满，一般采用上述分治法解决。 int n, k;vectori64 a[3005];i64 ans = 0, f[3005];void merge(int l, int r) if (l == r) for (int i = 0; i = min(k, (int)a[l].size() - 1); ++i) ans = max(ans, a[l][i] + f[k - i]); return; int mid = l + r 1; i64 g[3005]; memcpy(g, f, sizeof(g)); for (int i = mid + 1; i = r; ++i) for (int j = k; j = a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(l, mid); memcpy(f, g, sizeof(f)); for (int i = l; i = mid; ++i) for (int j = k; j = a[i].size() - 1; --j) f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]); merge(mid + 1, r);int main(void) scanf(%d%d, n, k); for (int i = 1; i = n; ++i) int m; scanf(%d, m); a[i].resize(m + 1); for (int j = 1, x; j = m; ++j) scanf(%lld, a[i][j]), a[i][j] += a[i][j - 1]; merge(1, n); printf(%lld , ans); return 0; 二维分治 其实就是对两个东西进行分治，每次将其中一个东西切半（为了保证效率，一般选择其中区间更长的一个切半），然后合并答案。 [CF364E] Empty Rectangles.给定一个 n×m(1≤n,m≤2.5×103)n\\times m(1\\le n, m\\le 2.5\\times 10^3)n×m(1≤n,m≤2.5×103) 的 01 矩阵，询问有多少个子矩阵满足只有 k(1≤k≤6)k(1\\le k\\le 6)k(1≤k≤6) 个 1。 本题要求恰好有 kkk 个 1 的子矩形数量，我们将当前矩形劈成两半（以劈成左一半和右一半为例），那么符合条件的子矩形要么在左半，要么在右半，要么跨越中线。 考虑跨越中线的如何合并。我们枚举子矩形的上下边界，然后开个桶 ppp 统计左半矩形所含 111 数量小于 iii 时左边界的最小值（右半矩形同理），然后直接枚举左半边的 111 的个数就可以统计了。代码。 CDQ 分治 树套树的本质作用是降维，但是如果允许离线，则可以使用 CDQ 分治高效地完成这个问题。 最重要的应用是解决三维偏序问题。分别处理三个信息。第一维可以将原数组按照 xxx 排序，xi≤xjx_i\\le x_jxi​≤xj​ 转化为 ijijij。注意此时如果数都相同会出问题，因此去个重。第二维可以在分治时采用类似于归并排序的方式解决（求正序对），不过由于第三维的限制，并不是所有的信息都可以加到答案里的，需要整一个权值树状数组来处理第三维的信息：左半段序列的信息加入树状数组，右半段信息进行统计。代码。 CDQ 分治的写法非常灵活，像三维偏序问题是对分治树进行后序遍历来统计答案的。对于一些 DP 问题，往往可以在中序遍历时统计前面一半对后面一半的影响。 例题 这里选择一些比较有代表性的问题。 【模板】离线静态四维数点 Portal. 四维偏序模板题。 查看代码 #include bits/stdc++.husing namespace std;const int N = 4e5 + 5;int n, m, lsh[N * 2], C[N * 2], ans[N];struct Node int a, b, c, d, id, op; bool operator (const Node a) const if (this-a != a.a) return this-a a.a; return id a.id; a[N * 2], b[N * 2], T[N * 2];inline void add(int x, int k) for (; x = n; x += x -x) C[x] += k; inline int sum(int x) int r = 0; for (; x; x -= x -x) r += C[x]; return r; void cdq2(int l, int r) if (l == r) return; int mid = l + r 1; cdq2(l, mid); cdq2(mid + 1, r); for (int i = l, p = l, q = mid + 1; i = r; ++i) if (p = mid (q r || b[p].c = b[q].c)) if (b[p].op == 0 b[p].id == 0) add(b[p].d, 1); ++p; else if (b[q].op == 1 b[q].id) ans[b[q].id] += sum(b[q].d); ++q; for (int i = l; i = mid; ++i) if (b[i].op == 0 b[i].id == 0) add(b[i].d, -1); merge(b + l, b + mid + 1, b + mid + 1, b + r + 1, T + l, [](Node x, Node y) return x.c != y.c ? x.c y.c : x.id y.id; ); for (int i = l; i = r; ++i) b[i] = T[i]; // sort(b + l, b + r + 1, [](Node x, Node y) return x.c != y.c ? x.c y.c : x.id y.id; );void cdq(int l, int r) if (l == r) return; int mid = l + r 1; cdq(l, mid); cdq(mid + 1, r); for (int i = l; i = mid; ++i) a[i].op = 0; // a 小的左半部分产生贡献 for (int i = mid + 1; i = r; ++i) a[i].op = 1; // a 大的右半部分计算答案 merge(a + l, a + mid + 1, a + mid + 1, a + r + 1, T + l, [](Node x, Node y) return x.b != y.b ? x.b y.b : x.id y.id; ); // 按照 b 排序，进行 CDQ 分治计算答案 for (int i = l; i = r; ++i) a[i] = b[i] = T[i]; // sort(a + l, a + r + 1, [](Node x, Node y) return x.b != y.b ? x.b y.b : x.id y.id; ); // for (int i = l; i = r; ++i) b[i] = a[i]; cdq2(l, r);int main(void) ios::sync_with_stdio(0); cin n m; for (int i = 1; i = n + m; ++i) cin a[i].a a[i].b a[i].c a[i].d; a[i].c *= -1; a[i].d *= -1; lsh[i] = a[i].d; if (i n) a[i].id = i - n; n += m; sort(a + 1, a + n + 1); sort(lsh + 1, lsh + n + 1); for (int i = 1; i = n; ++i) a[i].d = lower_bound(lsh + 1, lsh + n + 1, a[i].d) - lsh; cdq(1, n); for (int i = 1; i = m; ++i) cout ans[i] ; return 0;"},{"title":"随机化算法","path":"/wiki/oi-note/1-3.html","content":"有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据满足一定条件，否则会 TLE 或者超交互次数。 生成随机数mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());int rndint(int l, int r) return uniform_int_distribution(l, r)(rng);double rnddb(int l, int r) return uniform_real_distribution(l, r)(rng);"},{"title":"哈希方法","path":"/wiki/oi-note/1-4.html","content":"序列哈希 即字符串哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 配合二分，字符串哈希可以以 O(knlog⁡n)O(kn\\log n)O(knlogn) 的时间复杂度完成允许失配 kkk 次的字符串匹配问题。 集合哈希 树哈希 哈希表 例题 刷基础 [CSP-S 2022] 星战 Portal. 要求所有点的出度都是 111。其实是要维护一个可重集，对于每一条边，都要将这条边的起点加入集合。只有这个集合恰好为 1∼n1\\sim n1∼n 的集合才是合法的。 因此直接使用集合哈希维护，摧毁和修复节点的操作都是加减法可以完成的。代码。 注意这里只能用 sum Hash，xor Hash 是错误的，比如一个点的出度为 333 也会被视作为合法的。 [AMPPZ 2023] Fibonacci Fusion Portal. 首先需要取枚举每一个数，不妨枚举那个比较大的数，发现不同的合法的较小的数最多只有两个。因为斐波那契数想要变大，过两项就会翻倍。这样在大数确定时，和不能翻两倍。 我们要找出比这个大数大的斐波那契数，观察通项公式 fn=15(((1+5)2)n−((1−5)2)n)f_n=\\frac{1}{\\sqrt{5}}\\left(\\left(\\frac{(1+\\sqrt{5})}{2}\\right)^n - \\left(\\frac{(1-\\sqrt{5})}{2}\\right)^n\\right)fn​=5​1​((2(1+5​)​)n−(2(1−5​)​)n)，在 nnn 足够大时可以直接将后面减的那一项放缩掉，便可以直接解出 nnn（两边取自然对数，一个数的自然对数可以通过它的位数估计），然后对这些斐波那契数求解即可。 高精度计算肯定是不行的，我们直接让所有数在对大质数取模意义下计算即可。笔者的实现为了保险采用了双哈希，但感觉没必要，代码。"},{"title":"线性代数","path":"/wiki/oi-note/10-0.html","content":"/wiki/algebra/1.html. 前置知识 高斯消元 行列式求值 行列式求值，枚举主对角线上的位置，通过行消法变换 + 辗转相除将一个行首转化成 000，然后换法变换将这一列底下的东西转成 000。 int sol(void) int f = 1; for (int i = 1; i = n; ++i) for (int j = i + 1; j = n; ++j) while (a[i][i]) int d = a[j][i] / a[i][i]; for (int k = i; k = n; ++k) a[j][k] = (a[j][k] - 1ll * d * a[i][k] % P + P) % P; swap(a[i], a[j]), f = -f; swap(a[i], a[j]); f = -f; int ans = f; for (int i = 1; i = n; ++i) ans = 1ll * ans * a[i][i] % P; return (ans + P) % P; 特征多项式"},{"title":"组合博弈论","path":"/wiki/oi-note/10-2.html","content":"博弈论主要研究一些有竞争或对抗性质的对象，在一定规则下/产生的各种行为。 接下来讨论的所有问题，若没有写出，均默认为两人轮流行动的、完美信息、无随机因素。 通常来讲，无法行动的人会输掉，称为正常博弈，而无法行动却获胜称为反常博弈。 公平组合博弈 引入 我们从 Nim 游戏开始研究。有 nnn 堆石子，每人每次可从任意一堆石子里取出正整数枚石子扔掉，谁不能动谁就输了。 我们将每个状态视作一个节点，那么博弈情况就可以刻画成一张有向图。不难发现，异或和为 000 时先手必败。 大部分的公平组合游戏都可以转换为有向图游戏，对于状态 xxx 和它的 kkk 个后继状态 y1,⋯ ,yky_1,\\cdots,y_ky1​,⋯,yk​，定义 SG 函数为： SG⁡(x)=mex⁡{SG⁡(y1),SG⁡(y2),…,SG⁡(yk)}\\operatorname{SG}(x)=\\operatorname{mex}\\{\\operatorname{SG}(y_1), \\operatorname{SG}(y_2), \\ldots, \\operatorname{SG}(y_k)\\} SG(x)=mex{SG(y1​),SG(y2​),…,SG(yk​)} 对于由 nnn 个有向图游戏组成的组合游戏，当且仅当 ⊕SG⁡(s)≠0\\oplus \\operatorname{SG}(s) e 0⊕SG(s)=0 的时候，先手必胜，称之为 P 态（previous player）。也就是说，SG⁡(x)=0\\operatorname{SG}(x)=0SG(x)=0 是必败态，称之为 N 态。 SG 定理：一个游戏的 SG 值是其所有子游戏的 SG 值的异或和，这可以说明 Nim 游戏结论的由来。 Anti-SG 定理 如果游戏的 SG 值为 000，那么所有子游戏的 SG 值都不超过 111 时先手必胜； 如果游戏的 SG 值不是 000，那么至少有一个子游戏的 SG 值超过 111 时先手必胜。 模板。 Colon Principle 针对树形结构的博弈，我们假定一次操作可以删除一条边，然后保留根节点所在的子树。不能操作者输掉。 首先对于一条长度为 xxx 的链，其 SG 值为 x−1x-1x−1。一棵树可以分解成若干个子问题，每个子问题都是根节点的一棵子树加上根节点本身。 如果一棵子树的 SG 值为 xxx，那么其可以等效为一个长度为 x+1x+1x+1 的链。也就是说，新搞一个点连到树根上，这棵树的 SG 值会加 111。 因此不难计算。模板，代码。 常见公平游戏 超现实数理论 非公平组合博弈"},{"title":"分块","path":"/wiki/oi-note/11-1.html","content":"Problemset 刷提升"},{"title":"概述","path":"/wiki/oi-note/12-1.html","content":"广义来说，所有问题都属于构造类问题——它们都需要构造解（bushi）。 此类题目中也有较多 ad-hoc 题，需要我们从多个角度思考，发挥自己的想象力。 我们不能对于每道题都枚举所有套路逐一试错，而需要具体情况具体分析。不应当完全依靠猜或试找出来，而是主要通过线索推断出来。它们包括但不限于： 特殊的题目条件、数据范围 特殊性质、部分分 必然性、充分性 模型的观察与转化 打表的结果 注意在做此类题目时，要避免自己陷入思维死局。"},{"title":"问题的分析","path":"/wiki/oi-note/13-1.html","content":"常见套路 正难则反 [Chengdu Regional 2025] K-Coverage Portal。如果直接枚举删除哪条线段，然后求解把它放在哪，可能不是很好做。不妨直接扔进去一条新的线段，不断移动它，然后看删除哪个线段最优。维护删除所有线段的贡献 deltaidelta_ideltai​，每次移动线段只会对一个连续段的线段的 deltadeltadelta 造成改变。代码。 操作的转化 [qoj962] Thanks to MikeMirzayanov Portal. 操作好像不是很方便，但是可以用两次操作实现对每一段分别翻转（即一次正常分一次全局）。于是问题就可以在值域上分治下去了（因为段之间互不影响），我们只需要对 01 排序，这是容易的，只需要不断地对间隔的 10 段来排序，O(log⁡n)O(\\log n)O(logn) 即可完成。注意不要每次操作后直接全局翻转使得你的常数乘二。代码。 例题 刷基础 [Ptz Winter 2020 Day3] Disjoint LIS Portal. 看上去非常 NP，"},{"title":"你需要注意的事情","path":"/wiki/oi-note/13-100.html","content":"否则我们无法成功收尸。 1. 策略性问题 想题之前检查有没有看错题。 太会做检查看没看错，太不会做检查看没看做。 做题之前检查看的数据范围，写完之后再检查一遍（比如输入是否是自然数而不是正整数？）。"},{"title":"并查集","path":"/wiki/oi-note/2-0.html","content":"拆点 即某教材中的“扩展域”并查集。反对这种恶意恐吓萌新的叫法。 CF776D。所有灯都恰好由两个开关控制，那么给每个开关拆成是否按下的两个点，并查集检查是否有矛盾即可。代码。"},{"title":"树状数组","path":"/wiki/oi-note/2-1.html","content":"又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 ratio:1415/735 模板，区间和我们可以用前缀和相减来求解，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) for (; x = n; x += x -x) C[x] += k; i64 sum(int x) i64 r = 0; for (; x; x -= x -x) r += C[x]; return r; int main(void) scanf(%d%d, n, m); for (int i = 1; i = n; ++i) scanf(%d, a + i), add(i, a[i]); while (m--) int op, x, y; scanf(%d%d%d, op, x, y); if (op == 1) add(x, y); else printf(%lld , sum(y) - sum(x - 1)); return 0;"},{"title":"线段树","path":"/wiki/oi-note/2-2.html","content":"线段树是一种功能强大的二叉数据结构，可以维护半群上的信息（满足结合律）。 对于一般情况，我们使用堆式线段树来存储线段树；对于空间开不下的情况，我们使用动态开点来存储线段树。 延迟标记 这个东西不只被用在线段树上，但从线段树结构基本可以介绍出它的大部分应用。以下问题都可以直接使用多元标记来处理： 区间最大子段和：维护前缀后缀最大子段和、区间和和答案即可； 区间平方和：不难根据区间和计算出新的区间平方和； 区间加等差数列单点求和：每个点维护一个 ddd，代表其加上的是 d×id\\times id×i，其中 iii 是下标，然后再维护一个区间加标记即可。 [CF446C] DZY Loves Fibonacci Numbers.区间加斐波那契数列，区间求和。 将广义斐波那契数列的前两项作为标记打在线段树中，合并时直接加起来就可以。再加上斐波那契数列的求和公式：∑i=1nfi=fn+2−f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2}∑i=1n​fi​=fn+2​−f2​，和便可以直接计算。代码。 李超线段树 模板。考虑这样一个问题：加入给定定义域的一次函数，查询 x∈[l,r]x\\in[l,r]x∈[l,r] 时的最小值。 怎么做？考虑一种线段树，维护 [l,r][l,r][l,r] 的节点只存储一个 midmidmid 处值最小的线段。修改操作如何实现呢？如果修改的线段不比当前线段优，那么下传修改线段；如果修改线段比当前线段优，那么下传当前线段。也就是说，要下传的一定是那个更劣的线段。这两条线段的交点在哪一部分，就往哪个儿子下传即可（当然，可能没有交点），而另一个儿子的部分，未下传线段优于下传线段，无需下传。 单次修改时间复杂度为 O(log⁡2n)O(\\log^2 n)O(log2n)，查询时直接记录路过的所有线段的答案即可，时间复杂度依然为 O(log⁡n)O(\\log n)O(logn)。 模板题在做的时候先树剖，每次修改拆成两条向上的链。 inline void pushup(int o, int l, int r) // T[o].v 维护区间最小值 T[o].v = min(T[o].v, T[o 1].v, T[o 1 | 1].v); T[o].v = min(T[o].v, calc(T[o].s, dis[idx[l]]), calc(T[o].s, dis[idx[r]]));void update(int o, int l, int r, int x, int y, Seg k) // 加入定义域为 [x, y] 的线段 k int mid = l + r 1; if (x = l r = y) if (calc(k, dis[mid]) calc(T[o].s, dis[idx[mid]])) swap(k, T[o].s); // 中点处 x 当前线段比 k 劣 if (calc(k, dis[idx[l]]) calc(T[o].s, dis[idx[l]])) update(o 1, l, mid, x, y, k); if (calc(k, dis[idx[r]]) calc(T[o].s, dis[idx[r]])) update(o 1 | 1, mid + 1, r, x, y, k); return pushup(o, l, r); if (x = mid) update(o 1, l, mid, x, y, k); if (mid y) update(o 1 | 1, mid + 1, r, x, y, k); pushup(o, l, r); i64 query(int o, int l, int r, int x, int y) if (x = l r = y) return T[o].v; int mid = l + r 1; i64 res = min(calc(T[o].s, dis[idx[max(l, x)]]), calc(T[o].s, dis[idx[min(r, y)]])); if (x = mid) res = min(res, query(o 1, l, mid, x, y)); if (mid y) res = min(res, query(o 1 | 1, mid + 1, r, x, y)); return res; 例题 刷基础 1 [2023 钉耙编程 1] Easy problem I Portal。如果一个数发生过 ai←x−aia_i\\leftarrow x-a_iai​←x−ai​，那么以后就会一直这样。搞两棵线段树分别维护即可。代码。 [Luogu P5278] 算术天才⑨与等差数列 Portal. 发现条件非常严苛，因此可以考虑哈希之类的方法，这里不做赘述。 一段区间可以重排为等差数列，当且仅当满足（d=0d=0d=0 先特判掉）： max⁡−min⁡=d×(len−1)\\max -\\min =d\\times (len-1)max−min=d×(len−1)； gcd⁡i=lr−1(ai+1−ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lr−1​(ai+1​−ai​)=d； 序列中没有重复的元素。 用线段树维护即可。第三条可以使用 set、map 维护一个数最左边的出现位置，然后用线段树维护这个值的最小值，如果这个数小于 lll，那么一定没有重复元素。代码。"},{"title":"平衡树","path":"/wiki/oi-note/2-3.html","content":"平衡树是一种二叉数据结构，满足所谓的“BST 性质”： 空树是 BST； 若 BST 的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值； 若 BST 的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值； BST 的左右子树均为 BST； BST 集合是满足 1、2、3、4 的最小二叉树集。 笔者通常使用 FHQ 来实现平衡树。 例题 刷基础 I [2023 钉耙编程 1] Easy Problem II Portal。维护权值平衡树，找到比 xxx 大、小的分别打标记，打完之后依然满足平衡树的性质。用分块来支持区间操作即可。代码。 刷综合 [Ynoi E2015] 人人本着正义之名 Portal. 首先看一看操作 3∼63\\sim 63∼6 是个什么东西。 将 [l,r−1][l,r-1][l,r−1] 中的数 aia_iai​ 同时变为 aia_iai​ 与 ai+1a_{i+1}ai+1​ 按位或的值？简单，就是所有极长 000 段最右边一个 000 变成 111。 搞一个平衡树，打一个标记表示左右端点的移动量。只有两个问题： 如何保证区间极长？区间染色时向左右拓展一下即可。 如何保证没有空区间？区间数量是 O(n+m)O(n+m)O(n+m) 的，维护最短 01 区间长度，暴力找，然后将其左右区间合并即可。 本质上不难，但代码比较壮观，需要使用指针实现平衡树进行卡常，代码。"},{"title":"扫描线","path":"/wiki/oi-note/2-4.html","content":"对于一个高维空间的坐标限制，我们称之为 BBB 维正交范围问题，我们可以利用扫描线将其降维。也就是说，扫描线维护一维，数据结构维护另一维。 差分处理 如果维护的信息可以差分，那么直接差分掉。比如矩形面积并问题，静态区间内不同数个数问题。将问题转化为矩形操作，然后扫描线维护。 此问题的基础形态是二维数点：平面上有 nnn 个点 (i,ai)(i,a_i)(i,ai​)，每次查询一个矩形内的点的个数。此矩形是一个 4-side 的矩形，可以通过差分的方式将其转化为 3-side，然后再扫描线维护一下变成 2-side，这样就成了一个平凡的单点修改区间查询的问题。 也就是说，差分和扫描线是我们的降维手段，最后一个 2-side 的问题就是平凡的，使用合适的数据结构（区间修改单点查询，单点修改区间查询，区间修改区间查询）维护即可。 这是二维数点的模板，其转化成单点加查询区间和。 矩形面积并 模板。转化成网格图上去做，扫描线扫描矩形的竖线，转化成区间加查询全局 000 的数的个数，因此维护区间最小值（对于全局来说必然是 000）和最小值个数即可，使用动态开点线段树可以很方便地写出来。 #include bits/stdc++.husing namespace std;typedef long long i64; const int N = 1e5 + 5;const int I = 1e9 + 2;int n;int b[N * 2], xs[N * 2];int stot;struct Scanning_Line int x, y, _y, val; Scanning_Line(int x = 0, int y = 0, int _y = 0, int val = 0) : x(x), y(y), _y(_y), val(val) bool operator (const Scanning_Line a) const return x a.x; S[N * 2];// 查区间 0 的数的个数// 区间最小值，区间最小值的个数struct Node int mn, mncnt; Node(int mn = 0, int mncnt = 0) : mn(mn), mncnt(mncnt) friend Node operator+ (const Node a, const Node b) Node c; c.mn = min(a.mn, b.mn); if (a.mn == c.mn) c.mncnt += a.mncnt; if (b.mn == c.mn) c.mncnt += b.mncnt; return c; T[N * 70];int tag[N * 70];int ls[N * 70], rs[N * 70];int tot = 1;inline void maketag(int o, int x) tag[o] += x; T[o].mn += x;inline void pushdown(int o) if (!tag[o]) return; maketag(ls[o], tag[o]); maketag(rs[o], tag[o]); tag[o] = 0;void update(int o, int l, int r, int x, int y, int k) if (x = l r = y) return maketag(o, k); int mid = l + r 1; if (!ls[o]) ls[o] = ++tot; rs[o] = ++tot; T[ls[o]] = Node(T[o].mn, mid - l + 1); T[rs[o]] = Node(T[o].mn, r - mid); tag[o] = 0; else pushdown(o); if (x = mid) update(ls[o], l, mid, x, y, k); if (mid y) update(rs[o], mid + 1, r, x, y, k); T[o] = T[ls[o]] + T[rs[o]];int main(void) ios::sync_with_stdio(0); cin n; for (int i = 1; i = n; ++i) int x, y, _x, _y; cin x y _x _y; --_x, --_y; S[++stot] = Scanning_Line(x, y, _y, 1); S[++stot] = Scanning_Line(_x + 1, y, _y, -1); sort(S + 1, S + stot + 1); for (int i = 1; i = stot; ++i) xs[i] = S[i].x; int m = unique(xs + 1, xs + stot + 1) - (xs + 1); i64 ans = 0; T[1].mncnt = I + 1; for (int i = 1, j = 0; i = m; ++i) if (i 1) ans += 1ll * (xs[i] - xs[i - 1]) * (I + 1 - T[1].mncnt); while (j stot S[j + 1].x == xs[i]) ++j, update(1, 0, I, S[j].y, S[j]._y, S[j].val); cout ans ; return 0; [SDOI2009] HH 的项链 二维扫描线 本质上是莫队，不在本文中介绍。"},{"title":"简单树形问题","path":"/wiki/oi-note/3-1.html","content":"树链剖分 每次跳重链即可完成树上 K 级祖先问题，而且通常比长链剖分快。 树上启发式合并 本质上是枚举每个节点时，直接枚举子树来计算答案的一种暴力。但是由启发式合并，我们可以最后枚举重儿子的信息，然后直接保留，这样就可以在统计父亲答案时不再重新枚举重儿子的信息。 void dfs(int x, bool keep) for (int y : T1.G[x]) if (y != T1.fa[x] y != T1.son[x]) dfs(y, 0); if (T1.son[x]) dfs(T1.son[x], 1); for (int y : T1.G[x]) if (y != T1.fa[x] y != T1.son[x]) for (int i = T1.dfn[y]; i = T1.dfn[y] + T1.sz[y] - 1; ++i) ... for (int i = T1.dfn[y]; i = T1.dfn[y] + T1.sz[y] - 1; ++i) add(T2.dfn[T1.idx[i]], 1); add(T2.dfn[x], 1); if (!keep) for (int i = T1.dfn[x]; i = T1.dfn[x] + T1.sz[x] - 1; ++i) add(T2.dfn[T1.idx[i]], -1); 例题 [北京市赛 2025] 最近公共祖先 Portal. LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。代码。 [Nanjing Regional 2025] Cyan White Tree Portal. 需要在 LCA 处统计信息不难考虑启发式合并。强制令 c≥wc\\ge wc≥w，那么只需要在线段树上查询一个后缀最大值即可。 唯一的问题是在保留重儿子信息时，需要将其加上当前节点的信息。也就是说，区间修改然后平移。但是是全部平移，因此直接在线段树上打 tag 然后记一个偏移量 delta 即可。代码。"},{"title":"树分治","path":"/wiki/oi-note/3-2.html","content":"点分治 例题 [qoj837] Giant Penguin Portal. 图上做这个有点过于恐怖了，先考虑树上。 求一条从某个关键点出发的路径的贡献，那么点分治，一定是某个关键点走到分治中心，然后再从分治中心走到某个点。 抓一棵生成树出来，那么对于每个分治点最多只有 kkk 条边跨越它，经过这些边也可以视作跨越的分治点。因此直接对最多 2k+12k+12k+1 个点为起点跑 BFS 即可，代码。"},{"title":"组合计数","path":"/wiki/oi-note/4-1.html","content":"到处都能见到它的身影，它是一切数数题的基础。 概念基础 基本定义与一些常见公式与方法。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​，有 Anm=n!(n−m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anm​=(n−m)!n!​。 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。置换中形成一个环的称为置换环，对于大小为 1,21,21,2 的置换环，原排列和置换显然是一样的。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 (nm)\\binom n m(mn​)。组合数同时也是二项式系数，当 m0m0m0 时，组合数没有定义。 (nm)=n!(n−m)!m!=nm‾m!(nm)=(n−1m)+(n−1m−1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mn​)=(n−m)!m!n!​=m!nm​​(mn​)=(mn−1​)+(m−1n−1​) 组合数有以下性质 / 恒等式： (nm)=(nn−m)\\dbinom n m = \\dbinom n {n - m}(mn​)=(n−mn​)； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)，常被用来递推组合数； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)； 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1。注意这个东西是很特殊的完整一行，一般的行求和是无法快速计算的。它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 Lucas 定理。若 ppp 是质数，则 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp，常用于 ppp 较小的情况。 组合数奇偶性公式。(nm)≡1(mod2) ⟺ n m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\ \\ m=m(mn​)≡1(mod2)⟺n m=m，使用 Lucas 定理来证明，需保证不出现 (01)\\dbinom{0}{1}(10​)。 Kummer 定理。(n+mn)\\dbinom{n+m}{n}(nn+m​) 中质因子 ppp 的次数为 n+mn+mn+m 在计算时 ppp 进制意义下的进位次数，等价于 (nm)\\dbinom n m(mn​) 中质因子 ppp 的次数等于在计算 n−mn-mn−m 时 ppp 进制意义下的借位次数。其中 ppp 是素数。 上指标翻转。(nk)=(−1)k(k−n−1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(kn​)=(−1)k(kk−n−1​)。 多重组合数。是指先选 n1n_1n1​，再选 n2n_2n2​，以此类推。有（∑ni=n\\sum n_i = n∑ni​=n）： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 组合方法。在小学学过一些常用的组合方法。 捆绑法插空法插板法nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。 经典问题 介绍一些经典问题。 树的拓扑序计数 对于一个 nnn 个点的树，其拓扑序数量为 n!∏szu\\dfrac{n!}{\\prod sz_u}∏szu​n!​。 证明采用归纳法： ans=(n−1szv1,szv2,⋯ ,szvk)∏szvi!∏w∈subtree⁡(vi)szw=(n−1)!szv1!szv2!⋯szvk!×∏szvi!×n∏szu=n!∏szu\\begin{aligned} ans=\\binom{n-1}{sz_{v_1},sz_{v_2},\\cdots,sz_{v_k}}\\prod \\frac{sz_{v_i}!}{\\prod_{w\\in \\operatorname{subtree}(v_i)}sz_w}\\\\ =\\frac{(n-1)!}{sz_{v_1}!sz_{v_2}!\\cdots sz_{v_k}!}\\times \\prod sz_{v_i}! \\times \\frac{n}{\\prod sz_u}\\\\ =\\dfrac{n!}{\\prod sz_u} \\end{aligned} ans​=(szv1​​,szv2​​,⋯,szvk​​n−1​)∏∏w∈subtree(vi​)​szw​szvi​​!​=szv1​​!szv2​​!⋯szvk​​!(n−1)!​×∏szvi​​!×∏szu​n​=∏szu​n!​​ 常见计数数列 错排数 指 pi≠ip_i e ipi​=i 的排列个数，有 fn=(n−1)(fn−1+fn−2)f_n=(n-1)(f_{n-1}+f_{n-2})fn​=(n−1)(fn−1​+fn−2​)。因为我们要用恰好一次操作将 nnn 放进错位排列里，因此只有这两种转移。"},{"title":"容斥原理","path":"/wiki/oi-note/4-2.html","content":"概述 容斥原理是非常重要的计数原理： ∣⋃i=1nSi∣=∑m=1n(−1)m−1∑aiai+1∣⋂i=1mSai∣\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_ia_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| ​i=1⋃n​Si​​=m=1∑n​(−1)m−1ai​ai+1​∑​​i=1⋂m​Sai​​​ 集合的交集可以使用补集容斥原理来求解： ∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| ​i=1⋂n​Si​​=∣U∣−​i=1⋃n​Si​​​ 容斥原理最经典的用处是“至少”与“恰好”之间的转化，实际上是一个子集反演的过程。子集反演是针对集合交并的容斥，可以在恰好是某个集合和至多/至少是这个集合反演。 我们先来看与至多是这个集合的反演。现在有其元素满足某种条件的集合 AAA。定义 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 代表 S⊆AS\\subseteq AS⊆A 时的答案。 钦定选了 SSS 这个集合中的子集 TTT，有 g(S)=∑T⊆Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=∑T⊆S​f(T)，这时有 f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=∑T⊆S​(−1)∣S∣−∣T∣g(T)。使用容斥原理不难感性理解。 类似的，如果 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 表示 A⊆SA\\subseteq SA⊆S 时的答案，有 g(S)=∑S⊆Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=∑S⊆T​f(T)，反演得 f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=∑S⊆T​(−1)∣T∣−∣S∣g(T)。 这是容斥原理的代数形式，它是我们用容斥原理解决问题的基础。因为在钦定时，一个“有两个元素满足条件”的东西会在“至少有一个元素满足条件”的东西计算时计算两次，也就因此成了一个子集反演的形式。"},{"title":"图的相关概念","path":"/wiki/oi-note/5-1.html","content":"一张图 GGG 由点集 VVV 和边集 EEE 构成。我们用 d(v)d(v)d(v) 代表节点 vvv 的度数，如果 d(v)=∣V∣−1d(v)=|V|-1d(v)=∣V∣−1，则称 vvv 为支配点。如果每个点的度数都是 kkk，则该图为 k−k-k−正则图。 子图 对一张图 G=(V,E)G = (V, E)G=(V,E)，若存在另一张图 H=(V′,E′)H = (V, E)H=(V′,E′) 满足 V′⊆VV \\subseteq VV′⊆V 且 E′⊆EE \\subseteq EE′⊆E，则称 HHH 是 GGG 的子图，记作 H⊆GH \\subseteq GH⊆G。 若对 H⊆GH \\subseteq GH⊆G，满足 ∀u,v∈V′\\forall u, v \\in V∀u,v∈V′，只要 (u,v)∈E(u, v) \\in E(u,v)∈E，均有 (u,v)∈E′(u, v) \\in E(u,v)∈E′，则称 HHH 是 GGG 的导出子图。点集为 V′(V′⊆V)V(V \\subseteq V)V′(V′⊆V) 的导出子图称为 V′VV′ 导出的子图，记作 G[V′]G \\left[ V \\right]G[V′]。 若 H⊆GH \\subseteq GH⊆G 满足 V′=VV = VV′=V，则称 HHH 为 GGG 的生成子图/支撑子图。 如果一张无向图 GGG 的某个生成子图 FFF 为 k−k-k−正则图，则称 FFF 为 GGG 的一个 k−k-k−因子。 如果有向图 G=(V,E)G = (V, E)G=(V,E) 的导出子图 H=G[V∗]H = G \\left[ V^\\ast \\right]H=G[V∗] 满足 ∀v∈V∗,(v,u)∈E\\forall v \\in V^\\ast, (v, u) \\in E∀v∈V∗,(v,u)∈E，有 u∈V∗u \\in V^\\astu∈V∗，则称 HHH 为 GGG 的一个闭合子图。也就是说，图内部是闭合的，不存在一个点在导出子图内，可以通过原图的一条边连到一个不在导出子图内的点。 特殊的图 对于无向简单图，所有本来在图上的边都不在，本来不在的都在，那么这个图就是原无向图的补图。 对于有向图，每条边的方向取反，得到的图就是原图的反图。 特殊集合 一些特殊的点和边的集合有着特殊的意义，这里我们介绍一些常见的。 支配集 对于无向图，如果一个点集的点可以连接到原图的所有点，那么这个点集为原图的支配集。 最小支配集是 NPH 的，我们通常使用 O(2n)O(2^n)O(2n) 的枚举算法来求解支配集。 独立集 就是任意两点不相邻的点集。对于树和二分图我们有高效做法，但是一般图上，这个问题是 NPH 的。 匹配 对于图 G=(V,E)G=(V,E)G=(V,E)，若 E′∈EE\\in EE′∈E 且 E′EE′ 中任意两条边都没有公共端点，且 E′EE′ 中没有自环，那么 E′EE′ 是 GGG 的一个匹配，也称为边独立集。如果一个点被匹配的边连接了，那么它就是被匹配的，否则就是不被匹配的。 边数最多的称为最大匹配，如果边带权，那么权重之和最大的匹配称为图的最大权匹配。 如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配就是极大匹配，最大匹配一定是极大匹配。 如果所有点都被匹配了，那么这个匹配是完美匹配。如果在一个匹配中只有一个点不被匹配，那么该匹配为准完美匹配。 对于一个匹配 MMM，若一条路径以非匹配点为起点，每相邻两条边中的一条在匹配中而另一条不在匹配中，那么这条路径称为交替路径；一条非匹配点终止的交替路径称为增广路径。 点覆盖 如果所有边都至少有一个端点在这个点集中，那么这个点集被称为点覆盖集。 点覆盖集一定是支配集，但是极小点覆盖集不一定是极小支配集（考虑一个三元环）。 点覆盖集拥有以下性质： 一个点集是点覆盖的充要条件是其补集是独立集。 一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。 边覆盖 当前边集满足任何一个点都至少是其中一条边的一个端点，那么这个边集称为边覆盖集。 如果知道了最大匹配，那么将所有非匹配点都连一条边加入最大匹配，那么就得到了一个最小边覆盖。同理，如果知道了最小边覆盖，那么将有公共点的边删去到只剩一条就得到了最大匹配。 团 一个图的子点集 V′VV′ 中任意两个不同的顶点都相邻，则称 V′VV′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 显然地，最大团等于补图的最大独立集。 求解一个图的最大团是 NPH 的，可以使用最大团搜索算法（在暴力枚举的基础上加一个不可能成为答案的最优性剪枝）来解决规模较小的图的问题。 例题 你可能会问：这里为什么有题呢？嗯，主要是建立在图结构上的一些奇奇怪怪的问题。 刷基础 I [3rd ucup s8] Challenge Matrix Multiplication Portal。考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。代码。 [CF1810E] Monsters Portal. 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。代码。"},{"title":"生成树问题","path":"/wiki/oi-note/5-2.html","content":"例题 刷基础 [4th ucup s1] Yet Another MST Problem Portal. 仿照 Kruskal 算法的流程，按照边权从小到大考虑，找不存在 mexmexmex 的区间，将它们合并。注意到合并后得到的新区间可以视作两区间的交集，因此直接做即可。代码。"},{"title":"连通性问题","path":"/wiki/oi-note/5-3.html","content":"有向图的强连通性 例题 [ICPC 2024 Hangzhou] Fuzzy Ranking Portal. 每个排序关系依次连边，然后 SCC 缩点，一个点对在同一个 SCC 里视作合法的。 然后如何查询？不难猜测 SCC 编号一定是形如一段一段的连续段，没有属于同一个 SCC 却是断开的。使用反证法，假定存在一个排名其 SCC 编号依次是 1 2 2 1，那么对于四个学校来说，有 1 2 3 4（初始的），根据这个信息有 2 3, 1 4，但是 1 4 3 2，说明 222 和 444 在一个 SCC 里，矛盾。 因此直接做即可。代码。"},{"title":"最短路问题","path":"/wiki/oi-note/5-4.html","content":"概述 对于无权图（01 带权），可以使用 BFS 求解最短路。 对于多源最短路，可以使用 Floyd 算法，也就是通过 nnn 轮 DP 来求解最短路。 对于单源最短路，可以使用 Dijkstra 和 SPFA。Dijkstra 基于贪心的思想，每次寻找当前最短的路来走，正确性基于边权非负；SPFA 则通过 O(nm)O(nm)O(nm) 的迭代来更新最短路，进而可以判断负环的存在性。 Johnson 通过将边改造为 (u,v,w+du−dv)(u,v,w+d_u-d_v)(u,v,w+du​−dv​) 来实现，边权是三角形不等式来满足 ≥0\\ge 0≥0，建立超级源点跑 SPFA 即可。 #include bits/stdc++.husing namespace std; typedef long long i64; const int N = 3e3 + 5; const int INF = 1e9; int n, m, cnt[N]; vectorpairint, i64 G[N]; i64 d[N], h[N]; bool vis[N], inq[N]; void Dijkstra(int s) fill(d, d + n + 1, INF); memset(vis, 0, sizeof vis); #define pil pairint, i64 priority_queuepil, vectorpil, greaterpil q; q.emplace(d[s] = 0, s); while (!q.empty()) int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto [v, w] : G[u]) if (d[v] d[u] + w) q.emplace(d[v] = d[u] + w, v); void SPFA(int s) fill(d, d + n + 1, INF); d[s] = 0; queueint q; q.push(s); inq[s] = 1; while (!q.empty()) int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] d[u] + w) d[v] = d[u] + w; cnt[v] = cnt[u] + 1; if (cnt[v] n + 1) cout -1 , exit(0); if (!inq[v]) q.push(v), inq[v] = 1; int main(void) ios::sync_with_stdio(0); cin n m; while (m--) int u, v, w; cin u v w; G[u].emplace_back(v, w); for (int i = 1; i = n; ++i) G[0].emplace_back(i, 0); SPFA(0); for (int u = 1; u = n; h[u] = d[u], ++u) for (auto [v, w] : G[u]) w += d[u] - d[v]; for (int i = 1; i = n; ++i) Dijkstra(i); i64 ans = 0; for (int j = 1; j = n; ++j) if (d[j] == INF) ans += 1ll * j * INF; else ans += j * (d[j] + h[j] - h[i]); cout ans ; return 0; 如果我们要求的是最短简单路径（有负环），那么它是一个 NPC 问题。 差分约束 根据三角形不等式进行连边，然后用 SPFA 判断负环。 值得注意的是，如果使用 SPFA 求最短路，那么得到的是字典序最大的解。对于字典序最小的解，只需要将约束条件统统变为 xi−xj≥yx_i-x_j\\ge yxi​−xj​≥y，然后跑最长路，有正环时无解（就是边的方向和权值都取反）。 [省选联考 2021 A 卷] 矩阵游戏。答案的构造是容易的，然后需要调整这个答案，让每一行和列依次 +1,−1+1,-1+1,−1，然后错开，直接差分约束即可。代码。 斯坦纳树 如果给定 nnn 个点，试求连接此 nnn 个点，总长最短的直线段连接系统，并且并且任意两点都可以通过系统中的直线段组成的折线连接起来，此问题被称为斯坦纳树问题。遗憾的是，这是一个 NPH 问题。 最小斯坦纳树。给定一个 nnn 个点 mmm 条边无向图 G=(V,E)G=(V,E)G=(V,E)，再给定包含 kkk 个节点的点集 SSS，选出 GGG 的连通子图 G′=(V′,E′)G=(V,E)G′=(V′,E′)，要求：S⊆V′S \\subseteq VS⊆V′，E′EE′ 中所有边的权值和最小。你需要求出这个最小权值和，n≤100,m≤500,k≤10n\\le 100,m\\le 500,k\\le 10n≤100,m≤500,k≤10。 并不是直接将 SSS 连接起来就是最小的，可能需要借助剩下的 n−kn-kn−k 个点。这种问题可以使用状压 DP 来解决： 设 f(i,S)f(i,S)f(i,S) 表示以 iii 为根的一棵树，包含集合 SSS 中所有点的最小边权值和。有转移：f(i,S)←min⁡{f(i,T)+f(i,S−T)},f(i,S)←min⁡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)←min{f(i,T)+f(i,S−T)},f(i,S)←min{f(j,S)+w(i,j)}。前者可以使用子集 DP 实现，后者可以跑一个最短路（由于图很难特殊构造而且规模很小，所以实际上更建议 SPFA）。代码。 Peach Blossom Spring，注意并不要求完全联通，最后子集和并一下即可。 平面图最小割 如果图 GGG 能画在平面 SSS 上，即除顶点处外无边相交，则称 GGG 可平面嵌入 SSS，GGG 为可平面图或平面图。画出的没有边相交的图称为 GGG 的平面表示或平面嵌入。 平面图可以转为对偶图，对偶图的最短路等于原平面图的最小割。给 GGG 的每个面搞一个点，两个面的公共边可以确定一条与其方向垂直的边。给源点和汇点连线可以将原图分成两个部分，跑最短路即可。 注意左侧和下侧，上侧和右侧分别是同一个点，从右上到左下的最短路即为左上到右下的最小割。模板，代码。 同余最短路 模板。这是一个最短路的变式问题。可以用于求解在某个范围内有多少重量可以由若干物品的完全背包凑出，就是多少数值可以由一些给定的数 bib_ibi​ 由 ∑aibi(ai≥0)\\sum a_i b_i(a_i\\ge 0)∑ai​bi​(ai​≥0) 得到。 我们可以发现，如果 xxx 可以被表示出，那么 x+kai(k0)x+ka_i(k0)x+kai​(k0) 就可以被表示出。因此我们找一个最小的 a1a_1a1​，然后连 j→(j+ai) mod a1j\\rightarrow (j+a_i)\\bmod a_1j→(j+ai​)moda1​ 的长度为 aia_iai​ 的边，然后我们从 000 开始跑最短路。由于这里图的形态不太能特殊构造，因此使用 SPFA 往往会跑的更快。最后求出的 fif_ifi​ 代表最小的能被凑出的数，满足 fi mod a1=if_i\\bmod a_1 =ifi​moda1​=i。代码。 答案的求解十分容易。[0,r][0,r][0,r] 的答案数量为： ∑i=0a1−1max⁡{0,⌊r−fia1⌋+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-f_i}{a_1}\\right\\rfloor+1\\right\\} i=0∑a1​−1​max{0,⌊a1​r−fi​​⌋+1} 但为什么要使用最短路呢？实际上这东西是体积模 mmm 意义下的完全背包，如果重复经过一个点，那么可以选择 mgcd⁡(vi,m)−1\\frac{m}{\\gcd(v_i,m)}-1gcd(vi​,m)m​−1 个这类物品。也就是说，会在大小为 mmm 的环上形成 gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m) 个子环。 那么在每个子环上转两圈即可统计到所有转移，时间复杂度 O(nm)O(nm)O(nm)。代码。 [THUPC 2023] 背包。完全背包，但是 V≥1011V\\ge 10^{11}V≥1011。 如果我们将密度最大的物品选做基准物品，那么其它物品的选择可以替换为若干基准物品，这样可以最大化贡献。设基准物品体积为 www，贡献为 mmm。 设 fif_ifi​ 代表最大的贡献，满足 V mod m=iV\\bmod m=iVmodm=i。最终权值为 fi+V−V′mwf_i+\\frac{V-V}{m}wfi​+mV−V′​w，因此要最大化 V−V′mV-\\frac{V}{m}V−mV′​，因此贡献应该是 fp+ci−p+vimwf_p+c_i-\\frac{p+v_i}{m}wfp​+ci​−mp+vi​​w。 可以发现每个 fif_ifi​ 对应的物品个数一定是不超过 vvv 的，因此这一部分总容积不超过 v2≤Vv^2\\le Vv2≤V，不存在误判成有解的情况。代码。 删边最短路 模板。给定一张带权无向图，每个询问独立，将一条边的边权改变，询问当前 1∼n1\\sim n1∼n 的最短路。 求出 1,n1,n1,n 的最短路树 T1,TnT_1,T_nT1​,Tn​。如果改的边不是最短路上的边的答案是好算的，否则，我们要算出强制不经过一条边的新的最短路。 我们可以证明，一定可以枚举一条边 (u,v)(u,v)(u,v)，然后 1→u,v→n1\\rightarrow u,v\\rightarrow n1→u,v→n 走的都是最短路。 我们需要保证 T1,TnT_1,T_nT1​,Tn​ 上 1∼n1\\sim n1∼n 的最短路是相同的一条，否则无法计算。 求出 p1ip1_ip1i​ 代表 T1(1→i)T_1(1\\rightarrow i)T1​(1→i) 与更新路径的最后一个交点（在最短路树上跳，第一个到的最短路上的点，就是 iii 与 nnn 的 LCA），pnipn_ipni​ 同理。 这样维护先修改再单点查询的区间 ckmin 即可。代码。 显然，这种做法并不能在有向图上成立，因为不在最短路上的边可能不止一条。但是，走的路径依然满足中间只有一段不在最短路上的路径。 k 短路 先建出一棵以 ttt 为根的最短路树 TTT，xxx 到 ttt 的最短路径为 dxd_xdx​。设 s→ts\\rightarrow ts→t 的路径上不在 TTT 中的当前选择的路径的边集为 P′PP′，s→ts\\rightarrow ts→t 上的所有边为 PPP，那么满足： 将一条边 eee 的代价定义为 Δe=w−(du−dv)\\Delta e = w-(d_u-d_v)Δe=w−(du​−dv​)，那么 LP′=ds+∑e∈P′ΔeL_{P} = d_s + \\sum_{e\\in P} \\Delta eLP′​=ds​+∑e∈P′​Δe； 将 PPP 和 P′PP′ 中所有边按照 s→ts\\rightarrow ts→t 经过的顺序依次排列，那么对于 P′PP′ 中相邻的边 e1,e2e_1,e_2e1​,e2​，那么 ve1=ue2v_{e_1}=u_{e_2}ve1​​=ue2​​ 或者 ue2u_{e_2}ue2​​ 是 ve1v_{e_1}ve1​​ 在 TTT 上的祖先。 对于每一个合法的 P′PP′，有且仅有一个 PPP 与之对应。因为可以根据 P′PP′ 还原在 TTT 上选择了什么。 也就是说，我们现在要求满足性质 222 的第 kkk 小 LpL_pLp​。 我们记录最后一条边和当前 LpL_pLp​ 的值即可表示 P′PP′。初始我们将 111 所有在 TTT 上的祖先的所有的边中 Δe\\Delta eΔe 最小的一条边加入小根堆，然后扩展时只有两种选择： 删掉 P′PP′ 结尾的那条边，换成第二大的边； 从 P′PP′ 的结尾开始到 TTT 的路径上，选择最小的边加入。 已知我们开始的描述路径的方式是不漏的，而且我们相当于枚举了所有的待替换边是否进行替换，因此这么做是正确的。 时间复杂度 O(mlog⁡m+klog⁡k)O(m\\log m+k\\log k)O(mlogm+klogk)，模板，代码。 kkk 短路问题能够高效解决，得益于我们只需要一个点即可描述能够被替换的边，如果要输出 kkk 短路的方案，那么就只能做到 O(k(n+m)log⁡m+klog⁡k)O(k(n+m)\\log m+k\\log k)O(k(n+m)logm+klogk) 了。 例题 刷基础 I [Shenyang Regional 2025] The Bond Beyond Time Portal。x,yx,yx,y 不相邻是容易解决的。相邻时需要将两个点引到一个环上转圈，因此需要求最小环。数据范围很小，因此直接暴力删边求最短路以求最小环即可。代码。 [ZJCPC2025] Challenge NPC III Portal。相当于与是同色点之间的最短路应该大于 kkk，于是对每个颜色都跑多起点最短路，在反图上也跑一遍，就可以求出距离，需要记录次短路防止起点终点相同。代码。 刷综合 [THUSCH2017] 巧克力 Portal. 如果颜色数比较少的话直接用斯坦纳树做，但是颜色数很多，钦定的可能也很多。 kkk 很小，因此考虑将所有颜色随机映射到 [0,k)[0,k)[0,k)，然后求最小斯坦纳树即可求出最小的巧克力个数 www。这 kkk 个点被分配到不同的颜色时答案合法，正确概率是 k!/kkk!/k^kk!/kk。随机化做 200200200 次即可。 然后二分出中位数，将小于等于二分值的权值都设为 inf−1inf-1inf−1，大于的都设为 inf+1inf+1inf+1，然后最小斯坦纳树要 ≤w×inf\\le w\\times inf≤w×inf（infinfinf 设置为一个不会影响斯坦纳树选择的巧克力数的一个数即可）。代码。"},{"title":"状态设计","path":"/wiki/oi-note/6-1.html","content":"动态规划是 OI 最重要的部分之一。从学习与做题的角度来说，主要分为设计状态与优化两部分。其中前者更多的是做题和总结方法与套路，甚至需要一定的灵感；而后者相对吃经验。 值得注意的是，很多题目都要求我们在设计算法以前先将题目进行一定的转化，从而将一个不熟悉的模型转化为我们更容易把握的模型。这一点在动态规划的题目中体现的尤为明显。 在阅读本文之前，你应该对动态规划有基本的了解。 线性 DP 在线性结构上枚举每一维度进行转移的 DP。 [CF1810G] The Maximum Prefix。较复杂，见原题面。 直接做怎么做？设 fi,j,kf_{i,j,k}fi,j,k​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后枚举填什么刷表转移对于每个状态是 O(1)O(1)O(1) 的，虽然能做，但是状态数炸了。 需要合并无效状态。同时记录前缀和和最大前缀和有些冗余，从这里入手。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响，这时可以直接确定排除掉这段后缀的前缀的答案，也就是题目所求。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案，答案是 fi,0f_{i,0}fi,0​。那么转移： 如果 j0j0j0，可以以 pip_ipi​ 的系数（第 i+1i+1i+1 位填 111）转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数（第 i+1i+1i+1 位填 −1-1−1）转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 如果 j=0j=0j=0，那么第 i+1i+1i+1 位一定是 −1-1−1，此时可以转移到 fi+1,0f_{i+1,0}fi+1,0​ 和 fi+1,1f_{i+1,1}fi+1,1​。 代码。 背包 基本模型：01 背包、完全背包、多重背包、分组背包、方案数背包的撤回（将转移的东西减去即可）。 [十二省联考 2019] 皮配。机械大师有 ccc 个工具箱，nnn 个螺丝，每个螺丝都有自己的质量，需要将螺丝设定为普通螺钉/自攻螺钉、三角螺纹/方螺纹。一个工具箱里的螺丝必须都是普通螺钉，或者都是自攻螺钉。要求 普通/自攻/三角/方 的螺丝总质量不超过 C0,C1,D0,D1C_0,C_1,D_0,D_1C0​,C1​,D0​,D1​。有 KKK 个螺丝不可以被设定成某种螺丝（如不能设定为三角自攻）。问有多少种方案，对 998244353998244353998244353 取模。n,c≤103,K≤30n,c\\le 10^3,K\\le 30n,c≤103,K≤30。 为方便分析时间复杂度，记 M=max⁡{C,D}M=\\max\\{C,D\\}M=max{C,D}。 考虑 K=0K=0K=0 怎么做。分别考虑划分两种特征，两次背包分别对工具箱和螺丝进行 DP 即可。 发现 KKK 很小，考虑针对它设计状态。对于不是这 KKK 个没事找事的螺丝，前面的 DP 做法依然成立。然后再考虑这些没事找事的。 设 F(i,j,k)F(i,j,k)F(i,j,k) 代表考虑前 iii 个工具箱，普通螺钉的重量为 jjj，三角螺纹的重量为 kkk。需要枚举当前的选的东西是什么和上一个东西是什么。滚掉 iii 这一维，所有状态都是可以转移的，考虑用这种方式处理没事找事的螺丝，时间复杂度为 O(k2wM)O(k^2 w M)O(k2wM)。 然后枚举体积，进行背包合并即可。代码。 区间 DP 图上 DP 一般的图上 DP 建立在 DAG 结构上。 树上背包 * [福建省队集训 2019] 最大权独立集问题 Portal. 好题！如果你之前没怎么学明白，这道题能让你对树形背包的理解加深不少。 删点相当于什么？当前这个点的信息会走到与它连接的未被删去的点，也就是给边定向。那么不难发现问题相当于给边定向，然后每个点的权值是 ai×∣i能到达的点的个数∣a_i\\times |i 能到达的点的个数|ai​×∣i能到达的点的个数∣。 因此设 fx,if_{x,i}fx,i​ 代表连 fax→xfa_x \\to xfax​→x，xxx 可到达子树内（含本身）的 iii 个点（它不会到达子树外面的点）；gx,ig_{x,i}gx,i​ 代表连 x→faxx\\to fa_xx→fax​，xxx 可到达子树外的 iii 个点（在转移时，它的父亲不会关心它能到达子树中的几个点）。 现在考虑计算 xxx 点的答案。比如说要算 ggg，能根据其孩子的 ggg 信息来确定吗？不太方便，因为孩子的 ggg 和当前 xxx 选择了多少个孩子的 fff 是有关的。不一定不能做，总之不太方便。 本身 xxx 点还是要计算贡献的，因此我们不妨直接钦定其能走到树上的 jjj 个节点，然后关系到这个信息填进哪个 f,gf,gf,g 值，因此设 hi,jh_{i,j}hi,j​ 代表走到 iii 个子树内的点，总共能走到 jjj 个点的代价。算出 hhh 数组后不难求出 fx,gxf_x,g_xfx​,gx​。转移就不难了。 qoj14416 只是把 min⁡\\minmin 改成 max⁡\\maxmax，代码。 父亲向子树转移 [Nanjing Regional 2024] Topology Portal. 设状态为考虑子树内的信息是很奇怪的事情，因为你不知道外部的拓扑序是怎么排的。 因此设 fx,if_{x,i}fx,i​ 代表删除 xxx 子树内的所有节点（不含 xxx）之后，使得 xxx 的拓扑序为 iii 的拓扑序个数。转移的时候从父亲转移到儿子，每次考虑除了 yyy 以外 xxx 的所有儿子。代码。 换根 DP 如果我们需要对所有点都当作根进行一次树形 DP，那么我们可以使用换根 DP 来处理。 [AMPPZ 2023] Routing K-Codes Portal. 不难观察出只有二叉树是有答案的。其实就是根节点一定填 111（填 000 则删掉这个点），然后左右儿子一个填 2i2i2i 另一个填 2i+12i+12i+1，树形 DP 可以完成。 由于转移途中不止有加减法而且 DP 数组不止一个，换根可能很麻烦。推荐一种非常美观的换根写法：在第二次 DFS 时记录一个 Node 类型代表父亲的答案。重载 Node 类型的加法即可很方便的完成换根。 代码。 例题 [Jinan Regional 2024] DFS Order 2 Portal. 还是只能考虑父亲向子树转移，fx,if_{x,i}fx,i​ 表示 xxx 节点在 DFS 序中的 iii 号位置，然后转移到孩子。考虑在转到儿子之前，应该先遍历了一些其它儿子，然后再遍历完目标儿子之后再回来遍历其它孩子，是一个树形背包的形式，然后要乘上一些阶乘。 写起来挺爽。 代码。 状压 DP 与轮廓线 DP 动态 DP 其它 DP 一些杂项内容 插入法 数位 DP 一般的数位 DP 直接采用记忆化搜索实现即可。 手机号码，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64;int num[15];int f[11][11][11][2][2][2];i64 dp(int p, int p1, int p2, bool unlim, bool d, bool _4, bool _8) if (_4 _8) return 0; if (p == 0) return d; if (unlim f[p][p1][p2][d][_4][_8] != -1) return f[p][p1][p2][d][_4][_8]; i64 res = 0; int mx = unlim ? 9 : num[p]; for (int i = 0; i = mx; ++i) res += dp(p - 1, i, p1, unlim || (i mx), d || (i == p1 i == p2), _4 || (i == 4), _8 || (i == 8)); if (unlim) f[p][p1][p2][d][_4][_8] = res; return res;i64 calc(i64 n) memset(f, 0xff, sizeof f); for (int i = 1; i = 11; ++i, n /= 10) num[i] = n % 10; i64 res = 0; for (int i = 1; i = num[11]; ++i) res += dp(10, i, -1, i num[11], 0, i == 4, i == 8); return res;int main(void) i64 l, r; cin l r; cout calc(r) - calc(l - 1) ; return 0; 例题 刷基础 1 只有 NOIP 难度。 [CSP-S 2024] 染色 Portal. 设 fif_ifi​ 代表考虑前 iii 位的答案。只有 lstailst_{a_i}lstai​​ 可以与 aia_iai​ 匹配，如果要匹配，中间一大段都要染成同一个颜色，计算这一段有多少贡献，从 flstai+1f_{lst_{a_i} + 1}flstai​​+1​ 转移过来。 记录前缀某一段的贡献即可快速计算任意一段有多少贡献。代码。 [2023 钉耙编程 1] Mr. Liang play Card Game Portal。很有合并的感觉！考虑区间 DP，最后你会将区间合到只剩一张牌，于是设一个四维状态就可以直接转移。代码。 刷提升 1 比较有趣。 [Ptz 2020 Summer Day4] Ternary String Counting Portal. O(n4)O(n^4)O(n4) 直接 fi,x,y,zf_{i,x,y,z}fi,x,y,z​ 记录每一个字符出现的位置，O(n3)O(n^3)O(n3) 记录前两个不同字符的出现位置。都需要前缀和优化。 状态数还是过多了，我们需要寻找一个方式简化。先把转移写出来（对于状态 f(i,j,k)f(i,j,k)f(i,j,k)，表示当前考虑到第 iii 位，与这一位不同的数字上一次出现的位置分别位 j,kj,kj,k，并且 jkjkjk）： f(i+1,i,k)←+f(i,j,k)f(i+1,i,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,k)←+f(i,j,k)； f(i+1,i,j)←+f(i,j,k)f(i+1,i,j)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,j)←+f(i,j,k)； f(i+1,j,k)←+f(i,j,k)f(i+1,j,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,j,k)←+f(i,j,k)。 再考虑题目中的限制，实际上就是限制了 dp 过程中 jjj 和 kkk 的取值范围： x=1x=1x=1，则 jljljl； x=2x=2x=2，则 j≥l,klj\\ge l,klj≥l,kl； x=3x=3x=3，则 k≥lk\\ge lk≥l。 考虑优化，看上去第一维什么都不是！将转移分为 iii​ 层，每一层的状态只能从上一层转移过来，第三个转移就是直接从上一层的对应点转移，第一二个转移是对上一层的一列和一行求和。 等价于，每次给出一个矩形，先把矩形外的值全部清零。然后还可以发现，一旦某个值被清零，那么这个值以后永远都是零。并且对于某一行来说，非零的值永远是一段连续区间，而且其位置是单调的。 双指针扫，不重复清零某个行即可。最终时间复杂度 O(n2+m)O(n^2+m)O(n2+m)。代码。"},{"title":"转移优化","path":"/wiki/oi-note/6-2.html","content":"一般用 tD / eD 描述动态规划的规模，即有 O(nt)O(n^t)O(nt) 个状态，每个状态通过 O(ne)O(n^e)O(ne) 个子问题推出答案。 wqs 二分 决策单调性 我们首先介绍四边形不等式。假设要求解最小值，如果有转移 fj←fi+w(i,j)f_j\\leftarrow f_i+w(i,j)fj​←fi​+w(i,j)，且 www 满足四边形不等式，即若 abcdabcdabcd，则 w(a,d)+w(b,c)≥w(a,c)+w(b,d)w(a,d)+w(b,c)\\ge w(a,c)+w(b,d)w(a,d)+w(b,c)≥w(a,c)+w(b,d)，则具有决策单调性：随着 iii 的增大，转移点 pip_ipi​ 不降。 证明 采用反证法，存在 pjpiijp_jp_iijpj​pi​ij，那么： fpi+w(pi,i)≤fpj+w(pj,i)fpj+w(pj,j)≤fpi+w(pi,j)f_{p_i}+w(p_i,i)\\le f_{p_j}+w(p_j,i)\\\\ f_{p_j}+w(p_j,j)\\le f_{p_i}+w(p_i,j)\\\\ fpi​​+w(pi​,i)≤fpj​​+w(pj​,i)fpj​​+w(pj​,j)≤fpi​​+w(pi​,j) 因此得到 w(pi,i)+w(pj,j)≤w(pj,i)+w(pi,j)w(p_i,i)+w(p_j,j)\\le w(p_j,i)+w(p_i,j)w(pi​,i)+w(pj​,j)≤w(pj​,i)+w(pi​,j)，不满足四边形不等式。如果相等，说明两个不等式都是等式，pjp_jpj​ 也可以转移到 iii，那么 pip_ipi​ 不成立。 分治处理 直接套用分治可以 O(nlog⁡n)O(n\\log n)O(nlogn) 完成一层的转移，只要 www 可以直接计算或者增量计算即可。 [PtzS2020-6] Rhythm Game Portal. 设 fi,jf_{i,j}fi,j​ 代表前 iii 个音符敲击 jjj 个？这样转移就需要枚举连续敲击之类的，不太方便。改为漏了 jjj 个，还是不太方便，因此强制钦定第 jjj 个漏了，这样可以在 n+1n+1n+1 算答案，正好统计最后的 PPP。 转移就是 fi,j←fk,j−1+w(k+1,i−1)f_{i,j}\\leftarrow f_{k,j-1}+w(k+1,i-1)fi,j​←fk,j−1​+w(k+1,i−1)，www 满足四边形不等式，证明容易做差得到。 值得注意的是，当 ijijij 时，w(i,j)w(i,j)w(i,j) 是不满足四边形不等式的，但是转移的时候却会出现这种情况，因此要把 fi,dep←fi−1,dep−1f_{i,dep}\\leftarrow f_{i - 1, dep -1}fi,dep​←fi−1,dep−1​ 的转移单独拉出来。代码。 斜率优化 数据结构优化"},{"title":"前置知识","path":"/wiki/oi-note/7-1.html","content":"我们记字符集为 Σ\\SigmaΣ，字符串是由若干字符集中的元素构成的序列。 字符串哈希 即序列哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 inline u64 q(u64 *f, int l, int r) return f[r] - f[l - 1] * p[r - l + 1]; 最小表示法 模板，目的是求一个循环同构的字符串的最小字典序。 #include bits/stdc++.husing namespace std;const int N = 1e7 + 5;int n;char a[N];int getmin(void) int i = 0, j = 1; while (i n j n) int k = 0; while (k n a[(i + k) % n] == a[(j + k) % n]) ++k; if (a[(i + k) % n] a[(j + k) % n]) i += k + 1; else j += k + 1; if (i == j) ++i; return min(i, j);int main(void) ios::sync_with_stdio(0); cin.tie(0); cin n a; int v = getmin(); for (int i = 0; i n; ++i) cout a[(i + v) % n]; cout ; return 0;"},{"title":"多项式乘法","path":"/wiki/oi-note/8-1.html","content":"假定你拥有高中数学基础。 复数 复数的三角形式可以表示为 a=r(cos⁡θ+isin⁡θ)a=r(\\cos\\theta + i\\sin \\theta)a=r(cosθ+isinθ)。 那么假定 a=r1(cos⁡α+isin⁡α),b=r2(cos⁡β+isin⁡β)a=r_1(\\cos\\alpha + i\\sin \\alpha),b=r_2(\\cos\\beta + i\\sin\\beta)a=r1​(cosα+isinα),b=r2​(cosβ+isinβ)，有 ab=r1r2(cos⁡αcos⁡β−sin⁡αsin⁡β+icos⁡αsin⁡β+icos⁡βsin⁡α)=r1r2(cos⁡(α+β)+isin⁡(α+β))ab=r_1 r_2(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta + i\\cos\\alpha\\sin\\beta + i\\cos\\beta\\sin\\alpha)=r_1r_2(\\cos(\\alpha + \\beta)+i\\sin(\\alpha+\\beta))ab=r1​r2​(cosαcosβ−sinαsinβ+icosαsinβ+icosβsinα)=r1​r2​(cos(α+β)+isin(α+β))，也就是说，模长相乘，辐角相加，即棣莫弗定理。 由复数的三角形式，我们画一个单位圆，以 (1,0)(1,0)(1,0) 为起点，在圆上等间距画出 nnn 个点，这样得到的 nnn 个复数便是 nnn 次单位根，转到的第一个记作 ωn\\omega_nωn​，有 ωnn=1\\omega_n^n =1ωnn​=1。 欧拉公式：eix=cos⁡x+isin⁡xe^{ix}=\\cos x + i\\sin xeix=cosx+isinx。 快速傅里叶变换 设 F(x)=∑i=0n−1ai×xiF(x)=\\sum\\limits_{i=0}^{n-1} a_i\\times x^iF(x)=i=0∑n−1​ai​×xi，那么这是多项式的系数表示法。 由拉格朗日插值可知，我们搞 nnn 个不重复的点也可以确定一个 n−1n-1n−1 次多项式，这是多项式的点值表示法。 FFT 我们现在假定（nnn 为偶数）： F1(x)=a0+a2×x+a4×x2+⋯an−2×xn/2−1F2(x)=a1+a3×x+a5×x2+⋯an−1×xn/2−1F_1(x)=a_0+a_2\\times x + a_4\\times x^2+\\cdots a_{n-2}\\times x^{n/2-1}\\\\ F_2(x)=a_1+a_3\\times x + a_5\\times x^2 +\\cdots a_{n-1}\\times x^{n/2-1} F1​(x)=a0​+a2​×x+a4​×x2+⋯an−2​×xn/2−1F2​(x)=a1​+a3​×x+a5​×x2+⋯an−1​×xn/2−1 那么 F(x)=F1(x2)+xF2(x2)F(x)=F_1(x^2)+x F_2(x^2)F(x)=F1​(x2)+xF2​(x2)。并且： F(ωnk)=F1(ωn2k)+ωnkF2(ωn2k)=F1(ωn/2k)+ωnkF2(ωn/2k)F(ωnk+n/2)=F1(ωn2k)+ωnk+n/2F2(ωn2k)=F1(ωn2k)−ωnkF2(ωn2k)\\begin{aligned} F(\\omega_n^{k})=F_1(\\omega_n^{2k})+\\omega_{n}^k F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_{n/2}^{k})+\\omega_{n}^k F_2(\\omega_{n/2}^{k}) \\end{aligned} \\\\ \\begin{aligned} F(\\omega_n^{k+n/2})=F_1(\\omega_n^{2k})+\\omega_{n}^{k+n/2} F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_n^{2k})-\\omega_{n}^{k} F_2(\\omega_n^{2k}) \\end{aligned} F(ωnk​)​=F1​(ωn2k​)+ωnk​F2​(ωn2k​)=F1​(ωn/2k​)+ωnk​F2​(ωn/2k​)​F(ωnk+n/2​)​=F1​(ωn2k​)+ωnk+n/2​F2​(ωn2k​)=F1​(ωn2k​)−ωnk​F2​(ωn2k​)​ 通过这样的方式，我们可以以 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度在已知一个多项式的系数表示时求得它的点值表示，在求出两个多项式的点值表示后，我们就可以计算 H(x)=F(x)G(x)H(x)=F(x)G(x)H(x)=F(x)G(x)，进而得到两多项式乘积的点值表示。 IFFT 我们现在要将点值表示转化为系数表示，我们现在得到了 nnn 个点 (ωni,yi=F(ωni))(\\omega_{n}^i,y_i=F(\\omega_{n}^i))(ωni​,yi​=F(ωni​))。 略。 迭代实现 void FFT(int L, Complex *f, int type) // L 表示长度, type = 1 表示 FFT, type = 0 表示 IFFT static int r[N]; for (int i = 1; i L; ++i) r[i] = (r[i 1] 1) + (i 1 ? L 1 : 0); if (i r[i]) swap(f[i], f[r[i]]); for (int d = 1; d L; d = 1) Complex wd(cos(PI / d), sin(PI / d)); // 2d 次单位根 wd.b *= type; // IFFT 单位根取倒数, 相当于沿 x 轴对称 static Complex w[N]; w[0] = Complex(1, 0); for (int j = 1; j d; ++j) w[j] = w[j - 1] * wd; // 用数组记录 0 ~ d-1 次单位根, 减少复数乘法次数 for (int i = 0; i L; i += d 1) for (int j = 0; j d; ++j) Complex x = f[i | j], y = w[j] * f[i | j | d]; f[i | j] = x + y, f[i | j | d] = x - y; if (type == -1) for (int i = 0; i L; ++i) f[i] = f[i] / L; 三次变两次优化 我们考虑 (f+gi)2=f2−g2+2fgi(f+gi)^2=f^2-g^2+2fgi(f+gi)2=f2−g2+2fgi，因此有 三次变两次。 快速数论变换 将 FFT 的单位根换成原根。 半在线卷积 模板，一般使用 CDQ 分治 + NTT 来解决。我们每次统计 l∼midl\\sim midl∼mid 对 mid+1∼rmid+1\\sim rmid+1∼r 的贡献，写出来之后发现是多项式乘法的形式。 void solve(int l, int r) // if (l == r) return; int mid = l + r 1, L = 1; solve(l, mid); static int a[N], b[N]; while (L r - l + 1) L = 1; for (int i = 0; i L; ++i) a[i] = (l + i = mid ? f[l + i] : 0), b[i] = g[i]; NTT(L, a, 1); NTT(L, b, 1); for (int i = 0; i L; ++i) a[i] = 1ll * a[i] * b[i] % P; NTT(L, a, -1); for (int i = mid + 1; i = r; ++i) f[i] = (f[i] + a[i - l]) % P; solve(mid + 1, r);"},{"title":"拉格朗日插值","path":"/wiki/oi-note/8-4.html","content":"拉格朗日插值是沟通多项式的系数形式与点值形式的重要公式。 事实上，nnn 个点确定唯一的多项式，其最高项次数为 n−1n-1n−1。 一般形式 核心思想是利用点值的可加性。什么意思呢？ 构造一个函数 f(x)f(x)f(x) 经过 P(x1,y1),⋯P(xn,yn)P(x_1,y_1),\\cdots P(x_n,y_n)P(x1​,y1​),⋯P(xn​,yn​)，设第 iii 个点在 xxx 轴上的投影为 Pi′(xi,0)P_i^{\\prime}(x_i,0)Pi′​(xi​,0)。考虑构造 nnn 个函数，使得 fi(x)f_i(x)fi​(x) 的图像经过 {Pj′(xj,0),(j≠i)Pi(xi,yi)\\begin{cases}P_j^{\\prime}(x_j,0),(j eq i)\\\\P_i(x_i,y_i)\\end{cases}{Pj′​(xj​,0),(j=i)Pi​(xi​,yi​)​，则 f(x)=∑i=1nfi(x)f(x)=\\sum_{i=1}^{n}f_i(x)f(x)=∑i=1n​fi​(x)。 设 fi(x)=a∏j≠i(x−xj)f_i(x)=a\\prod_{j e i}(x-x_j)fi​(x)=a∏j=i​(x−xj​)，然后将 PiP_iPi​ 的坐标代入求出 a=yi∏j≠i(xi−xj)a=\\cfrac{y_i}{\\prod_{j e i}(x_i-x_j)}a=∏j=i​(xi​−xj​)yi​​，进而导出： f(k)=∑i=1nyi∏i≠jk−xjxi−xjf(k)=\\sum_{i=1}^n y_i\\prod_{i e j}\\frac{k-x_j}{x_i-x_j} f(k)=i=1∑n​yi​i=j∏​xi​−xj​k−xj​​ 这就是拉格朗日插值表达式。 如果要求出系数，用 O(n2)O(n^2)O(n2) 卷出 F(x)=∏i=1n(x−xi)F(x)=\\prod_{i=1}^n (x-x_i)F(x)=∏i=1n​(x−xi​)，然后对于每个 iii 暴力将 FFF 除掉 x−xix-x_ix−xi​ 算出 F(x)x−xi\\cfrac{F(x)}{x-x_i}x−xi​F(x)​ 的各项系数，再乘 yi∏j≠ixi−xj\\cfrac{y_i}{\\prod_{j e i}{x_i-x_j}}∏j=i​xi​−xj​yi​​ 即可得到 fif_ifi​ 的各项系数，加起来即可。时间复杂度为 O(n2)O(n^2)O(n2)。 #include iostream#include cstdiousing namespace std;const int MOD = 998244353;int poww(int a, int b) int res = 1; for (; b; b = 1, a = 1ll * a * a % MOD) if (b 1) res = 1ll * res * a % MOD; return res;int n, k;int x[2005], y[2005];int main(void) scanf(%d%d, n, k); for (int i = 1; i = n; ++i) scanf(%d%d, x + i, y + i); int ans = 0; for (int i = 1; i = n; ++i) int s1 = y[i], s2 = 1; for (int j = 1; j = n; ++j) if (i != j) s1 = 1ll * s1 * (k - x[j]) % MOD, s2 = 1ll * s2 * (x[i] - x[j]) % MOD; ans = (ans + 1ll * s1 * poww(s2, MOD - 2)) % MOD; printf(%d , (ans % MOD + MOD) % MOD); return 0;"},{"title":"正整数中的数论","path":"/wiki/oi-note/9-1.html","content":"主要是针对素数的研究。 素数与合数 如果一个数 x(x∈N)x(x\\in\\mathbb{N})x(x∈N) 的约数仅有 111 和它本身，那么就称 xxx 是质数（素数），特别地，000 和 111 不是质数，如果一个自然数不是质数，他就是合数。 可以用线性筛在 O(n)O(n)O(n) 的时间内筛出所有质数，用 O(r+(r−l+1)log⁡(r−l+1))O(\\sqrt{r}+(r-l+1)\\log(r-l+1))O(r​+(r−l+1)log(r−l+1)) 的时间筛出区间内的所有质数。 ppp 进赋值序列是刻画正整数的重要方式。可以将正整数表示到 ppp 维空间上。 例题 刷提升 1"},{"title":"模意义下的数论","path":"/wiki/oi-note/9-2.html","content":"基础知识 拉格朗日定理：在模 ppp 意义下，最高次项系数非 000 的 nnn 次多项式至多有 nnn 个根。 线性同余方程组 可以使用 CRT 解决模数互质的情况，exCRT 解决模数不互质的情况。 {x≡a1(modm1)x≡a2(modm2)⋯x≡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} ⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋯x≡a3​(modm3​)​ 模数互质 设 M=∏i=1nmi,Mi=m÷miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=∏i=1n​mi​,Mi​=m÷mi​，tit_iti​ 是线性同余方程 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​) 的一个解，也就是说 tit_iti​ 是 MiM_iMi​ 模 mim_imi​ 的逆元（显然 Mi⊥miM_i \\perp m_iMi​⊥mi​ 当且仅当 mim_imi​ 两两互质），那么 x=∑i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=∑i=1n​ai​Mi​ti​+kM，最小非负整数解需要求 ∑i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod M∑i=1n​ai​Mi​ti​modM。 i64 CRT(void) // x === a[i] (mod m[i]) i64 ans = 0, x; for (int i = 1; i = n; ++i) M[i] = mm / m[i]; t[i] = inv(M[i], m[i]); ans = (ans + a[i] * M[i] * t[i]) % mm; return (ans % mm + mm) % mm; 模数不互质 考虑如何合并两个方程组。我们先假定一定可以合并，然后看看什么时候合并之后的解是 ∅\\varnothing∅。 假设我们有： {x≡a(modA)x≡b(modB)\\begin{cases} x\\equiv a \\pmod A\\\\ x\\equiv b \\pmod B \\end{cases} {x≡a(modA)x≡b(modB)​ 那么 x=Ak1+a=Bk2+bx=Ak_1+a=Bk_2+bx=Ak1​+a=Bk2​+b，不难使用 exgcd 求出一组合法的 k1,k2k_1,k_2k1​,k2​，则通解为： K1=k1+t×Bgcd⁡(A,B)K2=k2−t×Agcd⁡(A,B)K_1=k_1+t\\times \\frac{B}{\\gcd(A,B)}\\\\ K_2=k_2-t\\times \\frac{A}{\\gcd(A,B)} K1​=k1​+t×gcd(A,B)B​K2​=k2​−t×gcd(A,B)A​ 则 x=A(k1+t×Bgcd⁡(A,B))+a=Ak1+t×lcm⁡(A,B)+ax=A(k_1+t\\times \\frac{B}{\\gcd(A,B)})+a=Ak_1+t\\times \\operatorname{lcm}(A,B)+ax=A(k1​+t×gcd(A,B)B​)+a=Ak1​+t×lcm(A,B)+a，也就是： x≡Ak1+a(modlcm⁡(A,B))x\\equiv Ak_1+a \\pmod{\\operatorname{lcm}(A,B)} x≡Ak1​+a(modlcm(A,B)) i64 exCRT(void) // x === A[i] (mod B[i]) i64 A = 1; LL a = 0; // M 为当前合并的模数，ans 为当前答案 for (int i = 1; i = n; ++i) i64 b = ::A[i], B = ::B[i], x, y, c = b - a; i64 g = exgcd(A, B, x, y); if (c % g != 0) return -1; a = A * ((LL)x * (c / g)) + a; A = A / g * B; a %= A; return (a + A) % A;"},{"title":"欢迎来到 NOI 一轮复习笔记","path":"/wiki/oi-note/index.html","content":"这是什么 原为不知名菜狗 OIer james1BadCreeper 在高二备战 NOI2024 时书写的笔记，现在他要上大学了，于是重新整理并完善了这些内容。 当时的想法很美好，但是受限于水平和执行力，很多内容都没能完成。现在重新将其拾起，能完成多少是多少了。 怎样使用 受限于作者的水平，完全依照本笔记来学习是不妥的。需要学会在网上查找更多的参考文章和向大佬提问。阅读本笔记时要保持警惕，如果发现错误，请及时通过评论区告知笔者，谢谢您的支持。 但是笔者认为这些笔记的选题是很有价值的。如果你在学习对应知识点的时候不知道做什么题，不妨看一看本笔记。 通用规则 以下是笔记的一些符号的含义，与一些不说明的规则： 题目前的星号： *： 不错的题目； **： 相当不错的题目。 P 打头的题号默认是洛谷主题库。"},{"title":"风雪前夜","path":"/wiki/pastmemory/disaster1.html","content":"什么时候六月份会下雪呢？当然是在南半球啦！ 这是什么？脑筋急转弯吗？ 我在此可以做出预言：明天会下雪，而且是在北半球。理由？这是一位伟大的占星者告诉我的！它左手握着黄金权杖，水晶球在它的右手上静静地悬浮着。它仰望着星空，告诉我，六月三十三日会下雪。 但是它死了。 众人闯了进来。亡者躁动不安……他们的每一根僵硬的手指都指向了刺骨的北地。聆听神谕的占星者极力劝说众人，跟随它的指引去铲除最后的罪恶。但愤怒的众人再也无法相信它说的每一句话，将他绑在了绞刑架上，送占星者回到了它的“神”的身边。 后来呢？看看天气预报，嗯，明天，额不对，明天是七月三日，不下雪。六月三十三日并不存在，六月三十三日更没有雪。我应该是犯了蠢吧？我怎么会认为存在六月三十三日这个日期呢？ 我看了看手机，没有错，今天是六月三十二日，明天确实应该是六月三十三日。但是为什么天气预报会说明天是七月三日？又怎敢做出违背伟大的占星者的预言的推断？ 占星者到底是谁呢？ 地府的人告诉我，他们在审判占星者时，它的身上突然长出来了鱼鳍，它是一个深海人！它就是传说中的利维坦（Leviathan）。它畅泳于大海之时，波涛亦为之逆流。它口中喷着火焰，鼻子冒出烟雾，拥有锐利的牙齿，身体好像包裹着铠甲般坚固。性格冷酷无情，暴戾好杀，它在海洋之中寻找猎物，令四周生物闻之色变。 酆都大帝亲自审判，将利维坦驱逐到八大地狱之九：绝境。此处已经不可用地狱来形容，相当于地狱的边境之地，有着接近于绝对零度的温度，可以将一切化为接近于静止。也就是说，在绝境，甚至连时间都会被冻结。 为什么，占星者会是利维坦？不，是人们看不清真相，绞死了占星者！ 天气预报是错的，明天真的会下雪！"},{"title":"终极天灾","path":"/wiki/pastmemory/disaster13.html","content":"“你啊，就完全不知道自己是个什么东西是吧。苏格拉底说，‘认识你自己。’你却未曾注意过你到底是个什么样的存在。” 我看了看我，对眼前这个人所说的话感到茫然。 “我是 KE9Ne，目的是干掉你。” 不，我一定要问清楚一切，然后杀掉这个人！ 当这个想法产生之时， “你和之前几百次犯了一样的错误呢。下次再见了。”KE9Ne 将剑从我的躯体中拔出。 “什么，下次再见是什么意思？”很意外地，我并没有感觉到什么疼痛，只是苍蓝色的血液从我被刺穿的伤口处缓缓流出。 “果然啊。”眼前的人叹息到，“这是你死亡的，第 1981 次，吧。干掉你果然还是太困难了。”言罢，他便转身离开。 我感觉我自己的意识正在缓缓消逝，这可能将是我的终点。 但是天灾并没有停止。 在一个名叫地球的星球上，被冰封的白发少女永远驻留在了北极点。也许在亿万斯年后，当下一批类似于人类的智慧生命到达这个北纬 90° 的坐标，也不会知道在他们脚下的厚厚冰层中，埋藏着怎样的历史。"},{"title":"一级预警","path":"/wiki/pastmemory/disaster2.html","content":"六月三十三日确实没有下雪，是占星者说了谎。 也许是我错了，旧时代的迷信不可相信。 然而我今天又遇见了另一位占星者，看上去比上一位靠谱的很多。它发布了一级预警！！！ 果然，下雨了！这位占星者真的很靠谱！ 我花一块大洋雇佣了它。在放学路上我们遇见了一个混混，他拿着枪指着我们。占星者毫不在意：“我赌他的枪里没有子弹，赌注是一块大洋！”然后枪响，占星者死了。 但是转眼间，凶手也消失不见。我仔细看了看周围，但除了还在下的雨，什么也没有。我呆在雨幕中，过了很久。"},{"title":"二级狂风","path":"/wiki/pastmemory/disaster3.html","content":"我没有想到，我竟能遇到第三位占星者！ 第一次遇见它时，我竟有些害怕，它那酷似“歪嘴战神”的诡异笑容让人发抖。它一挥爪，我的眼前就呈现了一副可怕的情景：暴风雪，在不可阻挡的气流中，我飞向了空中。暴风雪似乎只在我周围存在，我不知道它是如何做到的。 “你的身体太轻，狂风袭来之时，会将你与一切分别。告诉你吧，天灾真的会降临，届时一切都会被毁灭。” “你，是谁？” 它的嘴歪的更厉害了，笑容开始变得变态起来，拿起手中我不知道什么材质的权杖，上面甚至还有一个小骷髅头。它用权杖敲了两下地面，然后，它消失了。 第一位占星者，告诉我六月十八日会下雪，但是最终没下。 第二位占星者，成功预言了会下雨，但是在赌枪里是否有子弹时失败，被毙。 第三位占星者，似乎有些超能力，它做的事情有些恐怖。 下一个，是什么？还会有第四位占星者吗？“天灾”指的是什么？ 我们拒绝坐以待毙。我再次来到了地府，打算打听一些关于被关在绝境里的利维坦的事。使者告诉我，它似乎休克了，它在绝境 -273.15℃ 的岩浆中已经快被冻死了。 这群占星者，究竟来自哪里？到底是何方神圣？ 离开了地府，但是，我又不知道往哪里去了。 最近的风似乎开始大起来了，不寻常啊。"},{"title":"三级暗流","path":"/wiki/pastmemory/disaster4.html","content":"这是一座很神秘的山，传说中这里有一棵神秘的古树，找到并砍倒它，解读其中的文字，便可以知晓世界之真理。不少村民曾来这里砍树，却从来没见过什么文字。后来政府明令禁止砍树，渐渐地再也听不到山中的轰鸣声了，可这传说依然代代相传。 前几天我收到了一封信，信中自称它是第四位占星者，有事情想跟我说。我来到这座山，就是寻找“第四位占星者”。 然而，我在山中遇到了一具尸体，是第三位占星者的尸体。 它的嘴依然很歪，似乎在死前还大笑着。 “看到了吧。”另一位占星者从暗处走来，它就是第四位占星者。 “你杀死了它？” “嗯，没想到吧。” “不知道，最初我以为你们是类似神谕者一样的东西，也许能为人类做出某些预警，但后来发现好像不是。如果可以的话，我也应该杀了你。” 它笑了笑，笑得很无力：“我们确实不是什么好人，但是我们确实不是灾难的制造者，我也活不了多久了，在我们见面之后，其它占星者很快就回来杀死我，我只是希望你，尽快去寻找灾难的源头，阻止天灾降临，否则这颗星球可能要完蛋的。” “如果真的有天灾，那不应该是自然法则所造成的吗？比如全球火山爆发导致冰河时代还是什么小行星撞击地球的来着？那样的话不就需要听天由命了吗。”我嘲笑它，“况且你有什么证据能证明天灾存在？” “是，我无法证明。但是我们的预言，是足够准确的。” “那你说，我该怎么做？” “到极北之地[1]。” “等等？极北之地？你是说要我前往北极点？” 然而我再也看不见占星者，它的轮廓再次消失于黑暗之中，就如同它出现时那样突兀。 世人不会想到，遗忘之海波光粼粼的海面下早已暗流涌动。占星者望了望躁动的星空，“灾难，要开始了。”然后，垂垂老矣的它，静静地躺在了地上，永远地闭上了眼睛。 《狂乱繁星》的故事发生在一个在北极存在一片大陆的星球。 ↩︎"},{"title":"四级霜冻","path":"/wiki/pastmemory/disaster5.html","content":"我如往常醒来，感觉有点冷，一看气温，零下十度？昨天不还是三十多度吗？"},{"title":"八级暴雪","path":"/wiki/pastmemory/disaster9.html","content":"人类在很早以前就幻想能够穿越时间，“穿越”到未来并不是什么难事，而想要回到过去就难多了，因为如果能够回到过去，那么物理学都不存在了。 在这个超出我们能理解的范围内的世界，“天启领主”做到了这一点。然而，这并不是什么好事，“天启领主”反复穿越于过去、现在和未来，盗走了无数珍宝，也因此获得了“时空大盗”的美誉。 由于技术原因，天启领主时间穿越的地点会产生一定的空间偏移，也就让人们在走过小巷的时候会突然来到市中心，打开窗户却有河水涌了进来。警察局长一直不相信天启领主的存在，但是他错了。天启领主，真的来了。 在某一天，时空大盗窥见了未来，他成为了占星者 09。 他想要离开地球，需要动用整个太阳系的能量，同时也会毁灭太阳系范围内的一切，自然包括刚刚做好一同对抗末日准备的人类。"},{"title":"旧日末路","path":"/wiki/pastmemory/flawlesslie10.html","content":"最终她承认自己错误地低估了敌人的力量。 “我命令我的部队停止抵抗，不要再造成更多的伤亡，希斯塔无条件投降。” iznomia 最后一次叹气，“是你赢了，Mythend，还是应该说，你们赢了？但我不想被末影之刃砍下头颅，我会自行了断。” 过了很久，从广播中传出来一声枪响。随后，万籁俱寂。"},{"title":"谎言破碎之后","path":"/wiki/pastmemory/flawlesslie11.html","content":"“她是，自杀了吗？”樱问。 “按照那东西的性格来说，应该是的。”KE9Ne 回答，“终于结束了，第二次诛神之战。” “怎么了，iznomia？”james1BadCreeper 问道。 “我感觉有些不真实，”iznomia 望着前方被轰炸的有些残破不堪的希斯塔城，“她就这样自杀了？不管怎么说，她就是我啊。” “怎么，一声招呼都不打就想离开吗！你这家伙是装高冷还是怎么回事？”james2StormEye 一把抓住了 Mythend。 “反应倒是很快嘛，我以为我能神不知鬼不觉地溜走呢。” “能告诉你的就这么多。答应我，今天所给你讲的不要告诉任何其他人，这个宇宙中有一个人知晓真相 “好。”james2StormEye 点了点头。 “那也是时候道别了。替我向 kn 和萨缪尔问好。”他说完这句话就转身离开，登上了终界航母。第二次诛神之战期间，这个宇宙第一次聆听终界航母的咆哮声，而这一次也可能是最后一次。刚升空时速度还很慢，也再次展示了它那让人难以理解的加速度，就离开了这个宇宙。 “也许这一别，就是沧海桑田了吧。”james2StormEye 抬头望向希斯塔星淡粉色的天空，留下了他人生中的第一滴泪水。 “他就这样走了？还真像他的作风。”听完 james2StormEye 讲述的萨缪尔回答道。 “我还挺想再见见他的。” “ 希斯塔的重建在 iznomia 的领导下有序地进行着。虽然 iznomia 从经验方面来说更像是个孩子，但她手下的人，如天启领主"},{"title":"参战","path":"/wiki/pastmemory/flawlesslie5.html","content":"由于希斯塔对终界发起了无耻的偷袭，为了保卫终界不受主宇宙的侵害，我命令国会宣布终界对希斯塔宣战！” 终界航母恐怖的咆哮声响起，缓缓通过了传送门，来到了这个不属于它的维度。 力量的天平已经倒转，接下来将见证的是这个世界的神明都无法理解的规则。"},{"title":"阅读须知","path":"/wiki/pastmemory/index.html","content":"本质上是关于 iznomia 的某种自设，但其相对来说更庞大。会逐步补全，目前的推荐阅读顺序： 旧历 狂乱繁星 CRYPTO 灾难 绝对无用 红十字 完美谎言 新历 终界旅行 二次重生 除此之外，《个人档案》可以在您喜欢的时候阅读，其可能有部分剧透，但不会影响您的阅读体验。 最后，希望您能在阅读之后，优雅地忘记一切。"},{"title":"败者不语","path":"/wiki/pastmemory/nihil6.html","content":"“真的是他？也许我们有救了。”kn 说。 “他是？”james1BadCreeper 问。 “代号‘末影之刃’，来自终界的神话，Mythend， “什，什么？为什么，有人能，斩断，我的剑？” “你以为人质能阻止我吗？”紫衣男子脸上露出神秘的笑容。"}]