[{"title":"2025-10-20(#6)：","path":"/posts/3b920f8f/","content":"trio https://qoj.ac/contest/2551，怎么马上就要打正赛了啊？ solo https://qoj.ac/contest/1828 B. Birthday Gift 发现不太能做，转化成删除相邻两个不同的，这样 222 就可以转化为 0,10,10,1，最后必定会删到只剩一个数的情况。 qoj14572 Mex Hex 这个条件非常奇妙，不太能 DP。但是可以维护上一个保护范围终止点的可行区间，这样下一个区间的合法范围是可以简单地更新的。 qoj4888 Decoding The Message 首先模 655356553565535 很诡异，注意到 65535=3×5×7×25765535=3\\times 5\\times 7\\times 25765535=3×5×7×257，因此对于 256256256 进制，前三个都是所有数的和（256 mod 3=1256\\bmod 3=1256mod3=1），后面这个 做点杂题，感觉这个挺杂的：2023 Multi-University Training Contest 1。 A. Hide-And-Seek Game 不是你怎么能调这么久的。 B. City Upgrading 直接 DP 就可以了。 E. Cyclically Isomorphic 向模板库中添加了最小表示法。 I. Assertion 你在搞笑吗。 J. Easy Problem I 不是你怎么能调这么久的。 K. Easy Problem II 不是你怎么能调这么久的。 不如 Today’s Computer is very Fast.","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-05(#5)：不死的太阳耀斑","path":"/posts/Infinity/","content":"Ashrount —— Undying Macula 10 月 2 日体验了 Arcaea 的新主线，也是我第一次跟着更新体验主线。确实好玩好吧。 隐藏曲我就这么翻译了，感觉这么粗暴的翻译比较有史诗感。 谢谢你回应我的呼唤。 duo https://qoj.ac/contest/2539 F. Yet Another MST Problem 就你要注意到一个事情，两个区间连起来之后，新的区间相当于这两个区间的交集。 E. Coffee Shops B. Domain Compression K. Robot Construction trio https://qoj.ac/contest/1741，真补不完了啊。 E. Building a Fence 考场上就应该直接写拍子。 B. Bookshelf Tracking 注意到读书操作相当于左右两半段排序，因此直接模拟即可。 C. Painting Fences D. Function with Many Maximums F. Teleports G. Exponent Calculator I. Marks Sum 萌萌的。 K. Train Depot L. Array Spread trio https://qoj.ac/contest/1780。 我觉得我就是菜。 H. Permutation 事实证明小局部 DP，大范围按照 2/32/32/3 来划分即可。 E. Team Arrangement 我勒个直接枚举拆分数之后跑 O(n2)O(n^2)O(n2) 暴力啊。 L. Challenge Matrix Multiplication 考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。 trio https://qoj.ac/contest/1901。 我觉得需要好好训练一下。 K. Knapsack 莫名其妙的科技题，这里稍微写点东西。 如果直接那个数少然后将当前数加到某个值里是没有道理的，因为你不会使这三个数的差值变小。于是你考虑每次将两个当前三元组 (A,B,C)(A,B,C)(A,B,C) 合并，用 A+CA+CA+C 来算值，这样大概率是可以减小差值的。 最终我也是不知道真遇到这种题怎么办，感觉只能听天由命。 H. Have You Seen This Subarray? 这场为数不多的好题了，这个比赛给我的感觉非常愚人节。 相邻两个数靠在一起的时间为若干个连续段，因为交换随机，所以段数很少，询问的时候直接暴力合并段即可。 但是 nnn 小的时候不满足这一点，需要暴力哈希做掉。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-30(#4)：我却以为 终有一日 能回想起来","path":"/posts/b060879/","content":"JYOCHO —— 互いの宇宙 国庆会多更新一点，但是我还没做线性代数的标准化作业。 trio https://qoj.ac/contest/1480，红了。 J. Middle Race 假交互其实猜对了，但问题是我暴力写挂了。 但为什么会想着去硬解不等式啊。 就是你要选的尽可能接近 n(A+B+C)÷3n(A+B+C)\\div 3n(A+B+C)÷3，然后直接枚举就行了。 D. Gambler’s Ruin L. Por Una Cabeza trio https://qoj.ac/contest/1236，绿了。 A. Oops, It’s Yesterday Twice More D. Paimon Sorting H. Crystalfly I. Cloud Retainer’s Game L. Secret of Tianqiu Valley M. Windblume Festival K. Ancient Magic Circle in Teyvat 大无语题。 休息很久了，来打 CF！希望能上分！https://codeforces.com/contest/2152 妈的破防了。 E. Monotone Subsequence F. Triple Attack G. Query Jungle","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"夜行","path":"/posts/71998f63/","content":"打完了 CF，但是确实卡 F 了。手速还是需要练的啊。 然后吃了点夜宵，明天下午才有课，因此可以稍微放松一下。原本的打算是稍微玩一会儿，然后在机房睡两三个小时，等早上学校门开了再回宿舍睡觉（我宿舍在校外）。 但发生了一些意料之外的情况。我之前没有注意到机房的窗没有纱窗，便直接将其打开以便通风——这邀请了大量的蚊子进入机房做客，导致我无法入睡。 于是无事可做，扫了一辆车在校园里乱逛。夜晚给人的体感还是比较冷的，把手冻到有点发寒的程度。我尝试寻找可能出去的门（没有找到），在北门找到了没有人要的外卖（放了一天的汉堡），穿越了正在施工的医学楼，如此。 最后以在机房睡了大概半个小时，大拇指被蚊子咬了一下的结局迎来了天亮。温度仍然很低，我离开了学校。 图片 王湘浩楼 于北苑拍摄的拂晓","tags":["闲话"],"categories":["记录","闲话"]},{"title":"2025-09-22(#3)：让我们再次解答 对着那被吞噬的黑暗","path":"/posts/ec78c757/","content":"ARForest feat. Sennzai —— 星になって 队友太强了！！ https://qoj.ac/contest/2534 G. 序列与整数对 这个复杂度怎么拿不等式写出来啊qwq 多做点数据结构。由队长的建议，要补区域赛的数据结构题。 A. 整点正方形计数2 赛时队友写了一个非常诡异的做法过掉了，赛后看来想复杂了。 M. 并行计算 为啥能不去想这个题啊。 首先先把前缀和算出来，然后再减去上一个最近是 111 的位置的前缀和值，也就是 yi×siy_i\\times s_iyi​×si​ 的前缀最大值。 由于 1024=3221024=32^21024=322，因此直接将序列分块，即可比分治更优地完成前缀操作。 C. 造桥与砍树 F. 连线博弈 Fun Fact：我之前做过 SG 函数的递推式长得跟这个一样得题，但是一点瞪不出 SG 函数的规律。感谢队友神力了。 H. 教师 trio https://qoj.ac/contest/1252 也算是勉强打上金牌线了，主要是我的 I 分类讨论讨错了，我在干什么🤣 I. Linear Fractional Transformation 硬解方程，由于 c,dc,dc,d 中至多只有一个是零，分别尝试将所有数用 c,dc,dc,d 表示即可。 来打 CF，用的小号，打 Div.2，https://codeforces.com/contest/2151。 怎么 C 都不会了，还是要充满决心啊！ C. Limited Edition Shop 其实一开始想的就是对的，唉。 搞了新的小号来打 Div.3。james2StormEye！ https://codeforces.com/contest/2149 无语了，怎么能卡 F。 某些小事情：/posts/71998f63/。 补 https://qoj.ac/contest/2238。 G. 矩阵 for (int i = 1; i = n; ++i) for (int j = 1; j = n; ++j) cout j + (i - 1) * p [j == n]; pnpnpn。 trio https://qoj.ac/contest/1305 打的还可以吧。 E. Buy and Delete 被队友想出做法后遥控我写完了，然后发现这个东西很对。 唉怎么每天都有一万道题需要做。 感觉是时候寻找一些全新的可能性了，iznomia。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-15(#2)：漂浮于重力之上","path":"/posts/c967b560/","content":"AxR —— Levitation [EC Online 2025 II] DAG Query 我了个假 DAG 啊。 忘了拉格朗日插值怎么推的了。 有板子真的，最多三分钟。 无语了，只能说幸好没掉出前六。 solo https://qoj.ac/contest/1799 G. Game 直接模拟即可，需要等比数列求和。 L. 502 Bad Gateway 我的写法需要开 int128。 另外我推得的答案总是小 111😂，不知道为什么，可能题读错了，直接加上就好了。 D. Query on Tree K. Match 有一百万道题需要补。 trio https://qoj.ac/contest/1053 E. Identical Parity 被硬控了😭 我觉得还是需要写出 exgcd 的通解。 D. Frozen Scoreboard C. DFS Order 2 这真的比 G 简单吗😨 肯定要树形 DP，但是不难发现一个事情：关注子树内的信息是极其诡异的，因为 DFS 序只和子树外面是怎么走的有关。 G. Quick Sort 快速排序的答案是 O(nlog⁡n)O(n\\log n)O(nlogn) 级别的，只是暴力找比哨兵大 / 小的数交换到 右 / 左边很慢，搞个数据结构优化一下即可。 L. Tree Distance 加强代码能力，加强体力（以及读题能力）。学数学，做 DP，练数据结构，如果可以还需要学图论和串。 妈的干不完了，我想打金。 要不找机会 VP 一场 CF。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-08-30(#1)：重新开始","path":"/posts/cfb4593d/","content":"又回来了，又能持续多久呢？ Sakuzyo —— Lost Memory CF2128D Sum of LDS 注意到以 iii 为右端点的区间的 LDS，一定可以以 iii 或者 i−1i-1i−1 结尾，然后就完成了。 做 https://qoj.ac/contest/1986 A. 删除01串 分讨。 C. 砝码 分讨。 G. 萤火虫难题 注意 111 和任何数都互质。 D. 最近公共祖先 来写简单数据结构！感觉比 H、I、J 都要简单啊。 总结一下两棵树类的问题：在一棵树上进行操作（点分治等），然后统计另一棵树上的信息。 LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。 CF2135B For the Champion 记得使用演算纸而不是 iPad。 qoj 11736 Three Arrays STL 二分记得判断二分出来的东西是否在答案区间内。 感觉 https://qoj.ac/contest/1885 很不错。 [EC Online 2025 I] Moving on the Plane 为啥不会啊。 见 NOI 一轮复习 I：杂项。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"一场因神秘力量影响而发生的事故","path":"/posts/9b7cfc66/","content":"源于一场使用 XeLaTeX 编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。最后切换至 LuaTeX 解决了该问题。 问题概述 最近在准备假期给小朋友讲课用的课件，但是遇到了一个问题：编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。我查阅了曾经做过的课件（只能找到 pdf，源码已丢失），发现它们的大小是正常的。 这让人很苦恼，因为一个课件有上百页，对于一张 2MB 的背景来说，会使得这个课件膨胀至 300MB 的大小，非常的恐怖。所以这是一个继续修复的问题。 有趣的是，如果把这个膨胀的 pdf 打成 zip 那么它没怎么被压缩，而打成 7z 可以压缩至正常大小。原来 zip 这么菜的，以后有机会要研究一下。 问题分析 deepsleep 给出了使用 background 的解决方式。经过我的尝试这好像不起作用。我认为这应该是给 LaTeX 文档用的而不是 beamer。如果是我的问题，请在评论区告诉我。 我曾经在其它环境上使用过 XeTeX 并没有出现上述情况，可能是我现在使用的环境的 XeTeX 有点问题。反正很神秘。 经测试 pdfTeX 可以正常工作，但是因为我需要改字体，所以最终换成了 LuaTeX，问题得以解决。 总结 感觉自己没有解决实际问题的能力。需要学会如何高效地使用搜索引擎寻找答案，并适当的使用 AI 辅助来解决问题。 否则到时候遇到一点自己不会的东西，忙了一个下午不知道自己在忙什么，那就有点搞笑了！","tags":["TeX"]},{"title":"继续寻找人生的下一块拼图","path":"/posts/57c4317c/","content":"图片来源：高考之后人生第一次打凋灵风暴，图为准备进行第二次共生体战以获取用于制作恐怖炸弹的指令附魔书。 令人迷茫的现状 你应该知道我位于辽宁省，昨天查完 2025 年高考的分数。和我的估分差不多，但这个结果也确实不能令人满意。按照曾经的标准就是“没学上了”。 我可以说我拆括号拆错（你可以简单的理解为我计算出了 2(x+3)=2x+32(x+3)=2x+32(x+3)=2x+3）丢了 101010 分很糖，也可以说少刷 505050 套数学卷数学也是这个分，省下来的时间去学物理显然更赚。但不管怎样高考已经结束，复读也是不可能的。只能祝愿还没高考的同学不要犯糖。 只能安慰自己都一样了！自己就是一个普通人而已啦~ 动力源于创作，创作源于生活 后记 不要问我去了哪里。如果某天我想说出来，我会自己写出来的。 就这样吧，要做的事情还有很多，可是自己总是很懒。"},{"title":"CodeTON Round 4 题解","path":"/posts/4ded5892/","content":"避雷：H 我不会。 随便写写吧：https://codeforces.com/contest/1810. 终于更完了，james1 你也是够懒的。 A. Beautiful Sequence 如果有一个数满足 ai≥ia_i\\geq iai​≥i 即可。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n, flag = 0; cin n; for (int i = 1, x; i = n; ++i) cin x; if (x = i) flag = 1; cout (flag ? YES : NO );int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; B. Candies 不难发现决策是唯一的。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n; cin n; vectorint ans; while (n % 2 n 1) if ((n 1) 1) ans.push_back(2), n = 1; else ans.push_back(1), n = (n 1) + 1; if (n != 1) return cout -1 , void(); reverse(ans.begin(), ans.end()); cout ans.size() ; for (int i : ans) cout i ; cout ;int main(void) ios::sync_with_stdio(0); int T = 1; cin T; while (T--) solve(); return 0; C. Make It Permutation 枚举结束的数字即可。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 1e5 + 5;int n, c, d;int a[N];void solve(void) cin n c d; for (int i = 1; i = n; ++i) cin a[i]; sort(a + 1, a + n + 1); int m = unique(a + 1, a + n + 1) - (a + 1); i64 ans = 1ll * m * c + d; for (int i = 1; i = m; ++i) ans = min(ans, 1ll * (a[i] - i) * d + 1ll * (m - i) * c); cout ans + 1ll * c * (n - m) ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; D. Climbing the Tree 蜗牛爬水井是小学时非常常见的脑筋急转弯题，要注意蜗牛可能会直接爬出水井。 对于本题来说，我们需要用更为一般的代数手段，也就是不等式组描述这个问题。给条件相当于要解出一组取值范围看能否与之前的合并，问能否爬出相当于要对于当前的高度取值范围 [L,R][L,R][L,R]，分别看高度为 L,RL,RL,R 时所需的爬出天数（显然这个函数是单调递增的）。 先来看第一个问题。什么时候高度最大？第 nnn 天需要爬 aaa 时，即 (n−1)×(a−b)+a(n-1)\\times (a-b) + a(n−1)×(a−b)+a。最小呢？第 n−1n-1n−1 天白天爬完之后还剩 111 的高度没有爬完，以至于需要第 nnn 天接着爬。 再来看第二个问题。不妨设高度为 hhh，那么要满足 an−b(n−1)≥han - b(n-1) \\geq han−b(n−1)≥h，将 nnn 解出向上取整即可。 有点小细节但不多，比如天数为 111 需要特判之类的。样例非常友好，写挂了全能调出来。 #include bits/stdc++.husing namespace std;typedef long long i64;i64 calc(i64 h, int a, int b) if (a = h) return 1; // (a - b)n = h - b return (h - b + a - b - 1) / (a - b);void solve(void) int q; cin q; i64 L = 1, R = 2e18; while (q--) int op, a, b; i64 n; cin op a b; if (op == 1) cin n; i64 r = (n - 1) * (a - b) + a; i64 l = (n == 1 ? 1 : (n - 2) * (a - b) + a + 1); if (l R || r L) cout 0 ; else cout 1 ; L = max(L, l); R = min(R, r); else // cerr L R E$TD ; i64 n1 = calc(L, a, b), n2 = calc(R, a, b); if (n1 != n2) cout -1 ; else cout n1 ; cout ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; E. Monsters 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 2e5 + 5;int n, m, a[N], vis[N];vectorint G[N];bool work(int x) #define pii pairint, int priority_queuepii, vectorpii, greaterpii q; q.emplace(0, x); int cnt = 0; while (!q.empty()) int u = q.top().second; q.pop(); if (vis[u] == x) continue; vis[u] = x; ++cnt; if (a[u] = cnt) return 0; for (int v : G[u]) if (vis[v] != x) q.emplace(a[v], v); return cnt == n;void solve(void) cin n m; for (int i = 1; i = n; ++i) vectorint().swap(G[i]), cin a[i]; while (m--) int u, v; cin u v; G[u].emplace_back(v); G[v].emplace_back(u); memset(vis, 0, sizeof vis); for (int i = 1; i = n; ++i) if (a[i] == 0 vis[i] == 0) if (work(i)) return cout YES , void(); cout NO ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; G. The Maximum Prefix 直接做怎么做？设 fif_ifi​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后刷表转移对于每个状态是 O(1)O(1)O(1) 的，炸了。 需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。 #include bits/stdc++.husing namespace std;typedef long long i64;const int P = 1000000007;const int N = 5e3 + 5;inline int poww(int a, int b) int r = 1; for (; b; b = 1, a = 1ll * a * a % P) if (b 1) r = 1ll * r * a % P; return r;inline int inv(int x) return poww(x, P - 2); inline void add(int x, i64 k) x = (x + k) % P; int n;int p[N];int f[N][N];void solve(void) cin n; for (int i = 1; i = n; ++i) int x, y; cin x y; p[i] = 1ll * x * inv(y) % P; for (int i = 0; i = n + 2; ++i) for (int j = 0; j = n + 2; ++j) f[i][j] = 0; for (int i = 0; i = n; ++i) cin f[0][i]; for (int i = 0; i n; ++i) for (int j = 0; j = n; ++j) if (f[i][j]) // i + 1 位置填 1 if (j) add(f[i + 1][j - 1], 1ll * p[i + 1] * f[i][j]); // i + 1 位置填 -1 add(f[i + 1][j + 1], 1ll * (1 + P - p[i + 1]) * f[i][j]); if (j == 0) add(f[i + 1][0], 1ll * (1 + P - p[i + 1]) * f[i][j]); for (int i = 1; i = n; ++i) cout f[i][0] [i == n];int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0;","tags":["算法竞赛","Codeforces"],"categories":["算法竞赛","Codeforces"]},{"title":"我回来了","path":"/posts/a5aedc5a/","content":"搬家了！这里是新博客。以前的内容会逐步搬迁。 这里主要测试一些内容，回归文章一段时间之后会写。 公式部分 ap−1≡1(modp) a^{p-1}\\equiv 1 \\pmod p ap−1≡1(modp) ∇⋅D=ρf∇⋅B=0∇×E=−∂B∂t∇×H=Jf+∂D∂t\\begin{array}{l} abla \\cdot \\mathbf{D} =\\rho _f \\\\ abla \\cdot \\mathbf{B} = 0 \\\\ abla \\times \\mathbf{E} = -\\cfrac{\\partial \\mathbf{B}}{\\partial t } \\\\ abla \\times \\mathbf{H} = \\mathbf{J}_f + \\cfrac{\\partial \\mathbf{D}}{\\partial t } \\end{array} ∇⋅D=ρf​∇⋅B=0∇×E=−∂t∂B​∇×H=Jf​+∂t∂D​​ 代码部分 这里测试一些代码。 cpp #include bits/stdc++.husing namespace std;int main(void) cout Hello World! ; return 0; yaml stellar: version: 1.30.1 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar main_css: /css/main.css main_js: /js/main.js"},{"title":"探索者笔记","path":"/explore/index/index.html","content":"你若问我这里是什么，只是 iznomia 无聊时写的一点文字而已啦~ 如果你找到了某些共鸣，欢迎在评论区与我交流~"},{"title":"探索者笔记","path":"/explore/music/index.html","content":"由于这些歌风格可能非常多元，故以下排名不分先后。 1. かめりあ —— #1f1e33 (Another long “#ant1p01e” version) #1f1e33 一切的一切，真的只是命中注定吗…… 2. 华晨宇 —— 不重逢 不重逢 “不要懂错了没错，只要懂有用没用。” “多愁善感是成不了事的”。所以，杀死过去的自己吧。这不是告别，只是永不重逢罢了。 3. void(Mournfinale) feat. 星熊南巫 —— Testify Testify 你所犯下的罪孽，是可以偿还的吗？！ 宿命岂是凡人可以见证？ 4. Mili —— world.execute(me); world.execute(me); 如果人工智能拥有了情感，你会爱上 TA 吗？ 5. 华晨宇 —— 虚幻与现实 虚幻与现实 既没能消除无知，也没能学会善良。 6. 周深 —— 人是_ “弹指间湮灭我，但命运打不败活着。” 7. 藤末樹 feat. Cereus —— 絶対零度 絶対零度 真正的绝对零度——世界上最为悲凉的感觉莫过于此。 将时间冻结，切割成碎片，染上我苍蓝色的血液。 8. Globus —— The Promise 此路直至彼岸处，那是崭新的明天。 不太会评价，但非常喜欢。绝对的史诗感，但最后却是拨云见日。 相比某些我也很喜欢的史诗音乐没有叠的很厚重，但是听的真的很感动~ 9. Laur —— Glacier 10. Kirara Magic feat. Shion Lee —— Floating Star 喜欢的音乐家 华晨宇Two Steps From HellThomas BergersenCamelliaLaurSakuzyo打打だいずvoid (Mournfinale)a_hisaAxRARForestCre-sc3NTKirara Magic月下散落出世"},{"title":"探索者笔记","path":"/explore/todo/index.html","content":"算法竞赛中的 python：https://www.cnblogs.com/Mxrush/p/17052293.html 完善数据结构部分的复习笔记 学习多项式 做题： https://qoj.ac/contest/1828 https://qoj.ac/contest/2535 https://qoj.ac/contest/1871 https://qoj.ac/contest/1817"},{"title":"前置知识","path":"/wiki/calculus/1.html","content":"邻域：U(A,δ)=(a−δ,a+δ),U˚(A,δ)=(a−δ,a)∪(a,a+δ)U(A,\\delta)=(a-\\delta,a+\\delta),\\mathring{U}(A,\\delta)=(a-\\delta,a)\\cup(a,a+\\delta)U(A,δ)=(a−δ,a+δ),U˚(A,δ)=(a−δ,a)∪(a,a+δ)。"},{"title":"极限与连续函数","path":"/wiki/calculus/2.html","content":"夹逼定理：给定三个数列 xn,yn,zn{x_n},{y_n},{z_n}xn​,yn​,zn​，若满足： ∃K,s.t.⁡nK,yn≤xn≤zn\\exist K,\\operatorname{s.t.} nK,y_n\\le x_n\\le z_n∃K,s.t.nK,yn​≤xn​≤zn​， lim⁡n→∞yn=lim⁡n→∞zn=a\\lim\\limits_{n\\to\\infty}y_n=\\lim\\limits_{n\\to\\infty}z_n=an→∞lim​yn​=n→∞lim​zn​=a， 则 lim⁡n→∞xn=a\\lim\\limits_{n\\to\\infty}x_n=an→∞lim​xn​=a。 证明拿定义写一下就行，又称三明治定理"},{"title":"矩阵的运算和初等变换","path":"/wiki/linear-algebra/1.html","content":"基本上参照吉林大学的教材，可能会适当补充一些比较难的内容。 1. 矩阵与向量 若 A,B\\mathbf{A},\\mathbf{B}A,B 都为 nnn 行 mmm 列的矩阵，则 A,B\\mathbf{A},\\mathbf{B}A,B 称为同型矩阵； 用 eie_iei​ 表示基本列向量，fif_ifi​ 表示基本行向量； 矩阵的行和列互换，称为转置矩阵，记作 A⊤\\mathbf{A}^\\topA⊤，当 A=A⊤\\mathbf{A}=\\mathbf{A}^\\topA=A⊤ 时，A\\mathbf{A}A 是对称矩阵，若 A⊤=−A\\mathbf{A}^\\top=-\\mathbf{A}A⊤=−A，则 A\\mathbf{A}A 是反称矩阵； 矩阵的分块，我对它的理解是：矩阵的元素是矩阵；如果分块后其主对角线上的矩阵是方阵（阶数可以不同），其余子块均为零矩阵，那么它是分块对角矩阵； 对角矩阵：只有主对角线有值的方阵，记为 A=diag⁡{a11,a22,⋯ ,ann}\\mathbf{A}=\\operatorname{diag}\\{a_{11},a_{22},\\cdots,a_{nn}\\}A=diag{a11​,a22​,⋯,ann​}，全相等时称为标量矩阵； 1.1 矩阵的初等变换 三种初等变换 倍法变换：给某一行或列（接下来只写行）乘上一个非零数，A→ri×kB\\mathbf{A}\\xrightarrow{r_i\\times k}\\mathbf{B}Ari​×k​B； 消法变换：用一个数乘上某一行后再加到另一行上，A→ri×k+rjB\\mathbf{A}\\xrightarrow{r_i\\times k+r_j}\\mathbf{B}Ari​×k+rj​​B； 换法变换：交换两行，A→ri↔rjB\\mathbf{A}\\xrightarrow{r_i\\leftrightarrow r_j}\\mathbf{B}Ari​↔rj​​B； 对单位矩阵实施一次初等变换得到初等矩阵。 等价关系： 经过有限次初等变换后相等，A≅B\\mathbf{A}\\cong \\mathbf{B}A≅B。 任意一个矩阵都可以经过若干次初等变换变为标准形矩阵，是一个 2×22\\times 22×2 的分块矩阵，左上角为单位矩阵，其余三个子块为零矩阵。单位矩阵的阶就是原矩阵的秩。 若只允许使用行初等变换，那么可以变成一个行阶梯形矩阵，即左下角有一个全 000 阶梯（而且每个台阶高为 111）。如果行首非零元素为 111，且这个 111 所在的列的其余元素为 000，那么它是行最简形矩阵。 1.2 杂题选解"},{"title":"方阵的行列式","path":"/wiki/linear-algebra/2.html","content":"1. 方阵的行列式"},{"title":"二分与倍增","path":"/wiki/oi-note/1-1.html","content":"两者的本质均基于单调性，寻找题目中具有单调性的函数关系，然后施展二分或者倍增。二分答案可以用来解决分数规划问题，三分法可以求解单峰/谷函数。同时，二分上界不确定的内容的最佳方式是倍增，通过先倍增到上界，再倍增答案来解决。 二分 一种二分写法 通过 l = r 之类的方法的二分笔者认为有些过于诡异，这里给出我自己的二分实现方式（我记得当时是在 B 站学的，但是出自哪个视频忘了）。 Luogu P2249int L = 0, R = n + 1;while (L + 1 != R) int mid = L + R 1; if (a[mid] = x) R = mid; else L = mid;if (a[R] == x) cout R ;else cout -1 ; 01 分数规划 用来求一个分式的极值，也就求一组 wi={0,1}w_i=\\{0,1\\}wi​={0,1}，最大化或者最小化： ∑ai×wi∑bi×wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} ∑bi​×wi​∑ai​×wi​​ 我们一般使用二分答案来解决这个问题。以最大值为例： ∑ai×wi∑bi×wimid⟹∑ai×wi−mid×∑bi×wi0⟹∑wi(ai−mid×bi)0\\begin{aligned} \\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}mid\\\\ \\Longrightarrow \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i 0\\\\ \\Longrightarrow \\sum w_i(a_i-mid\\times b_i)0 \\end{aligned} ⟹⟹​∑bi​×wi​∑ai​×wi​​mid∑ai​×wi​−mid×∑bi​×wi​0∑wi​(ai​−mid×bi​)0​ 于是排序即可确定 wiw_iwi​ 的值。有些时候会限制 ∑bi×wi\\sum b_i\\times w_i∑bi​×wi​ 的最小值之类的，例题，这时使用背包求解即可。 三分法 三分法可以用于求解单峰函数的极值点。对于常规的三分写法不再赘述，但值得注意的是，对于定义域为整数的实际问题，它们的答案可能真的是单峰的，但此时由于其不满足函数的连续性，会存在一大段平的区间，然后三分就炸了（鬼知道极值点在哪，你需要 O(n)O(n)O(n) 扫过去）。 不要错误的将某些函数视作可以三分，更不要将单峰函数视作凸函数而对导函数二分。单峰的证明是比较困难的，而且有时对于非单峰的问题也比较难找到反例（廊桥分配），要根据实际情况判断。 Luogu P1883 画图可知，两个单谷函数（一次函数的谷点视作在无穷远处）取 max⁡\\maxmax 后，得到的新函数仍然是单谷函数，因此直接三分即可。 但很阴的是，这题要求极值而不是极值点，精度会被 bbb 吃掉，因此 eps 要取小。 double L = 0, R = 1000;while (L + eps R) double Lmid = (L + R) / 2; double Rmid = (Lmid + R) / 2; if (calcF(Lmid) calcF(Rmid)) L = Lmid; else R = Rmid; wqs 二分 O(log⁡n)O(\\log n)O(logn) 倍增 ST 表 ST 表使用倍增结构来实现，支持在末尾插入一个数。大概长这样： f[0][n] = a[n]; // The new Nfor (int j = 1; 1 j = n; ++j) f[j][n - (1 j) + 1] = max(f[j - 1][n - (1 j) + 1], f[j - 1][n - (1 j - 1) + 1]); 在开头插入亦同理。 Problemset 刷提升 ** [CF1764G] Doremy’s Perfect DS Class G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pnmidp_n midpn​mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pnmid′p_nmidpn​mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点浪费，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。代码。"},{"title":"杂项内容","path":"/wiki/oi-note/1-100.html","content":"曼哈顿与切比雪夫距离转化 曼哈顿距离是指 x,yx,yx,y 坐标的差的和，而切比雪夫距离指的是差的最大值。 从曼哈顿距离转化成切比雪夫距离，令 xi′=xi+yi,yi′=xi−yix_i=x_i+y_i,y_i=x_i-y_ixi′​=xi​+yi​,yi′​=xi​−yi​，反着转的时候反过来解一下二元一次方程组就行。 [EC Online 2025 I] Moving on the Plane Portal. 首先转成切比雪夫，然后两维独立了。然后坐标范围很小，于是直接枚举最后点走到的坐标范围。然后你发现 KKK 更小，甚至可以直接枚举位置。注意会算重，于是改为钦定最小坐标，把没有点走到最小坐标的东西减去就好了。代码。"},{"title":"分治","path":"/wiki/oi-note/1-2.html","content":"分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 仿照分治的结构可以衍生出一大堆静态分治算法。 普通分治 uoj979. 决战库尔斯克 Portal. 首先排序去重。如果选择钦定最小值，发现需要枚举最小值的倍数然后在一段中二分出最大值，但是值域很大，寄了。 那么钦定最大值，最小值可以选择严格比其一半大的，那么答案是差。 考虑小于的部分对大于的部分的影响。发现需要 ai−1ar−amida_i - 1 a_r - a_{mid}ai​−1ar​−amid​，而这一部分的 aia_iai​ 就只有至多两端倍数了，直接二分。 于是分治下去即可，O(nlog⁡Vlog⁡n)O(n\\log V\\log n)O(nlogVlogn)，二分跑不满能过。代码。 二维分治"},{"title":"随机化算法","path":"/wiki/oi-note/1-3.html","content":"有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据满足一定条件，否则会 TLE 或者超交互次数。 生成随机数mt19937_64 Rnd(time(0));int rndint(int l, int r) return uniform_int_distribution(l, r)(Rnd);double rnddb(int l, int r) return uniform_real_distribution(l, r)(Rnd);"},{"title":"哈希方法","path":"/wiki/oi-note/1-4.html","content":"序列哈希 集合哈希 树哈希 哈希表 Problemset [CSP-S 2022] 星战 Portal. 要求所有点的出度都是 111。其实是要维护一个可重集，对于每一条边，都要将这条边的起点加入集合。只有这个集合恰好为 1∼n1\\sim n1∼n 的集合才是合法的。 因此直接使用集合哈希维护，摧毁和修复节点的操作都是加减法可以完成的。代码。 注意这里只能用 sum Hash，xor Hash 是错误的，比如一个点的出度为 333 也会被视作为合法的。"},{"title":"组合博弈论","path":"/wiki/oi-note/10-2.html","content":"博弈论主要研究一些有竞争或对抗性质的对象，在一定规则下/产生的各种行为。 接下来讨论的所有问题，若没有写出，均默认为两人轮流行动的、完美信息、无随机因素。 通常来讲，无法行动的人会输掉，称为正常博弈，而无法行动却获胜称为反常博弈。 公平组合博弈 引入 我们从 Nim 游戏开始研究。有 nnn 堆石子，每人每次可从任意一堆石子里取出正整数枚石子扔掉，谁不能动谁就输了。 我们将每个状态视作一个节点，那么博弈情况就可以刻画成一张有向图。不难发现，异或和为 000 时先手必败。 大部分的公平组合游戏都可以转换为有向图游戏，对于状态 xxx 和它的 kkk 个后继状态 y1,⋯ ,yky_1,\\cdots,y_ky1​,⋯,yk​，定义 SG 函数为： SG⁡(x)=mex⁡{SG⁡(y1),SG⁡(y2),…,SG⁡(yk)}\\operatorname{SG}(x)=\\operatorname{mex}\\{\\operatorname{SG}(y_1), \\operatorname{SG}(y_2), \\ldots, \\operatorname{SG}(y_k)\\} SG(x)=mex{SG(y1​),SG(y2​),…,SG(yk​)} 对于由 nnn 个有向图游戏组成的组合游戏，当且仅当 ⊕SG⁡(s)≠0\\oplus \\operatorname{SG}(s) e 0⊕SG(s)=0 的时候，先手必胜，称之为 P 态（previous player）。也就是说，SG⁡(x)=0\\operatorname{SG}(x)=0SG(x)=0 是必败态，称之为 N 态。 SG 定理：一个游戏的 SG 值是其所有子游戏的 SG 值的异或和，这可以说明 Nim 游戏结论的由来。 Anti-SG 定理 如果游戏的 SG 值为 000，那么所有子游戏的 SG 值都不超过 111 时先手必胜； 如果游戏的 SG 值不是 000，那么至少有一个子游戏的 SG 值超过 111 时先手必胜。 模板。 常见公平游戏 超现实数理论 非公平组合博弈"},{"title":"分块","path":"/wiki/oi-note/11-1.html","content":"Problemset 刷提升"},{"title":"概述","path":"/wiki/oi-note/12-1.html","content":"广义来说，所有问题都属于构造类问题——它们都需要构造解（bushi）。 此类题目中也有较多 ad-hoc 题，需要我们从多个角度思考，发挥自己的想象力。 我们不能对于每道题都枚举所有套路逐一试错，而需要具体情况具体分析。不应当完全依靠猜或试找出来，而是主要通过线索推断出来。它们包括但不限于： 特殊的题目条件、数据范围 特殊性质、部分分 必然性、充分性 模型的观察与转化 打表的结果 注意在做此类题目时，要避免自己陷入思维死局。"},{"title":"问题的分析","path":"/wiki/oi-note/13-1.html","content":"例题 刷基础 [Ptz Winter 2020 Day3] Disjoint LIS Portal. 看上去非常 NP，"},{"title":"并查集","path":"/wiki/oi-note/2-0.html","content":"拆点 即某教材中的“扩展域”并查集。反对这种恶意恐吓萌新的叫法。 CF776D。所有灯都恰好由两个开关控制，那么给每个开关拆成是否按下的两个点，并查集检查是否有矛盾即可。代码。"},{"title":"树状数组","path":"/wiki/oi-note/2-1.html","content":"又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 ratio:1415/735 模板，区间和我们可以用前缀和相减来求解，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) for (; x = n; x += x -x) C[x] += k; i64 sum(int x) i64 r = 0; for (; x; x -= x -x) r += C[x]; return r; int main(void) scanf(%d%d, n, m); for (int i = 1; i = n; ++i) scanf(%d, a + i), add(i, a[i]); while (m--) int op, x, y; scanf(%d%d%d, op, x, y); if (op == 1) add(x, y); else printf(%lld , sum(y) - sum(x - 1)); return 0;"},{"title":"线段树","path":"/wiki/oi-note/2-2.html","content":"线段树是一种功能强大的二叉数据结构，可以维护半群上的信息（满足结合律）。 对于一般情况，我们使用堆式线段树来存储线段树；对于空间开不下的情况，我们使用动态开点来存储线段树。 双半群模型 例题 刷基础 1 [2023 钉耙编程 1] Easy problem I Portal。如果一个数发生过 ai←x−aia_i\\leftarrow x-a_iai​←x−ai​，那么以后就会一直这样。搞两棵线段树分别维护即可。代码。"},{"title":"平衡树","path":"/wiki/oi-note/2-3.html","content":"平衡树是一种二叉数据结构，满足所谓的“BST 性质”： 空树是 BST； 若 BST 的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值； 若 BST 的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值； BST 的左右子树均为 BST； BST 集合是满足 1、2、3、4 的最小二叉树集。 笔者通常使用 FHQ 来实现平衡树。 例题 刷基础 I [2023 钉耙编程 1] Easy Problem II Portal。维护权值平衡树，找到比 xxx 大、小的分别打标记，打完之后依然满足平衡树的性质。用分块来支持区间操作即可。代码。"},{"title":"扫描线","path":"/wiki/oi-note/2-4.html","content":"对于一个高维空间的坐标限制，我们称之为 BBB 维正交范围问题，我们可以利用扫描线将其降维。也就是说，扫描线维护一维，数据结构维护另一维。 差分处理 如果维护的信息可以差分，那么直接差分掉。比如矩形面积并问题，静态区间内不同数个数问题。将问题转化为矩形操作，然后扫描线维护。 此问题的基础形态是二维数点：平面上有 nnn 个点 (i,ai)(i,a_i)(i,ai​)，每次查询一个矩形内的点的个数。此矩形是一个 4-side 的矩形，可以通过差分的方式将其转化为 3-side，然后再扫描线维护一下变成 2-side，这样就成了一个平凡的单点修改区间查询的问题。 也就是说，差分和扫描线是我们的降维手段，最后一个 2-side 的问题就是平凡的，使用合适的数据结构（区间修改单点查询，单点修改区间查询，区间修改区间查询）维护即可。 这是二维数点的模板，其转化成单点加查询区间和。 矩形面积并 模板。转化成网格图上去做，扫描线扫描矩形的竖线，转化成区间加查询全局 000 的数的个数，因此维护区间最小值（对于全局来说必然是 000）和最小值个数即可，使用动态开点线段树可以很方便地写出来。 #include bits/stdc++.husing namespace std;typedef long long i64; const int N = 1e5 + 5;const int I = 1e9 + 2;int n;int b[N * 2], xs[N * 2];int stot;struct Scanning_Line int x, y, _y, val; Scanning_Line(int x = 0, int y = 0, int _y = 0, int val = 0) : x(x), y(y), _y(_y), val(val) bool operator (const Scanning_Line a) const return x a.x; S[N * 2];// 查区间 0 的数的个数// 区间最小值，区间最小值的个数struct Node int mn, mncnt; Node(int mn = 0, int mncnt = 0) : mn(mn), mncnt(mncnt) friend Node operator+ (const Node a, const Node b) Node c; c.mn = min(a.mn, b.mn); if (a.mn == c.mn) c.mncnt += a.mncnt; if (b.mn == c.mn) c.mncnt += b.mncnt; return c; T[N * 70];int tag[N * 70];int ls[N * 70], rs[N * 70];int tot = 1;inline void maketag(int o, int x) tag[o] += x; T[o].mn += x;inline void pushdown(int o) if (!tag[o]) return; maketag(ls[o], tag[o]); maketag(rs[o], tag[o]); tag[o] = 0;void update(int o, int l, int r, int x, int y, int k) if (x = l r = y) return maketag(o, k); int mid = l + r 1; if (!ls[o]) ls[o] = ++tot; rs[o] = ++tot; T[ls[o]] = Node(T[o].mn, mid - l + 1); T[rs[o]] = Node(T[o].mn, r - mid); tag[o] = 0; else pushdown(o); if (x = mid) update(ls[o], l, mid, x, y, k); if (mid y) update(rs[o], mid + 1, r, x, y, k); T[o] = T[ls[o]] + T[rs[o]];int main(void) ios::sync_with_stdio(0); cin n; for (int i = 1; i = n; ++i) int x, y, _x, _y; cin x y _x _y; --_x, --_y; S[++stot] = Scanning_Line(x, y, _y, 1); S[++stot] = Scanning_Line(_x + 1, y, _y, -1); sort(S + 1, S + stot + 1); for (int i = 1; i = stot; ++i) xs[i] = S[i].x; int m = unique(xs + 1, xs + stot + 1) - (xs + 1); i64 ans = 0; T[1].mncnt = I + 1; for (int i = 1, j = 0; i = m; ++i) if (i 1) ans += 1ll * (xs[i] - xs[i - 1]) * (I + 1 - T[1].mncnt); while (j stot S[j + 1].x == xs[i]) ++j, update(1, 0, I, S[j].y, S[j]._y, S[j].val); cout ans ; return 0; [SDOI2009] HH 的项链 二维扫描线 本质上是莫队，不在本文中介绍。"},{"title":"简单树形问题","path":"/wiki/oi-note/3-1.html","content":"树链剖分 每次跳重链即可完成树上 K 级祖先问题，而且通常比长链剖分快。 树上启发式合并 本质上是枚举每个节点时，直接枚举子树来计算答案的一种暴力。但是由启发式合并，我们可以最后枚举重儿子的信息，然后直接保留，这样就可以在统计父亲答案时不再重新枚举重儿子的信息。 Problemset [北京市赛 2025] 最近公共祖先 Portal. LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。代码。"},{"title":"组合计数","path":"/wiki/oi-note/4-1.html","content":"到处都能见到它的身影，它是一切数数题的基础。 概念基础 基本定义与一些常见公式与方法。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​，有 Anm=n!(n−m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anm​=(n−m)!n!​。 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。置换中形成一个环的称为置换环，对于大小为 1,21,21,2 的置换环，原排列和置换显然是一样的。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 (nm)\\binom n m(mn​)。组合数同时也是二项式系数，当 m0m0m0 时，组合数没有定义。 (nm)=n!(n−m)!m!=nm‾m!(nm)=(n−1m)+(n−1m−1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mn​)=(n−m)!m!n!​=m!nm​​(mn​)=(mn−1​)+(m−1n−1​) 组合数有以下性质 / 恒等式： (nm)=(nn−m)\\dbinom n m = \\dbinom n {n - m}(mn​)=(n−mn​)； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)，常被用来递推组合数； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)； 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1。注意这个东西是很特殊的完整一行，一般的行求和是无法快速计算的。它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 Lucas 定理。若 ppp 是质数，则 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp，常用于 ppp 较小的情况。 组合数奇偶性公式。(nm)≡1(mod2) ⟺ n m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\ \\ m=m(mn​)≡1(mod2)⟺n m=m，使用 Lucas 定理来证明，需保证不出现 (01)\\dbinom{0}{1}(10​)。 Kummer 定理。(n+mn)\\dbinom{n+m}{n}(nn+m​) 中质因子 ppp 的次数为 n+mn+mn+m 在计算时 ppp 进制意义下的进位次数，等价于 (nm)\\dbinom n m(mn​) 中质因子 ppp 的次数等于在计算 n−mn-mn−m 时 ppp 进制意义下的借位次数。其中 ppp 是素数。 上指标翻转。(nk)=(−1)k(k−n−1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(kn​)=(−1)k(kk−n−1​)。 多重组合数。是指先选 n1n_1n1​，再选 n2n_2n2​，以此类推。有（∑ni=n\\sum n_i = n∑ni​=n）： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 组合方法。在小学学过一些常用的组合方法。 捆绑法插空法插板法nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。"},{"title":"容斥原理","path":"/wiki/oi-note/4-2.html","content":"概述 容斥原理是非常重要的计数原理： ∣⋃i=1nSi∣=∑m=1n(−1)m−1∑aiai+1∣⋂i=1mSai∣\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_ia_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| ​i=1⋃n​Si​​=m=1∑n​(−1)m−1ai​ai+1​∑​​i=1⋂m​Sai​​​ 集合的交集可以使用补集容斥原理来求解： ∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| ​i=1⋂n​Si​​=∣U∣−​i=1⋃n​Si​​​ 容斥原理最经典的用处是“至少”与“恰好”之间的转化，实际上是一个子集反演的过程。子集反演是针对集合交并的容斥，可以在恰好是某个集合和至多/至少是这个集合反演。 我们先来看与至多是这个集合的反演。现在有其元素满足某种条件的集合 AAA。定义 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 代表 S⊆AS\\subseteq AS⊆A 时的答案。 钦定选了 SSS 这个集合中的子集 TTT，有 g(S)=∑T⊆Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=∑T⊆S​f(T)，这时有 f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=∑T⊆S​(−1)∣S∣−∣T∣g(T)。使用容斥原理不难感性理解。 类似的，如果 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 表示 A⊆SA\\subseteq SA⊆S 时的答案，有 g(S)=∑S⊆Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=∑S⊆T​f(T)，反演得 f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=∑S⊆T​(−1)∣T∣−∣S∣g(T)。 这是容斥原理的代数形式，它是我们用容斥原理解决问题的基础。因为在钦定时，一个“有两个元素满足条件”的东西会在“至少有一个元素满足条件”的东西计算时计算两次，也就因此成了一个子集反演的形式。"},{"title":"图的相关概念","path":"/wiki/oi-note/5-1.html","content":"一张图 GGG 由点集 VVV 和边集 EEE 构成。我们用 d(v)d(v)d(v) 代表节点 vvv 的度数，如果 d(v)=∣V∣−1d(v)=|V|-1d(v)=∣V∣−1，则称 vvv 为支配点。如果每个点的度数都是 kkk，则该图为 k−k-k−正则图。 子图 对一张图 G=(V,E)G = (V, E)G=(V,E)，若存在另一张图 H=(V′,E′)H = (V, E)H=(V′,E′) 满足 V′⊆VV \\subseteq VV′⊆V 且 E′⊆EE \\subseteq EE′⊆E，则称 HHH 是 GGG 的子图，记作 H⊆GH \\subseteq GH⊆G。 若对 H⊆GH \\subseteq GH⊆G，满足 ∀u,v∈V′\\forall u, v \\in V∀u,v∈V′，只要 (u,v)∈E(u, v) \\in E(u,v)∈E，均有 (u,v)∈E′(u, v) \\in E(u,v)∈E′，则称 HHH 是 GGG 的导出子图。点集为 V′(V′⊆V)V(V \\subseteq V)V′(V′⊆V) 的导出子图称为 V′VV′ 导出的子图，记作 G[V′]G \\left[ V \\right]G[V′]。 若 H⊆GH \\subseteq GH⊆G 满足 V′=VV = VV′=V，则称 HHH 为 GGG 的生成子图/支撑子图。 如果一张无向图 GGG 的某个生成子图 FFF 为 k−k-k−正则图，则称 FFF 为 GGG 的一个 k−k-k−因子。 如果有向图 G=(V,E)G = (V, E)G=(V,E) 的导出子图 H=G[V∗]H = G \\left[ V^\\ast \\right]H=G[V∗] 满足 ∀v∈V∗,(v,u)∈E\\forall v \\in V^\\ast, (v, u) \\in E∀v∈V∗,(v,u)∈E，有 u∈V∗u \\in V^\\astu∈V∗，则称 HHH 为 GGG 的一个闭合子图。也就是说，图内部是闭合的，不存在一个点在导出子图内，可以通过原图的一条边连到一个不在导出子图内的点。 特殊的图 对于无向简单图，所有本来在图上的边都不在，本来不在的都在，那么这个图就是原无向图的补图。 对于有向图，每条边的方向取反，得到的图就是原图的反图。 特殊集合 一些特殊的点和边的集合有着特殊的意义，这里我们介绍一些常见的。 支配集 对于无向图，如果一个点集的点可以连接到原图的所有点，那么这个点集为原图的支配集。 最小支配集是 NPH 的，我们通常使用 O(2n)O(2^n)O(2n) 的枚举算法来求解支配集。 独立集 就是任意两点不相邻的点集。对于树和二分图我们有高效做法，但是一般图上，这个问题是 NPH 的。 匹配 对于图 G=(V,E)G=(V,E)G=(V,E)，若 E′∈EE\\in EE′∈E 且 E′EE′ 中任意两条边都没有公共端点，且 E′EE′ 中没有自环，那么 E′EE′ 是 GGG 的一个匹配，也称为边独立集。如果一个点被匹配的边连接了，那么它就是被匹配的，否则就是不被匹配的。 边数最多的称为最大匹配，如果边带权，那么权重之和最大的匹配称为图的最大权匹配。 如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配就是极大匹配，最大匹配一定是极大匹配。 如果所有点都被匹配了，那么这个匹配是完美匹配。如果在一个匹配中只有一个点不被匹配，那么该匹配为准完美匹配。 对于一个匹配 MMM，若一条路径以非匹配点为起点，每相邻两条边中的一条在匹配中而另一条不在匹配中，那么这条路径称为交替路径；一条非匹配点终止的交替路径称为增广路径。 点覆盖 如果所有边都至少有一个端点在这个点集中，那么这个点集被称为点覆盖集。 点覆盖集一定是支配集，但是极小点覆盖集不一定是极小支配集（考虑一个三元环）。 点覆盖集拥有以下性质： 一个点集是点覆盖的充要条件是其补集是独立集。 一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。 边覆盖 当前边集满足任何一个点都至少是其中一条边的一个端点，那么这个边集称为边覆盖集。 如果知道了最大匹配，那么将所有非匹配点都连一条边加入最大匹配，那么就得到了一个最小边覆盖。同理，如果知道了最小边覆盖，那么将有公共点的边删去到只剩一条就得到了最大匹配。 团 一个图的子点集 V′VV′ 中任意两个不同的顶点都相邻，则称 V′VV′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 求解一个图的最大团是 NPH 的，可以使用最大团搜索算法（在暴力枚举的基础上加一个不可能成为答案的最优性剪枝）来解决规模较小的图的问题。 例题 你可能会问：这里为什么有题呢？嗯，主要是建立在图结构上的一些奇奇怪怪的问题。 刷基础 I [3rd ucup s8] Challenge Matrix Multiplication Portal。考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。代码。 [CF1810E] Monsters Portal. 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。代码。"},{"title":"生成树问题","path":"/wiki/oi-note/5-2.html","content":"例题 刷基础 [4th ucup s1] Yet Another MST Problem Portal. 仿照 Kruskal 算法的流程，按照边权从小到大考虑，找不存在 mexmexmex 的区间，将它们合并。注意到合并后得到的新区间可以视作两区间的并集，因此直接做即可。代码。"},{"title":"状态设计","path":"/wiki/oi-note/6-1.html","content":"动态规划是 OI 最重要的部分之一。从学习与做题的角度来说，主要分为设计状态与优化两部分。其中前者更多的是做题和总结方法与套路，甚至需要一定的灵感；而后者相对吃经验。 值得注意的是，很多题目都要求我们在设计算法以前先将题目进行一定的转化，从而将一个不熟悉的模型转化为我们更容易把握的模型。这一点在动态规划的题目中体现的尤为明显。 在阅读本文之前，你应该对动态规划有基本的了解。 线性 DP 在线性结构上枚举每一维度进行转移的 DP。 [CF1810G] The Maximum Prefix。较复杂，见原题面。 直接做怎么做？设 fi,j,kf_{i,j,k}fi,j,k​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后枚举填什么刷表转移对于每个状态是 O(1)O(1)O(1) 的，虽然能做，但是状态数炸了。 需要合并无效状态。同时记录前缀和和最大前缀和有些冗余，从这里入手。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响，这时可以直接确定排除掉这段后缀的前缀的答案，也就是题目所求。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案，答案是 fi,0f_{i,0}fi,0​。那么转移： 如果 j0j0j0，可以以 pip_ipi​ 的系数（第 i+1i+1i+1 位填 111）转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数（第 i+1i+1i+1 位填 −1-1−1）转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 如果 j=0j=0j=0，那么第 i+1i+1i+1 位一定是 −1-1−1，此时可以转移到 fi+1,0f_{i+1,0}fi+1,0​ 和 fi+1,1f_{i+1,1}fi+1,1​。 代码。 背包 背包的变种很多，且都比较简单。基本模型：01 背包、完全背包、多重背包、分组背包、方案数背包的撤回（将转移的东西减去即可）。 区间 DP 图上 DP 状压 DP 与轮廓线 DP 动态 DP 其它 DP 一些杂项内容 插入法 数位 DP 一般的数位 DP 直接采用记忆化搜索实现即可。 手机号码，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64;int num[15];int f[11][11][11][2][2][2];i64 dp(int p, int p1, int p2, bool unlim, bool d, bool _4, bool _8) if (_4 _8) return 0; if (p == 0) return d; if (unlim f[p][p1][p2][d][_4][_8] != -1) return f[p][p1][p2][d][_4][_8]; i64 res = 0; int mx = unlim ? 9 : num[p]; for (int i = 0; i = mx; ++i) res += dp(p - 1, i, p1, unlim || (i mx), d || (i == p1 i == p2), _4 || (i == 4), _8 || (i == 8)); if (unlim) f[p][p1][p2][d][_4][_8] = res; return res;i64 calc(i64 n) memset(f, 0xff, sizeof f); for (int i = 1; i = 11; ++i, n /= 10) num[i] = n % 10; i64 res = 0; for (int i = 1; i = num[11]; ++i) res += dp(10, i, -1, i num[11], 0, i == 4, i == 8); return res;int main(void) i64 l, r; cin l r; cout calc(r) - calc(l - 1) ; return 0; 例题 刷基础 1 只有 NOIP 难度。 [CSP-S 2024] 染色 Portal. 设 fif_ifi​ 代表考虑前 iii 位的答案。只有 lstailst_{a_i}lstai​​ 可以与 aia_iai​ 匹配，如果要匹配，中间一大段都要染成同一个颜色，计算这一段有多少贡献，从 flstai+1f_{lst_{a_i} + 1}flstai​​+1​ 转移过来。 记录前缀某一段的贡献即可快速计算任意一段有多少贡献。代码。 刷提升 1 比较有趣。 [Ptz 2020 Summer Day4] Ternary String Counting Portal. O(n4)O(n^4)O(n4) 直接 fi,x,y,zf_{i,x,y,z}fi,x,y,z​ 记录每一个字符出现的位置，O(n3)O(n^3)O(n3) 记录前两个不同字符的出现位置。都需要前缀和优化。 状态数还是过多了，我们需要寻找一个方式简化。先把转移写出来（对于状态 f(i,j,k)f(i,j,k)f(i,j,k)，表示当前考虑到第 iii 位，与这一位不同的数字上一次出现的位置分别位 j,kj,kj,k，并且 jkjkjk）： f(i+1,i,k)←+f(i,j,k)f(i+1,i,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,k)←+f(i,j,k)； f(i+1,i,j)←+f(i,j,k)f(i+1,i,j)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,j)←+f(i,j,k)； f(i+1,j,k)←+f(i,j,k)f(i+1,j,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,j,k)←+f(i,j,k)。 再考虑题目中的限制，实际上就是限制了 dp 过程中 jjj 和 kkk 的取值范围： x=1x=1x=1，则 jljljl； x=2x=2x=2，则 j≥l,klj\\ge l,klj≥l,kl； x=3x=3x=3，则 k≥lk\\ge lk≥l。 考虑优化，看上去第一维什么都不是！将转移分为 iii​ 层，每一层的状态只能从上一层转移过来，第三个转移就是直接从上一层的对应点转移，第一二个转移是对上一层的一列和一行求和。 等价于，每次给出一个矩形，先把矩形外的值全部清零。然后还可以发现，一旦某个值被清零，那么这个值以后永远都是零。并且对于某一行来说，非零的值永远是一段连续区间，而且其位置是单调的。 双指针扫，不重复清零某个行即可。最终时间复杂度 O(n2+m)O(n^2+m)O(n2+m)。代码。"},{"title":"前置知识","path":"/wiki/oi-note/7-1.html","content":"我们记字符集为 Σ\\SigmaΣ，字符串是由若干字符集中的元素构成的序列。 字符串哈希 即序列哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 inline u64 q(u64 *f, int l, int r) return f[r] - f[l - 1] * p[r - l + 1]; 最小表示法 模板，目的是求一个循环同构的字符串的最小字典序。 #include bits/stdc++.husing namespace std;const int N = 1e7 + 5;int n;char a[N];int getmin(void) int i = 0, j = 1; while (i n j n) int k = 0; while (k n a[(i + k) % n] == a[(j + k) % n]) ++k; if (a[(i + k) % n] a[(j + k) % n]) i += k + 1; else j += k + 1; if (i == j) ++i; return min(i, j);int main(void) ios::sync_with_stdio(0); cin.tie(0); cin n a; int v = getmin(); for (int i = 0; i n; ++i) cout a[(i + v) % n]; cout ; return 0;"},{"title":"多项式乘法","path":"/wiki/oi-note/8-1.html","content":"假定你拥有高中数学基础。 复数 复数的三角形式可以表示为 a=r(cos⁡θ+isin⁡θ)a=r(\\cos\\theta + i\\sin \\theta)a=r(cosθ+isinθ)。 那么假定 a=r1(cos⁡α+isin⁡α),b=r2(cos⁡β+isin⁡β)a=r_1(\\cos\\alpha + i\\sin \\alpha),b=r_2(\\cos\\beta + i\\sin\\beta)a=r1​(cosα+isinα),b=r2​(cosβ+isinβ)，有 ab=r1r2(cos⁡αcos⁡β−sin⁡αsin⁡β+icos⁡αsin⁡β+icos⁡βsin⁡α)=r1r2(cos⁡(α+β)+isin⁡(α+β))ab=r_1 r_2(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta + i\\cos\\alpha\\sin\\beta + i\\cos\\beta\\sin\\alpha)=r_1r_2(\\cos(\\alpha + \\beta)+i\\sin(\\alpha+\\beta))ab=r1​r2​(cosαcosβ−sinαsinβ+icosαsinβ+icosβsinα)=r1​r2​(cos(α+β)+isin(α+β))，也就是说，模长相乘，辐角相加，即棣莫弗定理。 由复数的三角形式，我们画一个单位圆，以 (1,0)(1,0)(1,0) 为起点，在圆上等间距画出 nnn 个点，这样得到的 nnn 个复数便是 nnn 次单位根，转到的第一个记作 ωn\\omega_nωn​，有 ωnn=1\\omega_n^n =1ωnn​=1。 欧拉公式：eix=cos⁡x+isin⁡xe^{ix}=\\cos x + i\\sin xeix=cosx+isinx。 快速傅里叶变换 设 F(x)=∑i=0n−1ai×xiF(x)=\\sum\\limits_{i=0}^{n-1} a_i\\times x^iF(x)=i=0∑n−1​ai​×xi，那么这是多项式的系数表示法。 由拉格朗日插值可知，我们搞 nnn 个不重复的点也可以确定一个 n−1n-1n−1 次多项式，这是多项式的点值表示法。 FFT 我们现在假定（nnn 为偶数）： F1(x)=a0+a2×x+a4×x2+⋯an−2×xn/2−1F2(x)=a1+a3×x+a5×x2+⋯an−1×xn/2−1F_1(x)=a_0+a_2\\times x + a_4\\times x^2+\\cdots a_{n-2}\\times x^{n/2-1}\\\\ F_2(x)=a_1+a_3\\times x + a_5\\times x^2 +\\cdots a_{n-1}\\times x^{n/2-1} F1​(x)=a0​+a2​×x+a4​×x2+⋯an−2​×xn/2−1F2​(x)=a1​+a3​×x+a5​×x2+⋯an−1​×xn/2−1 那么 F(x)=F1(x2)+xF2(x2)F(x)=F_1(x^2)+x F_2(x^2)F(x)=F1​(x2)+xF2​(x2)。并且： F(ωnk)=F1(ωn2k)+ωnkF2(ωn2k)=F1(ωn/2k)+ωnkF2(ωn/2k)F(ωnk+n/2)=F1(ωn2k)+ωnk+n/2F2(ωn2k)=F1(ωn2k)−ωnkF2(ωn2k)\\begin{aligned} F(\\omega_n^{k})=F_1(\\omega_n^{2k})+\\omega_{n}^k F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_{n/2}^{k})+\\omega_{n}^k F_2(\\omega_{n/2}^{k}) \\end{aligned} \\\\ \\begin{aligned} F(\\omega_n^{k+n/2})=F_1(\\omega_n^{2k})+\\omega_{n}^{k+n/2} F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_n^{2k})-\\omega_{n}^{k} F_2(\\omega_n^{2k}) \\end{aligned} F(ωnk​)​=F1​(ωn2k​)+ωnk​F2​(ωn2k​)=F1​(ωn/2k​)+ωnk​F2​(ωn/2k​)​F(ωnk+n/2​)​=F1​(ωn2k​)+ωnk+n/2​F2​(ωn2k​)=F1​(ωn2k​)−ωnk​F2​(ωn2k​)​ 通过这样的方式，我们可以以 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度在已知一个多项式的系数表示时求得它的点值表示，在求出两个多项式的点值表示后，我们就可以计算 H(x)=F(x)G(x)H(x)=F(x)G(x)H(x)=F(x)G(x)，进而得到两多项式乘积的点值表示。 IFFT 我们现在要将点值表示转化为系数表示，我们现在得到了 nnn 个点 (ωni,yi=F(ωni))(\\omega_{n}^i,y_i=F(\\omega_{n}^i))(ωni​,yi​=F(ωni​))。 略。 迭代实现 void FFT(int L, Complex *f, int type) // L 表示长度, type = 1 表示 FFT, type = 0 表示 IFFT static int r[N]; for (int i = 1; i L; ++i) r[i] = (r[i 1] 1) + (i 1 ? L 1 : 0); if (i r[i]) swap(f[i], f[r[i]]); for (int d = 1; d L; d = 1) Complex wd(cos(PI / d), sin(PI / d)); // 2d 次单位根 wd.b *= type; // IFFT 单位根取倒数, 相当于沿 x 轴对称 static Complex w[N]; w[0] = Complex(1, 0); for (int j = 1; j d; ++j) w[j] = w[j - 1] * wd; // 用数组记录 0 ~ d-1 次单位根, 减少复数乘法次数 for (int i = 0; i L; i += d 1) for (int j = 0; j d; ++j) Complex x = f[i | j], y = w[j] * f[i | j | d]; f[i | j] = x + y, f[i | j | d] = x - y; if (type == -1) for (int i = 0; i L; ++i) f[i] = f[i] / L; 三次变两次优化 我们考虑 (f+gi)2=f2−g2+2fgi(f+gi)^2=f^2-g^2+2fgi(f+gi)2=f2−g2+2fgi，因此有 三次变两次。"},{"title":"拉格朗日插值","path":"/wiki/oi-note/8-4.html","content":"拉格朗日插值是沟通多项式的系数形式与点值形式的重要公式。 事实上，nnn 个点确定唯一的多项式，其最高项次数为 n−1n-1n−1。 一般形式 核心思想是利用点值的可加性。什么意思呢？ 构造一个函数 f(x)f(x)f(x) 经过 P(x1,y1),⋯P(xn,yn)P(x_1,y_1),\\cdots P(x_n,y_n)P(x1​,y1​),⋯P(xn​,yn​)，设第 iii 个点在 xxx 轴上的投影为 Pi′(xi,0)P_i^{\\prime}(x_i,0)Pi′​(xi​,0)。考虑构造 nnn 个函数，使得 fi(x)f_i(x)fi​(x) 的图像经过 {Pj′(xj,0),(j≠i)Pi(xi,yi)\\begin{cases}P_j^{\\prime}(x_j,0),(j eq i)\\\\P_i(x_i,y_i)\\end{cases}{Pj′​(xj​,0),(j=i)Pi​(xi​,yi​)​，则 f(x)=∑i=1nfi(x)f(x)=\\sum_{i=1}^{n}f_i(x)f(x)=∑i=1n​fi​(x)。 设 fi(x)=a∏j≠i(x−xj)f_i(x)=a\\prod_{j e i}(x-x_j)fi​(x)=a∏j=i​(x−xj​)，然后将 PiP_iPi​ 的坐标代入求出 a=yi∏j≠i(xi−xj)a=\\cfrac{y_i}{\\prod_{j e i}(x_i-x_j)}a=∏j=i​(xi​−xj​)yi​​，进而导出： f(k)=∑i=1nyi∏i≠jk−xjxi−xjf(k)=\\sum_{i=1}^n y_i\\prod_{i e j}\\frac{k-x_j}{x_i-x_j} f(k)=i=1∑n​yi​i=j∏​xi​−xj​k−xj​​ 这就是拉格朗日插值表达式。 如果要求出系数，用 O(n2)O(n^2)O(n2) 卷出 F(x)=∏i=1n(x−xi)F(x)=\\prod_{i=1}^n (x-x_i)F(x)=∏i=1n​(x−xi​)，然后对于每个 iii 暴力将 FFF 除掉 x−xix-x_ix−xi​ 算出 F(x)x−xi\\cfrac{F(x)}{x-x_i}x−xi​F(x)​ 的各项系数，再乘 yi∏j≠ixi−xj\\cfrac{y_i}{\\prod_{j e i}{x_i-x_j}}∏j=i​xi​−xj​yi​​ 即可得到 fif_ifi​ 的各项系数，加起来即可。时间复杂度为 O(n2)O(n^2)O(n2)。 #include iostream#include cstdiousing namespace std;const int MOD = 998244353;int poww(int a, int b) int res = 1; for (; b; b = 1, a = 1ll * a * a % MOD) if (b 1) res = 1ll * res * a % MOD; return res;int n, k;int x[2005], y[2005];int main(void) scanf(%d%d, n, k); for (int i = 1; i = n; ++i) scanf(%d%d, x + i, y + i); int ans = 0; for (int i = 1; i = n; ++i) int s1 = y[i], s2 = 1; for (int j = 1; j = n; ++j) if (i != j) s1 = 1ll * s1 * (k - x[j]) % MOD, s2 = 1ll * s2 * (x[i] - x[j]) % MOD; ans = (ans + 1ll * s1 * poww(s2, MOD - 2)) % MOD; printf(%d , (ans % MOD + MOD) % MOD); return 0;"},{"title":"正整数中的数论","path":"/wiki/oi-note/9-1.html","content":"主要是针对素数的研究。 素数与合数 如果一个数 x(x∈N)x(x\\in\\mathbb{N})x(x∈N) 的约数仅有 111 和它本身，那么就称 xxx 是质数（素数），特别地，000 和 111 不是质数，如果一个自然数不是质数，他就是合数。 可以用线性筛在 O(n)O(n)O(n) 的时间内筛出所有质数，用 O(r+(r−l+1)log⁡(r−l+1))O(\\sqrt{r}+(r-l+1)\\log(r-l+1))O(r​+(r−l+1)log(r−l+1)) 的时间筛出区间内的所有质数。 ppp 进赋值序列是刻画正整数的重要方式。可以将正整数表示到 ppp 维空间上。 例题 刷提升 1 [TTPC2022] Many Products Portal. 肯定先把 MMM 质因数分解"},{"title":"模意义下的数论","path":"/wiki/oi-note/9-2.html","content":"基础知识 拉格朗日定理：在模 ppp 意义下，最高次项系数非 000 的 nnn 次多项式至多有 nnn 个根。 线性同余方程组 可以使用 CRT 解决模数互质的情况，exCRT 解决模数不互质的情况。 {x≡a1(modm1)x≡a2(modm2)⋯x≡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} ⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋯x≡a3​(modm3​)​ 模数互质 设 M=∏i=1nmi,Mi=m÷miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=∏i=1n​mi​,Mi​=m÷mi​，tit_iti​ 是线性同余方程 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​) 的一个解，也就是说 tit_iti​ 是 MiM_iMi​ 模 mim_imi​ 的逆元（显然 Mi⊥miM_i \\perp m_iMi​⊥mi​ 当且仅当 mim_imi​ 两两互质），那么 x=∑i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=∑i=1n​ai​Mi​ti​+kM，最小非负整数解需要求 ∑i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod M∑i=1n​ai​Mi​ti​modM。 i64 CRT(void) // x === a[i] (mod m[i]) i64 ans = 0, x; for (int i = 1; i = n; ++i) M[i] = mm / m[i]; t[i] = inv(M[i], m[i]); ans = (ans + a[i] * M[i] * t[i]) % mm; return (ans % mm + mm) % mm; 模数不互质 考虑如何合并两个方程组。我们先假定一定可以合并，然后看看什么时候合并之后的解是 ∅\\varnothing∅。 假设我们有： {x≡a(modA)x≡b(modB)\\begin{cases} x\\equiv a \\pmod A\\\\ x\\equiv b \\pmod B \\end{cases} {x≡a(modA)x≡b(modB)​ 那么 x=Ak1+a=Bk2+bx=Ak_1+a=Bk_2+bx=Ak1​+a=Bk2​+b，不难使用 exgcd 求出一组合法的 k1,k2k_1,k_2k1​,k2​，则通解为： K1=k1+t×Bgcd⁡(A,B)K2=k2−t×Agcd⁡(A,B)K_1=k_1+t\\times \\frac{B}{\\gcd(A,B)}\\\\ K_2=k_2-t\\times \\frac{A}{\\gcd(A,B)} K1​=k1​+t×gcd(A,B)B​K2​=k2​−t×gcd(A,B)A​ 则 x=A(k1+t×Bgcd⁡(A,B))+a=Ak1+t×lcm⁡(A,B)+ax=A(k_1+t\\times \\frac{B}{\\gcd(A,B)})+a=Ak_1+t\\times \\operatorname{lcm}(A,B)+ax=A(k1​+t×gcd(A,B)B​)+a=Ak1​+t×lcm(A,B)+a，也就是： x≡Ak1+a(modlcm⁡(A,B))x\\equiv Ak_1+a \\pmod{\\operatorname{lcm}(A,B)} x≡Ak1​+a(modlcm(A,B)) i64 exCRT(void) // x === A[i] (mod B[i]) i64 A = 1; LL a = 0; // M 为当前合并的模数，ans 为当前答案 for (int i = 1; i = n; ++i) i64 b = ::A[i], B = ::B[i], x, y, c = b - a; i64 g = exgcd(A, B, x, y); if (c % g != 0) return -1; a = A * ((LL)x * (c / g)) + a; A = A / g * B; a %= A; return (a + A) % A;"},{"title":"欢迎来到 NOI 一轮复习笔记","path":"/wiki/oi-note/index.html","content":"这是什么 原为不知名菜狗 OIer james1BadCreeper 在高二备战 NOI2024 时书写的笔记，现在他要上大学了，于是重新整理并完善了这些内容。 当时的想法很美好，但是受限于水平和执行力，很多内容都没能完成。现在重新将其拾起，能完成多少是多少了。 怎样使用 受限于作者的水平，完全依照本笔记来学习是不妥的。需要学会在网上查找更多的参考文章和向大佬提问。阅读本笔记时要保持警惕，如果发现错误，请及时通过评论区告知笔者，谢谢您的支持。 但是笔者认为这些笔记的选题是很有价值的。如果你在学习对应知识点的时候不知道做什么题，不妨看一看本笔记。 通用规则 以下是笔记的一些符号的含义，与一些不说明的规则： 题目前的星号： *： 不错的题目； **： 相当不错的题目。 P 打头的题号默认是洛谷主题库。"}]