[{"title":"继续寻找人生的下一块拼图","path":"/posts/57c4317c/","content":"图片来源：高考之后人生第一次打凋灵风暴，图为准备进行第二次共生体战以获取用于制作恐怖炸弹的指令附魔书。 令人迷茫的现状 你应该知道我位于辽宁省，昨天查完 2025 年高考的分数。和我的估分差不多，但这个结果也确实不能令人满意。按照曾经的标准就是“没学上了”。 我可以说我拆括号拆错（你可以简单的理解为我计算出了 2(x+3)=2x+32(x+3)=2x+32(x+3)=2x+3）丢了 101010 分很糖，也可以说少刷 505050 套数学卷数学也是这个分，省下来的时间去学物理显然更赚。但不管怎样高考已经结束，复读也是不可能的。只能祝愿还没高考的同学不要犯糖 动力源于创作，创作源于生活"},{"title":"CodeTON Round 4 题解","path":"/posts/4ded5892/","content":"避雷：H 我不会。 随便写写吧：https://codeforces.com/contest/1810. 终于更完了，james1 你也是够懒的。 A. Beautiful Sequence 如果有一个数满足 ai≥ia_i\\geq iai​≥i 即可。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n, flag = 0; cin n; for (int i = 1, x; i = n; ++i) cin x; if (x = i) flag = 1; cout (flag ? YES : NO );int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; B. Candies 不难发现决策是唯一的。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n; cin n; vectorint ans; while (n % 2 n 1) if ((n 1) 1) ans.push_back(2), n = 1; else ans.push_back(1), n = (n 1) + 1; if (n != 1) return cout -1 , void(); reverse(ans.begin(), ans.end()); cout ans.size() ; for (int i : ans) cout i ; cout ;int main(void) ios::sync_with_stdio(0); int T = 1; cin T; while (T--) solve(); return 0; C. Make It Permutation 枚举结束的数字即可。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 1e5 + 5;int n, c, d;int a[N];void solve(void) cin n c d; for (int i = 1; i = n; ++i) cin a[i]; sort(a + 1, a + n + 1); int m = unique(a + 1, a + n + 1) - (a + 1); i64 ans = 1ll * m * c + d; for (int i = 1; i = m; ++i) ans = min(ans, 1ll * (a[i] - i) * d + 1ll * (m - i) * c); cout ans + 1ll * c * (n - m) ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; D. Climbing the Tree 蜗牛爬水井是小学时非常常见的脑筋急转弯题，要注意蜗牛可能会直接爬出水井。 对于本题来说，我们需要用更为一般的代数手段，也就是不等式组描述这个问题。给条件相当于要解出一组取值范围看能否与之前的合并，问能否爬出相当于要对于当前的高度取值范围 [L,R][L,R][L,R]，分别看高度为 L,RL,RL,R 时所需的爬出天数（显然这个函数是单调递增的）。 先来看第一个问题。什么时候高度最大？第 nnn 天需要爬 aaa 时，即 (n−1)×(a−b)+a(n-1)\\times (a-b) + a(n−1)×(a−b)+a。最小呢？第 n−1n-1n−1 天白天爬完之后还剩 111 的高度没有爬完，以至于需要第 nnn 天接着爬。 再来看第二个问题。不妨设高度为 hhh，那么要满足 an−b(n−1)≥han - b(n-1) \\geq han−b(n−1)≥h，将 nnn 解出向上取整即可。 有点小细节但不多，比如天数为 111 需要特判之类的。样例非常友好，写挂了全能调出来。 #include bits/stdc++.husing namespace std;typedef long long i64;i64 calc(i64 h, int a, int b) if (a = h) return 1; // (a - b)n = h - b return (h - b + a - b - 1) / (a - b);void solve(void) int q; cin q; i64 L = 1, R = 2e18; while (q--) int op, a, b; i64 n; cin op a b; if (op == 1) cin n; i64 r = (n - 1) * (a - b) + a; i64 l = (n == 1 ? 1 : (n - 2) * (a - b) + a + 1); if (l R || r L) cout 0 ; else cout 1 ; L = max(L, l); R = min(R, r); else // cerr L R E$TD ; i64 n1 = calc(L, a, b), n2 = calc(R, a, b); if (n1 != n2) cout -1 ; else cout n1 ; cout ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; E. Monsters G. The Maximum Prefix 直接做怎么做？设 fif_ifi​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后刷表转移对于每个状态是 O(1)O(1)O(1) 的，炸了。 需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。 #include bits/stdc++.husing namespace std;typedef long long i64;const int P = 1000000007;const int N = 5e3 + 5;inline int poww(int a, int b) int r = 1; for (; b; b = 1, a = 1ll * a * a % P) if (b 1) r = 1ll * r * a % P; return r;inline int inv(int x) return poww(x, P - 2); inline void add(int x, i64 k) x = (x + k) % P; int n;int p[N];int f[N][N];void solve(void) cin n; for (int i = 1; i = n; ++i) int x, y; cin x y; p[i] = 1ll * x * inv(y) % P; for (int i = 0; i = n + 2; ++i) for (int j = 0; j = n + 2; ++j) f[i][j] = 0; for (int i = 0; i = n; ++i) cin f[0][i]; for (int i = 0; i n; ++i) for (int j = 0; j = n; ++j) if (f[i][j]) // i + 1 位置填 1 if (j) add(f[i + 1][j - 1], 1ll * p[i + 1] * f[i][j]); // i + 1 位置填 -1 add(f[i + 1][j + 1], 1ll * (1 + P - p[i + 1]) * f[i][j]); if (j == 0) add(f[i + 1][0], 1ll * (1 + P - p[i + 1]) * f[i][j]); for (int i = 1; i = n; ++i) cout f[i][0] [i == n];int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0;","tags":["算法竞赛","Codeforces"]},{"title":"我回来了","path":"/posts/a5aedc5a/","content":"搬家了！这里是新博客。以前的内容会逐步搬迁。 这里主要测试一些内容，回归文章一段时间之后会写。 公式部分 ap−1≡1(modp) a^{p-1}\\equiv 1 \\pmod p ap−1≡1(modp) ∇⋅D=ρf∇⋅B=0∇×E=−∂B∂t∇×H=Jf+∂D∂t\\begin{array}{l} abla \\cdot \\mathbf{D} =\\rho _f \\\\ abla \\cdot \\mathbf{B} = 0 \\\\ abla \\times \\mathbf{E} = -\\cfrac{\\partial \\mathbf{B}}{\\partial t } \\\\ abla \\times \\mathbf{H} = \\mathbf{J}_f + \\cfrac{\\partial \\mathbf{D}}{\\partial t } \\end{array} ∇⋅D=ρf​∇⋅B=0∇×E=−∂t∂B​∇×H=Jf​+∂t∂D​​ 代码部分 这里测试一些代码。 cpp #include bits/stdc++.husing namespace std;int main(void) cout Hello World! ; return 0; yaml stellar: version: 1.30.1 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar main_css: /css/main.css main_js: /js/main.js"},{"title":"探索者笔记","path":"/explore/index/index.html","content":"你若问我这里是什么，只是 iznomia 无聊时写的一点文字而已啦~ 如果你找到了某些共鸣，欢迎在评论区与我交流~"},{"title":"探索者笔记","path":"/explore/music/index.html","content":"由于这些歌风格可能非常多元，故以下排名不分先后。 1. かめりあ —— #1f1e33 (Another long “#ant1p01e” version) #1f1e33 一切的一切，真的只是命中注定吗…… 2. 华晨宇 —— 不重逢 不重逢 “不要懂错了没错，只要懂有用没用。” 3. void(Mournfinale) feat. 星熊南巫 —— Testify Testify 你所犯下的罪孽，是可以偿还的吗？！ 宿命岂是凡人可以见证？ 4. Mili —— world.execute(me); world.execute(me); 如果人工智能拥有了情感，你会爱上 TA 吗？ 5. 华晨宇 —— 虚幻与现实 虚幻与现实 既没能消除无知，也没能学会善良。 6. 周深 —— 人是_ “弹指间湮灭我，但命运打不败活着。” 7. 藤末樹 feat. Cereus —— 絶対零度 絶対零度 真正的绝对零度——世界上最为悲凉的感觉莫过于此。 8. Globus —— The Promise 此路直至彼岸处，那是崭新的明天。 不太会评价，但非常喜欢。绝对的史诗感，但最后却是拨云见日。 相比某些我也很喜欢的史诗音乐没有叠的很厚重，但是听的真的很感动~ 9. 10. 打打だいず、月乃 —— 彼方へ、名もなき海辺より 彼方へ、名もなき海辺より 不太会评价，但是真的好喜欢！！"},{"title":"二分与倍增","path":"/wiki/oi-note/1-1.html","content":"两者的本质均基于单调性，寻找题目中具有单调性的函数关系，然后施展二分或者倍增。二分答案可以用来解决分数规划问题，三分法可以求解单峰/谷函数。同时，二分上界不确定的内容的最佳方式是倍增，通过先倍增到上界，再倍增答案来解决。 二分 一种二分写法 通过 l = r 之类的方法的二分笔者认为有些过于诡异，这里给出我自己的二分实现方式（我记得当时是在 B 站学的，但是出自哪个视频忘了）。 Luogu P2249int L = 0, R = n + 1;while (L + 1 != R) int mid = L + R 1; if (a[mid] = x) R = mid; else L = mid;if (a[R] == x) cout R ;else cout -1 ; 01 分数规划 用来求一个分式的极值，也就求一组 wi={0,1}w_i=\\{0,1\\}wi​={0,1}，最大化或者最小化： ∑ai×wi∑bi×wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} ∑bi​×wi​∑ai​×wi​​ 我们一般使用二分答案来解决这个问题。以最大值为例： ∑ai×wi∑bi×wimid⟹∑ai×wi−mid×∑bi×wi0⟹∑wi(ai−mid×bi)0\\begin{aligned} \\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}mid\\\\ \\Longrightarrow \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i 0\\\\ \\Longrightarrow \\sum w_i(a_i-mid\\times b_i)0 \\end{aligned} ⟹⟹​∑bi​×wi​∑ai​×wi​​mid∑ai​×wi​−mid×∑bi​×wi​0∑wi​(ai​−mid×bi​)0​ 于是排序即可确定 wiw_iwi​ 的值。有些时候会限制 ∑bi×wi\\sum b_i\\times w_i∑bi​×wi​ 的最小值之类的，例题，这时使用背包求解即可。 三分法 三分法可以用于求解单峰函数的极值点。对于常规的三分写法不再赘述，但值得注意的是，对于定义域为整数的实际问题，它们的答案可能真的是单峰的，但此时由于其不满足函数的连续性，会存在一大段平的区间，然后三分就炸了（鬼知道极值点在哪，你需要 O(n)O(n)O(n) 扫过去）。 不要错误的将某些函数视作可以三分，更不要将单峰函数视作凸函数而对导函数二分。单峰的证明是比较困难的，而且有时对于非单峰的问题也比较难找到反例（廊桥分配），要根据实际情况判断。 Luogu P1883 画图可知，两个单谷函数（一次函数的谷点视作在无穷远处）取 max⁡\\maxmax 后，得到的新函数仍然是单谷函数，因此直接三分即可。 但很阴的是，这题要求极值而不是极值点，精度会被 bbb 吃掉，因此 eps 要取小。 double L = 0, R = 1000;while (L + eps R) double Lmid = (L + R) / 2; double Rmid = (Lmid + R) / 2; if (calcF(Lmid) calcF(Rmid)) L = Lmid; else R = Rmid; wqs 二分 O(log⁡n)O(\\log n)O(logn) 倍增 ST 表 ST 表使用倍增结构来实现，支持在末尾插入一个数。大概长这样： f[0][n] = a[n]; // The new Nfor (int j = 1; 1 j = n; ++j) f[j][n - (1 j) + 1] = max(f[j - 1][n - (1 j) + 1], f[j - 1][n - (1 j - 1) + 1]); 在开头插入亦同理。 例题 ** [CF1764G] Doremy’s Perfect DS Class G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pnmidp_n midpn​mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pnmid′p_nmidpn​mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点浪费，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。代码。"},{"title":"分治","path":"/wiki/oi-note/1-2.html","content":"分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 仿照分治的结构可以衍生出一大堆静态分治算法。"},{"title":"随机化算法","path":"/wiki/oi-note/1-3.html","content":"有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据满足一定条件，否则会 TLE 或者超交互次数。 生成随机数mt19937_64 Rnd(time(0));int rndint(int l, int r) return uniform_int_distribution(l, r)(Rnd);double rnddb(int l, int r) return uniform_real_distribution(l, r)(Rnd);"},{"title":"树状数组","path":"/wiki/oi-note/2-1.html","content":"又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 模板，区间和我们可以用前缀和相减来求解，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) for (; x = n; x += x -x) C[x] += k; i64 sum(int x) i64 r = 0; for (; x; x -= x -x) r += C[x]; return r; int main(void) scanf(%d%d, n, m); for (int i = 1; i = n; ++i) scanf(%d, a + i), add(i, a[i]); while (m--) int op, x, y; scanf(%d%d%d, op, x, y); if (op == 1) add(x, y); else printf(%lld , sum(y) - sum(x - 1)); return 0;"},{"title":"组合计数","path":"/wiki/oi-note/3-1.html","content":"到处都能见到它的身影，它是一切数数题的基础。 概念基础 基本定义与一些常见公式与方法。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​，有 Anm=n!(n−m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anm​=(n−m)!n!​。 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。置换中形成一个环的称为置换环，对于大小为 1,21,21,2 的置换环，原排列和置换显然是一样的。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 (nm)\\binom n m(mn​)。组合数同时也是二项式系数，当 m0m0m0 时，组合数没有定义。 (nm)=n!(n−m)!m!=nm‾m!(nm)=(n−1m)+(n−1m−1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mn​)=(n−m)!m!n!​=m!nm​​(mn​)=(mn−1​)+(m−1n−1​) 组合数有以下性质 / 恒等式： (nm)=(nn−m)\\dbinom n m = \\dbinom n {n - m}(mn​)=(n−mn​)； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)，常被用来递推组合数； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)； 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1。注意这个东西是很特殊的完整一行，一般的行求和是无法快速计算的。它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 Lucas 定理。若 ppp 是质数，则 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp，常用于 ppp 较小的情况。 组合数奇偶性公式。(nm)≡1(mod2) ⟺ n m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\ \\ m=m(mn​)≡1(mod2)⟺n m=m，使用 Lucas 定理来证明，需保证不出现 (01)\\dbinom{0}{1}(10​)。 Kummer 定理。(n+mn)\\dbinom{n+m}{n}(nn+m​) 中质因子 ppp 的次数为 n+mn+mn+m 在计算时 ppp 进制意义下的进位次数，等价于 (nm)\\dbinom n m(mn​) 中质因子 ppp 的次数等于在计算 n−mn-mn−m 时 ppp 进制意义下的借位次数。其中 ppp 是素数。 上指标翻转。(nk)=(−1)k(k−n−1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(kn​)=(−1)k(kk−n−1​)。 多重组合数。是指先选 n1n_1n1​，再选 n2n_2n2​，以此类推。有（∑ni=n\\sum n_i = n∑ni​=n）： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 组合方法。在小学学过一些常用的组合方法。 捆绑法插空法插板法nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。"},{"title":"平衡树","path":"/wiki/oi-note/2-3.html","content":"平衡树是一种二叉数据结构，满足所谓的“BST 性质”： 空树是 BST； 若 BST 的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值； 若 BST 的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值； BST 的左右子树均为 BST； BST 集合是满足 1、2、3、4 的最小二叉树集。 笔者通常使用 FHQ 来实现平衡树。"},{"title":"图的相关概念","path":"/wiki/oi-note/4-1.html","content":"一张图 GGG 由点集 VVV 和边集 EEE 构成。我们用 d(v)d(v)d(v) 代表节点 vvv 的度数，如果 d(v)=∣V∣−1d(v)=|V|-1d(v)=∣V∣−1，则称 vvv 为支配点。如果每个点的度数都是 kkk，则该图为 k−k-k−正则图。 子图 对一张图 G=(V,E)G = (V, E)G=(V,E)，若存在另一张图 H=(V′,E′)H = (V, E)H=(V′,E′) 满足 V′⊆VV \\subseteq VV′⊆V 且 E′⊆EE \\subseteq EE′⊆E，则称 HHH 是 GGG 的子图，记作 H⊆GH \\subseteq GH⊆G。 若对 H⊆GH \\subseteq GH⊆G，满足 ∀u,v∈V′\\forall u, v \\in V∀u,v∈V′，只要 (u,v)∈E(u, v) \\in E(u,v)∈E，均有 (u,v)∈E′(u, v) \\in E(u,v)∈E′，则称 HHH 是 GGG 的导出子图。点集为 V′(V′⊆V)V(V \\subseteq V)V′(V′⊆V) 的导出子图称为 V′VV′ 导出的子图，记作 G[V′]G \\left[ V \\right]G[V′]。 若 H⊆GH \\subseteq GH⊆G 满足 V′=VV = VV′=V，则称 HHH 为 GGG 的生成子图/支撑子图。 如果一张无向图 GGG 的某个生成子图 FFF 为 k−k-k−正则图，则称 FFF 为 GGG 的一个 k−k-k−因子。 如果有向图 G=(V,E)G = (V, E)G=(V,E) 的导出子图 H=G[V∗]H = G \\left[ V^\\ast \\right]H=G[V∗] 满足 ∀v∈V∗,(v,u)∈E\\forall v \\in V^\\ast, (v, u) \\in E∀v∈V∗,(v,u)∈E，有 u∈V∗u \\in V^\\astu∈V∗，则称 HHH 为 GGG 的一个闭合子图。也就是说，图内部是闭合的，不存在一个点在导出子图内，可以通过原图的一条边连到一个不在导出子图内的点。 特殊的图 对于无向简单图，所有本来在图上的边都不在，本来不在的都在，那么这个图就是原无向图的补图。 对于有向图，每条边的方向取反，得到的图就是原图的反图。 特殊集合 一些特殊的点和边的集合有着特殊的意义，这里我们介绍一些常见的。 支配集 对于无向图，如果一个点集的点可以连接到原图的所有点，那么这个点集为原图的支配集。 最小支配集是 NPH 的，我们通常使用 O(2n)O(2^n)O(2n) 的枚举算法来求解支配集。 独立集 就是任意两点不相邻的点集。对于树和二分图我们有高效做法，但是一般图上，这个问题是 NPH 的。 匹配 对于图 G=(V,E)G=(V,E)G=(V,E)，若 E′∈EE\\in EE′∈E 且 E′EE′ 中任意两条边都没有公共端点，且 E′EE′ 中没有自环，那么 E′EE′ 是 GGG 的一个匹配，也称为边独立集。如果一个点被匹配的边连接了，那么它就是被匹配的，否则就是不被匹配的。 边数最多的称为最大匹配，如果边带权，那么权重之和最大的匹配称为图的最大权匹配。 如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配就是极大匹配，最大匹配一定是极大匹配。 如果所有点都被匹配了，那么这个匹配是完美匹配。如果在一个匹配中只有一个点不被匹配，那么该匹配为准完美匹配。 对于一个匹配 MMM，若一条路径以非匹配点为起点，每相邻两条边中的一条在匹配中而另一条不在匹配中，那么这条路径称为交替路径；一条非匹配点终止的交替路径称为增广路径。 点覆盖 如果所有边都至少有一个端点在这个点集中，那么这个点集被称为点覆盖集。 点覆盖集一定是支配集，但是极小点覆盖集不一定是极小支配集（考虑一个三元环）。 点覆盖集拥有以下性质： 一个点集是点覆盖的充要条件是其补集是独立集。 一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。 边覆盖 当前边集满足任何一个点都至少是其中一条边的一个端点，那么这个边集称为边覆盖集。 如果知道了最大匹配，那么将所有非匹配点都连一条边加入最大匹配，那么就得到了一个最小边覆盖。同理，如果知道了最小边覆盖，那么将有公共点的边删去到只剩一条就得到了最大匹配。 团 一个图的子点集 V′VV′ 中任意两个不同的顶点都相邻，则称 V′VV′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 求解一个图的最大团是 NPH 的，可以使用最大团搜索算法（在暴力枚举的基础上加一个不可能成为答案的最优性剪枝）来解决规模较小的图的问题。"},{"title":"状态设计","path":"/wiki/oi-note/5-1.html","content":"动态规划是 OI 最重要的部分之一。从学习与做题的角度来说，主要分为设计状态与优化两部分。其中前者更多的是做题和总结方法与套路，甚至需要一定的灵感；而后者相对吃经验。 值得注意的是，很多题目都要求我们在设计算法以前先将题目进行一定的转化，从而将一个不熟悉的模型转化为我们更容易把握的模型。这一点在动态规划的题目中体现的尤为明显。 在阅读本文之前，你应该对动态规划有基本的了解。 线性 DP 在线性结构上枚举每一维度进行转移的 DP。 [CF1810G] The Maximum Prefix。较复杂，见原题面。 直接做怎么做？设 fif_ifi​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后刷表转移对于每个状态是 O(1)O(1)O(1) 的，炸了。 需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。代码。 背包 背包的变种很多，且都比较简单。基本模型：01 背包、完全背包、多重背包、分组背包、方案数背包的撤回（将转移的东西减去即可）。 区间 DP 图上 DP 状压 DP 与轮廓线 DP 动态 DP 其它 DP 一些杂项内容 插入法 数位 DP 例题"},{"title":"前置知识","path":"/wiki/oi-note/6-1.html","content":"我们记字符集为 Σ\\SigmaΣ，字符串是由若干字符集中的元素构成的序列。 字符串哈希 即序列哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 inline u64 q(u64 *f, int l, int r) return f[r] - f[l - 1] * p[r - l + 1];"},{"title":"概述","path":"/wiki/oi-note/7-1.html","content":"广义来说，所有问题都属于构造类问题——它们都需要构造解（bushi）。 此类题目中也有较多 ad-hoc 题，需要我们从多个角度思考，发挥自己的想象力。 我们不能对于每道题都枚举所有套路逐一试错，而需要具体情况具体分析。不应当完全依靠猜或试找出来，而是主要通过线索推断出来。它们包括但不限于： 特殊的题目条件、数据范围 特殊性质、部分分 必然性、充分性 模型的观察与转化 打表的结果 注意在做此类题目时，要避免自己陷入思维死局。"},{"title":"欢迎来到 NOI 一轮复习笔记","path":"/wiki/oi-note/index.html","content":"这是什么 原为不知名菜狗 OIer james1BadCreeper 在高二备战 NOI2024 时书写的笔记，现在他要上大学了，于是重新整理并完善了这些内容。 当时的想法很美好，但是受限于水平和执行力，很多内容都没能完成。现在重新将其拾起，能完成多少是多少了。 怎样使用 受限于作者的水平，完全依照本笔记来学习是不妥的。需要学会在网上查找更多的参考文章和向大佬提问。阅读本笔记时要保持警惕，如果发现错误，请及时通过评论区告知笔者，谢谢您的支持。 但是笔者认为这些笔记的选题是很有价值的。如果你在学习对应知识点的时候不知道做什么题，不妨看一看本笔记。 通用规则 以下是笔记的一些符号的含义，与一些不说明的规则： 题目前的星号： *： 不错的题目； **： 相当不错的题目。 P 打头的题号默认是洛谷主题库。"}]