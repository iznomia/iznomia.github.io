[{"title":"2025-12-06(#9)：","path":"/posts/8d6b7bc5/","content":"沉淀了一段时间了，稍微来写点算法竞赛！！ 8 [2025 Shenyang] The Bond Beyond Time 我感觉我需要提高我自己写代码的能力。代码。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025 ICPC 上海站 & Arcaea NextStage 线上观感","path":"/posts/f79d0940/","content":"你不能总是一直逃避某些事情。 总结 比赛当天早上感觉扁桃体有些发炎。 为啥能不会这个 A 呢。 O(n2klog⁡m)O(n^2k\\log m)O(n2klogm) 真的卡不过这个 E 吗，等 ucup 上了我再研究一下。 所以还是单核强度最重要。下学期还是多学习一点有用的东西吧，算法竞赛也不能断就是了，感觉会很有挑战性。 主要影响是没拿到金牌，然后没 EC 去了。有一种没进省队的空虚感。 NextStage 第一次参加这种活动，虽然是线上。 Gram 抬手好帅，削除射线好酷炫。 第一次知道 TG 是个法师，有点帅的。期待和 Laur 的新曲。 期待 Ashrount 和打打的新曲。 象征性地放个图 ak+q vs onoken，我的天哪。 我就说 Xterfusion 是个不错的曲子，你看这效果不非常好吗。 看情况确实想在寒假开始学习乐理了。 上海旅行 赛后晚上打算去外滩看看，但是地铁坐到一般发现自己的感冒其实不是很轻，早上的感觉是对的，赛时只是在硬撑罢了。 在前往外滩的路上遇到了巧克力博物馆，有巧克力造的东方明珠塔。据我观察墙壁好像也是用巧克力造的（或者只是颜色很像），有点厉害的。 在外滩使用破烂手机拍照，并未被东方明珠塔攻击。未尝试饮用蜜雪冰城。","tags":["游记"],"categories":["记录","游记"]},{"title":"2025-11-11(#8)：四重性","path":"/posts/dcc604a/","content":"LucaProject / NeLiME —— Quadruplicity 2 [ICPC 2022 Jinan R] Tower 很好猜，不想证了。 3 [ICPC 2022 Jinan R] Frozen Scoreboard 模拟。 4 [CCPC 2025 Harbin] 01 背包 猜。 5 [CCPC 2025 Harbin] 六边形翻转 猜。 6 [CCPC 2025 Harbin] 液压机 模拟。 7 [Xi’an Regional 2025] Catch the Monster Portal. 不难画出来，如果有一个点满足它有至少三个儿子，每个儿子都不是叶子，那么就完蛋了。 使用双指针维护所有的答案为 Yes 的区间，移动指针的时候稍微剪剪枝。复杂度好像是对的，不管了。代码。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-25(#7)：一遍又一遍将它全部燃烧","path":"/posts/a497f773/","content":"Onlap —— Burn [4th ucup s3] Disjoint Set Splitting 只能离线做。因此直接假设所有答案都是 111，一条一条将删除的边加回来，看什么时候图是联通的，说明删掉这之前的边都没有问题。 1 [4th ucup s3] Christmas Tree 见 NOI 一轮复习：状态设计。 [Nanjing Regional 2024] Strips 简单。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-20(#6)：能拯救他人的梦想","path":"/posts/5d67ad62/","content":"ナナツカゼ —— アリア trio https://qoj.ac/contest/2551，怎么马上就要打正赛了啊？ solo https://qoj.ac/contest/1828 B. Birthday Gift 发现不太能做，转化成删除相邻两个不同的，这样 222 就可以转化为 0,10,10,1，最后必定会删到只剩一个数的情况。 qoj14572 Mex Hex 这个条件非常奇妙，不太能 DP。但是可以维护上一个保护范围终止点的可行区间，这样下一个区间的合法范围是可以简单地更新的。 qoj4888 Decoding The Message 首先模 655356553565535 很诡异，注意到 65535=3×5×7×25765535=3\\times 5\\times 7\\times 25765535=3×5×7×257，因此对于 256256256 进制，前三个都是所有数的和（256 mod 3=1256\\bmod 3=1256mod3=1），后面这个 做点杂题，感觉这个挺杂的：2023 Multi-University Training Contest 1。 A. Hide-And-Seek Game 不是你怎么能调这么久的。 B. City Upgrading 直接 DP 就可以了。 C. Mr. Liang play Card Game 比较简单。 E. Cyclically Isomorphic 向模板库中添加了最小表示法。 I. Assertion 你在搞笑吗。 J. Easy Problem I 不是你怎么能调这么久的。 K. Easy Problem II 不是你怎么能调这么久的。 不如 Today’s Computer is very Fast. L. Play on Tree AGC017D 的换根 DP 版。 [ARC207B] Balanced Neighbors 2 先考虑 nnn 为偶数，不难想到让 iii 无法到达 n−i+1n-i+1n−i+1。构造二分图容易做到这件事情，如果 nnn 为奇数，那么 nnn 可以在两步之内走到所有点。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-10-05(#5)：不死的太阳耀斑","path":"/posts/Infinity/","content":"Ashrount —— Undying Macula 10 月 2 日体验了 Arcaea 的新主线，也是我第一次跟着更新体验主线。确实好玩好吧。 隐藏曲我就这么翻译了，感觉这么粗暴的翻译比较有史诗感。 谢谢你回应我的呼唤。 duo https://qoj.ac/contest/2539 F. Yet Another MST Problem 就你要注意到一个事情，两个区间连起来之后，新的区间相当于这两个区间的交集。 E. Coffee Shops B. Domain Compression K. Robot Construction trio https://qoj.ac/contest/1741，真补不完了啊。 E. Building a Fence 考场上就应该直接写拍子。 B. Bookshelf Tracking 注意到读书操作相当于左右两半段排序，因此直接模拟即可。 C. Painting Fences D. Function with Many Maximums F. Teleports G. Exponent Calculator I. Marks Sum 萌萌的。 K. Train Depot L. Array Spread trio https://qoj.ac/contest/1780。 我觉得我就是菜。 H. Permutation 事实证明小局部 DP，大范围按照 2/32/32/3 来划分即可。 E. Team Arrangement 我勒个直接枚举拆分数之后跑 O(n2)O(n^2)O(n2) 暴力啊。 L. Challenge Matrix Multiplication 考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。 trio https://qoj.ac/contest/1901。 我觉得需要好好训练一下。 K. Knapsack 莫名其妙的科技题，这里稍微写点东西。 如果直接那个数少然后将当前数加到某个值里是没有道理的，因为你不会使这三个数的差值变小。于是你考虑每次将两个当前三元组 (A,B,C)(A,B,C)(A,B,C) 合并，用 A+CA+CA+C 来算值，这样大概率是可以减小差值的。 最终我也是不知道真遇到这种题怎么办，感觉只能听天由命。 H. Have You Seen This Subarray? 这场为数不多的好题了，这个比赛给我的感觉非常愚人节。 相邻两个数靠在一起的时间为若干个连续段，因为交换随机，所以段数很少，询问的时候直接暴力合并段即可。 但是 nnn 小的时候不满足这一点，需要暴力哈希做掉。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-30(#4)：我却以为 终有一日 能回想起来","path":"/posts/b060879/","content":"JYOCHO —— 互いの宇宙 国庆会多更新一点，但是我还没做线性代数的标准化作业。 trio https://qoj.ac/contest/1480，红了。 J. Middle Race 假交互其实猜对了，但问题是我暴力写挂了。 但为什么会想着去硬解不等式啊。 就是你要选的尽可能接近 n(A+B+C)÷3n(A+B+C)\\div 3n(A+B+C)÷3，然后直接枚举就行了。 D. Gambler’s Ruin L. Por Una Cabeza trio https://qoj.ac/contest/1236，绿了。 A. Oops, It’s Yesterday Twice More D. Paimon Sorting H. Crystalfly I. Cloud Retainer’s Game L. Secret of Tianqiu Valley M. Windblume Festival K. Ancient Magic Circle in Teyvat 大无语题。 休息很久了，来打 CF！希望能上分！https://codeforces.com/contest/2152 妈的破防了。 E. Monotone Subsequence F. Triple Attack G. Query Jungle","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"夜行","path":"/posts/71998f63/","content":"打完了 CF，但是确实卡 F 了。手速还是需要练的啊。 然后吃了点夜宵，明天下午才有课，因此可以稍微放松一下。原本的打算是稍微玩一会儿，然后在机房睡两三个小时，等早上学校门开了再回宿舍睡觉（我宿舍在校外）。 但发生了一些意料之外的情况。我之前没有注意到机房的窗没有纱窗，便直接将其打开以便通风——这邀请了大量的蚊子进入机房做客，导致我无法入睡。 于是无事可做，扫了一辆车在校园里乱逛。夜晚给人的体感还是比较冷的，把手冻到有点发寒的程度。我尝试寻找可能出去的门（没有找到），在北门找到了没有人要的外卖（放了一天的汉堡），穿越了正在施工的医学楼，如此。 最后以在机房睡了大概半个小时，大拇指被蚊子咬了一下的结局迎来了天亮。温度仍然很低，我离开了学校。 图片 王湘浩楼 于北苑拍摄的拂晓","tags":["闲话"],"categories":["记录","闲话"]},{"title":"2025-09-22(#3)：让我们再次解答 对着那被吞噬的黑暗","path":"/posts/ec78c757/","content":"ARForest feat. Sennzai —— 星になって 队友太强了！！ https://qoj.ac/contest/2534 G. 序列与整数对 这个复杂度怎么拿不等式写出来啊qwq 多做点数据结构。由队长的建议，要补区域赛的数据结构题。 A. 整点正方形计数2 赛时队友写了一个非常诡异的做法过掉了，赛后看来想复杂了。 M. 并行计算 为啥能不去想这个题啊。 首先先把前缀和算出来，然后再减去上一个最近是 111 的位置的前缀和值，也就是 yi×siy_i\\times s_iyi​×si​ 的前缀最大值。 由于 1024=3221024=32^21024=322，因此直接将序列分块，即可比分治更优地完成前缀操作。 C. 造桥与砍树 F. 连线博弈 Fun Fact：我之前做过 SG 函数的递推式长得跟这个一样得题，但是一点瞪不出 SG 函数的规律。感谢队友神力了。 H. 教师 trio https://qoj.ac/contest/1252 也算是勉强打上金牌线了，主要是我的 I 分类讨论讨错了，我在干什么🤣 I. Linear Fractional Transformation 硬解方程，由于 c,dc,dc,d 中至多只有一个是零，分别尝试将所有数用 c,dc,dc,d 表示即可。 来打 CF，用的小号，打 Div.2，https://codeforces.com/contest/2151。 怎么 C 都不会了，还是要充满决心啊！ C. Limited Edition Shop 其实一开始想的就是对的，唉。 搞了新的小号来打 Div.3。james2StormEye！ https://codeforces.com/contest/2149 无语了，怎么能卡 F。 某些小事情：/posts/71998f63/。 补 https://qoj.ac/contest/2238。 G. 矩阵 for (int i = 1; i = n; ++i) for (int j = 1; j = n; ++j) cout j + (i - 1) * p [j == n]; pnpnpn。 trio https://qoj.ac/contest/1305 打的还可以吧。 E. Buy and Delete 被队友想出做法后遥控我写完了，然后发现这个东西很对。 唉怎么每天都有一万道题需要做。 感觉是时候寻找一些全新的可能性了，iznomia。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-09-15(#2)：漂浮于重力之上","path":"/posts/c967b560/","content":"AxR —— Levitation [EC Online 2025 II] DAG Query 我了个假 DAG 啊。 忘了拉格朗日插值怎么推的了。 有板子真的，最多三分钟。 无语了，只能说幸好没掉出前六。 solo https://qoj.ac/contest/1799 G. Game 直接模拟即可，需要等比数列求和。 L. 502 Bad Gateway 我的写法需要开 int128。 另外我推得的答案总是小 111😂，不知道为什么，可能题读错了，直接加上就好了。 D. Query on Tree K. Match 有一百万道题需要补。 trio https://qoj.ac/contest/1053 E. Identical Parity 被硬控了😭 我觉得还是需要写出 exgcd 的通解。 D. Frozen Scoreboard C. DFS Order 2 这真的比 G 简单吗😨 肯定要树形 DP，但是不难发现一个事情：关注子树内的信息是极其诡异的，因为 DFS 序只和子树外面是怎么走的有关。 G. Quick Sort 快速排序的答案是 O(nlog⁡n)O(n\\log n)O(nlogn) 级别的，只是暴力找比哨兵大 / 小的数交换到 右 / 左边很慢，搞个数据结构优化一下即可。 L. Tree Distance 加强代码能力，加强体力（以及读题能力）。学数学，做 DP，练数据结构，如果可以还需要学图论和串。 妈的干不完了，我想打金。 要不找机会 VP 一场 CF。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"2025-08-30(#1)：重新开始","path":"/posts/cfb4593d/","content":"又回来了，又能持续多久呢？ Sakuzyo —— Lost Memory CF2128D Sum of LDS 注意到以 iii 为右端点的区间的 LDS，一定可以以 iii 或者 i−1i-1i−1 结尾，然后就完成了。 做 https://qoj.ac/contest/1986 A. 删除01串 分讨。 C. 砝码 分讨。 G. 萤火虫难题 注意 111 和任何数都互质。 D. 最近公共祖先 来写简单数据结构！感觉比 H、I、J 都要简单啊。 总结一下两棵树类的问题：在一棵树上进行操作（点分治等），然后统计另一棵树上的信息。 LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。 CF2135B For the Champion 记得使用演算纸而不是 iPad。 qoj 11736 Three Arrays STL 二分记得判断二分出来的东西是否在答案区间内。 感觉 https://qoj.ac/contest/1885 很不错。 [EC Online 2025 I] Moving on the Plane 为啥不会啊。 见 NOI 一轮复习 I：杂项。","tags":["算法竞赛"],"categories":["算法竞赛","训练"]},{"title":"一场因神秘力量影响而发生的事故","path":"/posts/9b7cfc66/","content":"源于一场使用 XeLaTeX 编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。最后切换至 LuaTeX 解决了该问题。 问题概述 最近在准备假期给小朋友讲课用的课件，但是遇到了一个问题：编译 beamer 并设置全局背景时，每一页都会重复引用图片导致最终 pdf 变得很大。我查阅了曾经做过的课件（只能找到 pdf，源码已丢失），发现它们的大小是正常的。 这让人很苦恼，因为一个课件有上百页，对于一张 2MB 的背景来说，会使得这个课件膨胀至 300MB 的大小，非常的恐怖。所以这是一个继续修复的问题。 有趣的是，如果把这个膨胀的 pdf 打成 zip 那么它没怎么被压缩，而打成 7z 可以压缩至正常大小。原来 zip 这么菜的，以后有机会要研究一下。 问题分析 deepsleep 给出了使用 background 的解决方式。经过我的尝试这好像不起作用。我认为这应该是给 LaTeX 文档用的而不是 beamer。如果是我的问题，请在评论区告诉我。 我曾经在其它环境上使用过 XeTeX 并没有出现上述情况，可能是我现在使用的环境的 XeTeX 有点问题。反正很神秘。 经测试 pdfTeX 可以正常工作，但是因为我需要改字体，所以最终换成了 LuaTeX，问题得以解决。 总结 感觉自己没有解决实际问题的能力。需要学会如何高效地使用搜索引擎寻找答案，并适当的使用 AI 辅助来解决问题。 否则到时候遇到一点自己不会的东西，忙了一个下午不知道自己在忙什么，那就有点搞笑了！","tags":["TeX"]},{"title":"继续寻找人生的下一块拼图","path":"/posts/57c4317c/","content":"图片来源：高考之后人生第一次打凋灵风暴，图为准备进行第二次共生体战以获取用于制作恐怖炸弹的指令附魔书。 令人迷茫的现状 你应该知道我位于辽宁省，昨天查完 2025 年高考的分数。和我的估分差不多，但这个结果也确实不能令人满意。按照曾经的标准就是“没学上了”。 我可以说我拆括号拆错（你可以简单的理解为我计算出了 2(x+3)=2x+32(x+3)=2x+32(x+3)=2x+3）丢了 101010 分很糖，也可以说少刷 505050 套数学卷数学也是这个分，省下来的时间去学物理显然更赚。但不管怎样高考已经结束，复读也是不可能的。只能祝愿还没高考的同学不要犯糖。 只能安慰自己都一样了！自己就是一个普通人而已啦~ 动力源于创作，创作源于生活 后记 不要问我去了哪里。如果某天我想说出来，我会自己写出来的。 就这样吧，要做的事情还有很多，可是自己总是很懒。"},{"title":"CodeTON Round 4 题解","path":"/posts/4ded5892/","content":"避雷：H 我不会。 随便写写吧：https://codeforces.com/contest/1810. 终于更完了，james1 你也是够懒的。 A. Beautiful Sequence 如果有一个数满足 ai≥ia_i\\geq iai​≥i 即可。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n, flag = 0; cin n; for (int i = 1, x; i = n; ++i) cin x; if (x = i) flag = 1; cout (flag ? YES : NO );int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; B. Candies 不难发现决策是唯一的。 #include bits/stdc++.husing namespace std;typedef long long i64;void solve(void) int n; cin n; vectorint ans; while (n % 2 n 1) if ((n 1) 1) ans.push_back(2), n = 1; else ans.push_back(1), n = (n 1) + 1; if (n != 1) return cout -1 , void(); reverse(ans.begin(), ans.end()); cout ans.size() ; for (int i : ans) cout i ; cout ;int main(void) ios::sync_with_stdio(0); int T = 1; cin T; while (T--) solve(); return 0; C. Make It Permutation 枚举结束的数字即可。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 1e5 + 5;int n, c, d;int a[N];void solve(void) cin n c d; for (int i = 1; i = n; ++i) cin a[i]; sort(a + 1, a + n + 1); int m = unique(a + 1, a + n + 1) - (a + 1); i64 ans = 1ll * m * c + d; for (int i = 1; i = m; ++i) ans = min(ans, 1ll * (a[i] - i) * d + 1ll * (m - i) * c); cout ans + 1ll * c * (n - m) ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; D. Climbing the Tree 蜗牛爬水井是小学时非常常见的脑筋急转弯题，要注意蜗牛可能会直接爬出水井。 对于本题来说，我们需要用更为一般的代数手段，也就是不等式组描述这个问题。给条件相当于要解出一组取值范围看能否与之前的合并，问能否爬出相当于要对于当前的高度取值范围 [L,R][L,R][L,R]，分别看高度为 L,RL,RL,R 时所需的爬出天数（显然这个函数是单调递增的）。 先来看第一个问题。什么时候高度最大？第 nnn 天需要爬 aaa 时，即 (n−1)×(a−b)+a(n-1)\\times (a-b) + a(n−1)×(a−b)+a。最小呢？第 n−1n-1n−1 天白天爬完之后还剩 111 的高度没有爬完，以至于需要第 nnn 天接着爬。 再来看第二个问题。不妨设高度为 hhh，那么要满足 an−b(n−1)≥han - b(n-1) \\geq han−b(n−1)≥h，将 nnn 解出向上取整即可。 有点小细节但不多，比如天数为 111 需要特判之类的。样例非常友好，写挂了全能调出来。 #include bits/stdc++.husing namespace std;typedef long long i64;i64 calc(i64 h, int a, int b) if (a = h) return 1; // (a - b)n = h - b return (h - b + a - b - 1) / (a - b);void solve(void) int q; cin q; i64 L = 1, R = 2e18; while (q--) int op, a, b; i64 n; cin op a b; if (op == 1) cin n; i64 r = (n - 1) * (a - b) + a; i64 l = (n == 1 ? 1 : (n - 2) * (a - b) + a + 1); if (l R || r L) cout 0 ; else cout 1 ; L = max(L, l); R = min(R, r); else // cerr L R E$TD ; i64 n1 = calc(L, a, b), n2 = calc(R, a, b); if (n1 != n2) cout -1 ; else cout n1 ; cout ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; E. Monsters 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。 #include bits/stdc++.husing namespace std;typedef long long i64;const int N = 2e5 + 5;int n, m, a[N], vis[N];vectorint G[N];bool work(int x) #define pii pairint, int priority_queuepii, vectorpii, greaterpii q; q.emplace(0, x); int cnt = 0; while (!q.empty()) int u = q.top().second; q.pop(); if (vis[u] == x) continue; vis[u] = x; ++cnt; if (a[u] = cnt) return 0; for (int v : G[u]) if (vis[v] != x) q.emplace(a[v], v); return cnt == n;void solve(void) cin n m; for (int i = 1; i = n; ++i) vectorint().swap(G[i]), cin a[i]; while (m--) int u, v; cin u v; G[u].emplace_back(v); G[v].emplace_back(u); memset(vis, 0, sizeof vis); for (int i = 1; i = n; ++i) if (a[i] == 0 vis[i] == 0) if (work(i)) return cout YES , void(); cout NO ;int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0; G. The Maximum Prefix 直接做怎么做？设 fif_ifi​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后刷表转移对于每个状态是 O(1)O(1)O(1) 的，炸了。 需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案。可以以 pip_ipi​ 的系数转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 答案便是 fi,0f_{i,0}fi,0​。 #include bits/stdc++.husing namespace std;typedef long long i64;const int P = 1000000007;const int N = 5e3 + 5;inline int poww(int a, int b) int r = 1; for (; b; b = 1, a = 1ll * a * a % P) if (b 1) r = 1ll * r * a % P; return r;inline int inv(int x) return poww(x, P - 2); inline void add(int x, i64 k) x = (x + k) % P; int n;int p[N];int f[N][N];void solve(void) cin n; for (int i = 1; i = n; ++i) int x, y; cin x y; p[i] = 1ll * x * inv(y) % P; for (int i = 0; i = n + 2; ++i) for (int j = 0; j = n + 2; ++j) f[i][j] = 0; for (int i = 0; i = n; ++i) cin f[0][i]; for (int i = 0; i n; ++i) for (int j = 0; j = n; ++j) if (f[i][j]) // i + 1 位置填 1 if (j) add(f[i + 1][j - 1], 1ll * p[i + 1] * f[i][j]); // i + 1 位置填 -1 add(f[i + 1][j + 1], 1ll * (1 + P - p[i + 1]) * f[i][j]); if (j == 0) add(f[i + 1][0], 1ll * (1 + P - p[i + 1]) * f[i][j]); for (int i = 1; i = n; ++i) cout f[i][0] [i == n];int main(void) ios::sync_with_stdio(0); cin.tie(0); int T = 1; cin T; while (T--) solve(); return 0;","tags":["算法竞赛","Codeforces"],"categories":["算法竞赛","Codeforces"]},{"title":"我回来了","path":"/posts/a5aedc5a/","content":"搬家了！这里是新博客。以前的内容会逐步搬迁。 这里主要测试一些内容，回归文章一段时间之后会写。 公式部分 ap−1≡1(modp) a^{p-1}\\equiv 1 \\pmod p ap−1≡1(modp) ∇⋅D=ρf∇⋅B=0∇×E=−∂B∂t∇×H=Jf+∂D∂t\\begin{array}{l} abla \\cdot \\mathbf{D} =\\rho _f \\\\ abla \\cdot \\mathbf{B} = 0 \\\\ abla \\times \\mathbf{E} = -\\cfrac{\\partial \\mathbf{B}}{\\partial t } \\\\ abla \\times \\mathbf{H} = \\mathbf{J}_f + \\cfrac{\\partial \\mathbf{D}}{\\partial t } \\end{array} ∇⋅D=ρf​∇⋅B=0∇×E=−∂t∂B​∇×H=Jf​+∂t∂D​​ 代码部分 这里测试一些代码。 cpp #include bits/stdc++.husing namespace std;int main(void) cout Hello World! ; return 0; yaml stellar: version: 1.30.1 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar main_css: /css/main.css main_js: /js/main.js"},{"title":"探索者笔记","path":"/explore/index/index.html","content":"你若问我这里是什么，只是 iznomia 无聊时写的一点文字而已啦~ 如果你找到了某些共鸣，欢迎在评论区与我交流~"},{"title":"探索者笔记","path":"/explore/music/index.html","content":"曲名 艺术家 Löschen BlackY feat. Risa Yuzuki Infection ARForest Impossible Two Steps From Hell Glacier Laur The Promise Globus world.execute (me) ; Mili 虚幻与现实 华晨宇 七重人格 华晨宇 #1f1e33 (Another long “#ant1p01e” version) かめりあ Floating Star Kirara Magic feat. Shion Lee 喜欢的音乐家 华晨宇Two Steps From HellThomas BergersenCamelliaLaurSakuzyo打打だいずvoid (Mournfinale)a_hisaAxRARForestCre-sc3NTKirara Magic月下散落出世"},{"title":"探索者笔记","path":"/explore/todo/index.html","content":"算法竞赛中的 python：https://www.cnblogs.com/Mxrush/p/17052293.html 完善数据结构部分的复习笔记 学习多项式 做题： https://qoj.ac/contest/1828 https://qoj.ac/contest/2535 https://qoj.ac/contest/1871 https://qoj.ac/contest/1817"},{"title":"线性代数","path":"/wiki/algebra/1.html","content":"基本上参照吉林大学的教材，可能会适当补充一些比较难的内容。 1. 矩阵与向量 若 A,B\\mathbf{A},\\mathbf{B}A,B 都为 nnn 行 mmm 列的矩阵，则 A,B\\mathbf{A},\\mathbf{B}A,B 称为同型矩阵； 用 eie_iei​ 表示基本列向量，fif_ifi​ 表示基本行向量； 矩阵的行和列互换，称为转置矩阵，记作 A⊤\\mathbf{A}^\\topA⊤，当 A=A⊤\\mathbf{A}=\\mathbf{A}^\\topA=A⊤ 时，A\\mathbf{A}A 是对称矩阵，若 A⊤=−A\\mathbf{A}^\\top=-\\mathbf{A}A⊤=−A，则 A\\mathbf{A}A 是反称矩阵； 矩阵的分块，我对它的理解是：矩阵的元素是矩阵；如果分块后其主对角线上的矩阵是方阵（阶数可以不同），其余子块均为零矩阵，那么它是分块对角矩阵； 对角矩阵：只有主对角线有值的方阵，记为 A=diag⁡{a11,a22,⋯ ,ann}\\mathbf{A}=\\operatorname{diag}\\{a_{11},a_{22},\\cdots,a_{nn}\\}A=diag{a11​,a22​,⋯,ann​}，全相等时称为标量矩阵； 1.1 矩阵的初等变换 三种初等变换 倍法变换：给某一行或列（接下来只写行）乘上一个非零数，A→ri×kB\\mathbf{A}\\xrightarrow{r_i\\times k}\\mathbf{B}Ari​×k​B； 消法变换：用一个数乘上某一行后再加到另一行上，A→ri×k+rjB\\mathbf{A}\\xrightarrow{r_i\\times k+r_j}\\mathbf{B}Ari​×k+rj​​B； 换法变换：交换两行，A→ri↔rjB\\mathbf{A}\\xrightarrow{r_i\\leftrightarrow r_j}\\mathbf{B}Ari​↔rj​​B； 对单位矩阵实施一次初等变换得到初等矩阵。 等价关系： 经过有限次初等变换后相等，A≅B\\mathbf{A}\\cong \\mathbf{B}A≅B。 任意一个矩阵都可以经过若干次初等变换变为标准形矩阵，是一个 2×22\\times 22×2 的分块矩阵，左上角为单位矩阵，其余三个子块为零矩阵。单位矩阵的阶就是原矩阵的秩。 R(A+B)≤R(A)+R(B)R(\\mathbf A + \\mathbf B)\\le R(\\mathbf A)+R(\\mathbf B)R(A+B)≤R(A)+R(B)， R(AB)≤min⁡{R(A),R(B)}R(\\mathbf A\\mathbf B)\\le \\min\\{R(\\mathbf A),R(\\mathbf B)\\}R(AB)≤min{R(A),R(B)}。 若只允许使用行初等变换，那么可以变成一个行阶梯形矩阵，即左下角有一个全 000 阶梯（而且每个台阶高为 111）。如果行首非零元素为 111，且这个 111 所在的列的其余元素为 000，那么它是行最简形矩阵。显然，行阶梯型矩阵的秩等于其行数。 使用初等矩阵左乘矩阵相当于行变换，右乘相当于列变换。 1.2 例题选解 2. 方阵的行列式 ∣A∣=a11a22−a12a21|\\mathbf A| =a_{11}a_{22}-a_{12}a_{21}∣A∣=a11​a22​−a12​a21​。 ∣A∣=a11a22a33+a12a23a31+a13a21a32−a13a22a31−a12a21a33−a11a23a32|\\mathbf A| =a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{12}a_{21}a_{33}-a_{11}a_{23}a_{32}∣A∣=a11​a22​a33​+a12​a23​a31​+a13​a21​a32​−a13​a22​a31​−a12​a21​a33​−a11​a23​a32​。 ∣A∣=∑j为1∼n的排列(−1)τ(j1,j2,⋯ ,jn)∏i=1naiji|\\mathbf A|=\\sum_{j为 1\\sim n 的排列}(-1)^{\\tau(j_1,j_2,\\cdots,j_n)} \\prod_{i=1}^n a_{ij_i} ∣A∣=j为1∼n的排列∑​(−1)τ(j1​,j2​,⋯,jn​)i=1∏n​aiji​​ 每一个乘积都是一个均布项。 ∣A∣=∣A⊤∣|\\mathbf A|=|\\mathbf A^\\top|∣A∣=∣A⊤∣。三角矩阵的行列式等于主对角线的乘积。 行列式某一行的公因子可以提到行列式外面去，消法变换不会改变行列式的值，一次换法变换使得行列式的值变为相反数。这句话可以推出，如果行列式有两行（列）成比例，那么行列式的值是 000。 det⁡A≠0\\det \\mathbf A e 0detA=0 的充要条件是 A\\mathbf AA 满秩。 ∣A∣=∣B∣∣C∣|\\mathbf A|=|\\mathbf B||\\mathbf C|∣A∣=∣B∣∣C∣，其中 A=[B OD C]\\mathbf A= \\begin{bmatrix}\\mathbf B\\ \\mathbf O\\\\ \\mathbf D\\ \\mathbf C\\end{bmatrix}A=[B OD C​]，∣AB∣=∣A∣∣B∣|\\mathbf A\\mathbf B|=|\\mathbf A||\\mathbf B|∣AB∣=∣A∣∣B∣。 2.1 行列式展开定理 将第 iii 行第 jjj 列划掉之后得到 aija_{ij}aij​ 的余子式，记作 MijM_{ij}Mij​。aija_{ij}aij​ 的代数余子式 Aij=(−1)i+jMijA_{ij}=(-1)^{i+j} M_{ij}Aij​=(−1)i+jMij​，代数余子式方阵转置后得到伴随矩阵，记作 A∗\\mathbf A^*A∗。 展开定理： ∑k=1naikAik=∑k=1nakiAki=∣A∣\\displaystyle\\sum_{k=1}^n a_{ik}A_{ik}=\\sum_{k=1}^n a_{ki}A_{ki}=|\\mathbf A|k=1∑n​aik​Aik​=k=1∑n​aki​Aki​=∣A∣； 当 i≠ji e ji=j 时，∑k=1naikAjk=∑k=1nakiAkj=0\\displaystyle\\sum_{k=1}^n a_{ik}A_{jk}=\\sum_{k=1}^n a_{ki}A_{kj}=0k=1∑n​aik​Ajk​=k=1∑n​aki​Akj​=0。 范德蒙德行列式： ∣111...1a1a2a3...an⋮⋮⋮⋱⋮a1n−2a2n−2a3n−2...ann−2a1n−1a2n−1a3n−1...ann−1∣=∏1≤ij≤n(aj−ai)\\begin{vmatrix} 1 1 1 ... 1\\\\ a_1 a_2 a_3 ... a_n\\\\ \\vdots \\vdots \\vdots \\ddots \\vdots \\\\ a_1^{n-2} a_2^{n-2} a_3^{n-2} ... a_n^{n-2}\\\\ a_1^{n-1} a_2^{n-1} a_3^{n-1} ... a_n^{n-1} \\end{vmatrix} =\\prod_{1\\le ij\\le n}(a_j-a_i) ​1a1​⋮a1n−2​a1n−1​​1a2​⋮a2n−2​a2n−1​​1a3​⋮a3n−2​a3n−1​​......⋱......​1an​⋮ann−2​ann−1​​​=1≤ij≤n∏​(aj​−ai​) 拉普拉斯定理：待补充。 2.2 例题选解 3. 逆矩阵 (AB)−1=B−1A−1(\\mathbf A \\mathbf B)^{-1}=\\mathbf B^{-1}\\mathbf A^{-1}(AB)−1=B−1A−1。 AA∗=A∗A=∣A∣E\\mathbf A\\mathbf A^{*}=\\mathbf A^{*}\\mathbf A=|\\mathbf A|\\mathbf EAA∗=A∗A=∣A∣E。 方阵可逆的充要条件是 ∣A∣≠0|\\mathbf A| e 0∣A∣=0（即方阵满秩），且 A−1=A∗∣A∣\\mathbf A^{-1} = \\dfrac{\\mathbf A^*}{|\\mathbf A|}A−1=∣A∣A∗​。 在矩阵中选取 kkk 行 kkk 列得到一个方阵，其行列式是一个 kkk 阶子式，记作 DkD_kDk​。如果 ∃Dr≠0\\exist D_r e 0∃Dr​=0，且 ∀Dr+1=0\\forall D_{r+1}=0∀Dr+1​=0，则 R(A)=rR(\\mathbf A)=rR(A)=r。 3.1 例题选解 4. 线性方程组 考虑如下线性方程组： {a11x1+a12x2+⋯+a1nxn=b1a21x1+a22x2+⋯+a2nxn=b2…am1x1+am2x2+⋯+amnxn=bm\\begin{cases} a_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n = b_1 \\\\ a_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n = b_2 \\\\ \\dots\\\\ a_{m1}x_1 + a_{m2}x_2 + \\cdots + a_{mn}x_n = b_m \\end{cases} ⎩⎨⎧​a11​x1​+a12​x2​+⋯+a1n​xn​=b1​a21​x1​+a22​x2​+⋯+a2n​xn​=b2​…am1​x1​+am2​x2​+⋯+amn​xn​=bm​​ 可以写成矩阵形式： [a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮am1am2⋯amn][x1x2⋮xn]=[b1b2⋮bm]\\begin{bmatrix} a_{11} a_{12} \\cdots a_{1n} \\\\ a_{21} a_{22} \\cdots a_{2n} \\\\ \\vdots \\vdots \\ddots \\vdots \\\\ a_{m1} a_{m2} \\cdots a_{mn} \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{bmatrix} = \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_m \\end{bmatrix} ​a11​a21​⋮am1​​a12​a22​⋮am2​​⋯⋯⋱⋯​a1n​a2n​⋮amn​​​​x1​x2​⋮xn​​​=​b1​b2​⋮bm​​​ 称 mmm 行 n+1n+1n+1 列的矩阵 B=(A,b)\\mathbf B=(\\mathbf A,\\mathbf b)B=(A,b) 为增广矩阵。 当 b≠0\\mathbf b e 0b=0 时，为非齐次线性方程组，否则是齐次线性方程组。 线性方程组有界时说它是相容的。 Cramer 法则：对于有 nnn 个未知量 nnn 个方程的线性方程组，记 DjD_jDj​ 代表用 b\\mathbf bb 代替 A\\mathbf AA 中第 jjj 列所得到的行列式，若 ∣A∣≠0|\\mathbf A| e 0∣A∣=0，则 xj=Djdet⁡Ax_j=\\dfrac {D_j}{\\det \\mathbf A}xj​=detADj​​。 注意到对增广矩阵进行初等行变换对方程组没有改变。有关于解的个数的定理： 非齐次线性方程组有解当且仅当 R(A)=R(A,b)R(\\mathbf A)=R(\\mathbf A,\\mathbf b)R(A)=R(A,b)，齐次线性方程组一定有解； nnn 元线性方程组有无穷多解的充要条件是 R(A)=R(A,b)nR(\\mathbf A)=R(\\mathbf A,\\mathbf b)nR(A)=R(A,b)n，有唯一解的充要条件是 R(A)=R(A,b)=nR(\\mathbf A)=R(\\mathbf A,\\mathbf b)=nR(A)=R(A,b)=n。 因此，向量组线性无关的充要条件是 R(α1,α2,⋯ ,αs)=sR(\\alpha_1,\\alpha_2,\\cdots,\\alpha_s)=sR(α1​,α2​,⋯,αs​)=s。 对于其次线性方程组，基础解系包含 n−R(A)n-R(\\mathbf A)n−R(A) 个解向量； 设 η0\\eta_0η0​ 是 Ax=b\\mathbf A \\mathbf x =\\mathbf bAx=b 的一个解，ξ1,⋯ ,ξn−r\\xi_1,\\cdots,\\xi_{n-r}ξ1​,⋯,ξn−r​ 是 Ax=0\\mathbf A\\mathbf x =\\mathbf 0Ax=0 的一个基础解系，那么方程的通解为 x=η0+∑kiξi\\mathbf x = \\eta_0+\\sum k_i\\xi_{i}x=η0​+∑ki​ξi​。 4.1 例题选解 证明：对于实矩阵 A\\mathbf AA，有 R(A⊤A)=R(A)R(\\mathbf A^\\top \\mathbf A)=R(\\mathbf A)R(A⊤A)=R(A)。 假定 A\\mathbf AA 是 mmm 行 nnn 列的，那么构造 nnn 维列向量 x\\mathbf xx 使得 Ax=0\\mathbf A\\mathbf x=\\mathbf 0Ax=0，则 A⊤Ax=0\\mathbf A^\\top \\mathbf A\\mathbf x=\\mathbf 0A⊤Ax=0。 若 A⊤Ax=0\\mathbf A^\\top \\mathbf A\\mathbf x=\\mathbf 0A⊤Ax=0，则 x⊤A⊤Ax=0\\mathbf x^\\top \\mathbf A^\\top \\mathbf A\\mathbf x=\\mathbf 0x⊤A⊤Ax=0，即 (Ax)⊤Ax=0(\\mathbf A\\mathbf x)^\\top \\mathbf A\\mathbf x=\\mathbf 0(Ax)⊤Ax=0，因此 Ax=0\\mathbf A\\mathbf x=\\mathbf 0Ax=0。 因此两齐次线性方程组同解，那么 R(A⊤A)=R(A)R(\\mathbf A^\\top \\mathbf A)=R(\\mathbf A)R(A⊤A)=R(A)。 5. 方阵的特征值、特征向量与相似化简 方阵的迹（trace）：tr⁡A=∑i=1naii\\operatorname{tr} \\mathbf A=\\sum_{i=1}^n a_{ii}trA=∑i=1n​aii​。 5.1 方阵的特征值和特征向量 设 A\\mathbf AA 是 nnn 阶矩阵，若存在数 λ\\lambdaλ 和 nnn 维非零列向量 α\\alphaα，使得 Aα=λα\\mathbf A\\alpha=\\lambda\\alphaAα=λα，那么 λ\\lambdaλ 是特征值（特征根），α\\alphaα 为对应于 λ\\lambdaλ 的特征向量，λE−A\\lambda\\mathbf E-\\mathbf AλE−A 是特征矩阵，φ(λ)=det⁡(λE−A)\\varphi(\\lambda)=\\det(\\lambda\\mathbf E-\\mathbf A)φ(λ)=det(λE−A) 为特征多项式，φ(λ)=0\\varphi(\\lambda)=0φ(λ)=0 为特征方程。在复数域上，A\\mathbf AA 恰有 nnn 个特征值（可能有重根）。 已知特征根求特征向量时，只需要求解齐次线性方程组 (λE−A)α=0(\\lambda E-\\mathbf A)\\alpha=\\mathbf 0(λE−A)α=0。 不难得知，上（下）三角矩阵的特征根就是主对角线上的元素。也不难得知，φ(λ)\\varphi(\\lambda)φ(λ) 是一个 nnn 次多项式，其系数 cn=1,cn−1=−tr⁡A,c0=φ(0)=det⁡(−A)c_n=1,c_{n-1}=-\\operatorname{tr} \\mathbf A,c_0=\\varphi(0)=\\det(-\\mathbf A)cn​=1,cn−1​=−trA,c0​=φ(0)=det(−A)。 有 tr⁡A=∑i=1nλi,det⁡A=∏i=1nλi\\operatorname{tr} \\mathbf A=\\sum_{i=1}^n \\lambda_i,\\det \\mathbf A=\\prod_{i=1}^n \\lambda_itrA=∑i=1n​λi​,detA=∏i=1n​λi​。 5.1.1 例题选解 证明幂等矩阵（即 A2=A\\mathbf A^2=\\mathbf AA2=A）的特征值只能是 000 或 111。 ∵Aα=λα,∴Aα=A2α=A(λα)=λ2α,∴λ2α=λα,∴λ=0,λ=1. \\because \\mathbf A\\alpha =\\lambda\\alpha, \\\\ \\therefore \\mathbf A\\alpha =\\mathbf A^2\\alpha=\\mathbf A(\\lambda\\alpha)=\\lambda^2 \\alpha,\\\\ \\therefore \\lambda^2\\alpha = \\lambda \\alpha,\\\\ \\therefore \\lambda = 0,\\lambda=1. ∵Aα=λα,∴Aα=A2α=A(λα)=λ2α,∴λ2α=λα,∴λ=0,λ=1. 5.2 方阵的相似 若存在 P\\mathbf PP 使得 P−1AP=B\\mathbf P^{-1}\\mathbf A\\mathbf P=\\mathbf BP−1AP=B，则 A∼B\\mathbf A\\sim \\mathbf BA∼B，这一操作称为相似变换，P\\mathbf PP 是相似因子（相似变换矩阵）。 若 A∼B\\mathbf A\\sim \\mathbf BA∼B，则可推出 R(A)=R(B),∣A∣=∣B∣,A⊤∼B⊤,A−1∼B−1,f(A)∼f(B)R(\\mathbf A)=R(\\mathbf B),|\\mathbf A|=|\\mathbf B|,\\mathbf A^\\top \\sim \\mathbf B^\\top,A^{-1}\\sim B^{-1},f(\\mathbf A)\\sim f(\\mathbf B)R(A)=R(B),∣A∣=∣B∣,A⊤∼B⊤,A−1∼B−1,f(A)∼f(B)，A\\mathbf AA 和 B\\mathbf BB 具有相同的特征多项式和特征根。 nnn 阶方阵 A\\mathbf AA 能和对角矩阵相似的充要条件是 A\\mathbf AA 存在 nnn 个线性无关的特征向量，而该对角矩阵主对角线的元素正是 A\\mathbf AA 的特征根，相似因子 P\\mathbf PP 的每一列都是一个特征向量，且与那些特征根所在的列一一对应。 设 λi\\lambda_iλi​ 是 nin_ini​ 重特征值，那么其对应的特征向量中线性无关组的大小最多为 nnn。 5.2.1 例题选解 求 [2213]100\\begin{bmatrix}2 2\\\\1 3\\end{bmatrix}^{100}[21​23​]100。 φ(λ)=λ2−5λ+4,∴λ1=1,λ2=4, \\varphi(\\lambda)=\\lambda^2 -5\\lambda +4,\\\\ \\therefore \\lambda_1=1,\\lambda_2=4, φ(λ)=λ2−5λ+4,∴λ1​=1,λ2​=4, 对应的特征向量为： α1=[2−1],α2=[11],\\alpha_1=\\begin{bmatrix}2\\\\-1 \\end{bmatrix},\\\\ \\alpha_2=\\begin{bmatrix}1\\\\1 \\end{bmatrix}, α1​=[2−1​],α2​=[11​], 因此 P=[21−11],B=[1004]\\mathbf P=\\begin{bmatrix}2 1 \\\\ -1 1\\end{bmatrix},\\mathbf B=\\begin{bmatrix}1 0 \\\\ 0 4\\end{bmatrix}P=[2−1​11​],B=[10​04​]，且 det⁡P=3,P∗=[1−112]\\det \\mathbf P=3,\\mathbf P^{*}=\\begin{bmatrix}1 -1 \\\\ 1 2\\end{bmatrix}detP=3,P∗=[11​−12​]，因此 P−1=13P∗\\mathbf P^{-1}=\\dfrac 1 3 \\mathbf P^{*}P−1=31​P∗。 A100=(PBP−1)100=PB100P−1=13[4100+22×4100−24100−12×4100+1]\\begin{aligned} \\mathbf A^{100}=(\\mathbf P\\mathbf B\\mathbf P^{-1})^{100}\\\\ =\\mathbf P\\mathbf B^{100}\\mathbf P^{-1}\\\\ =\\frac 1 3 \\begin{bmatrix}4^{100}+2 2\\times 4^{100}-2 \\\\ 4^{100}-1 2\\times 4^{100}+1\\end{bmatrix} \\end{aligned} A100​=(PBP−1)100=PB100P−1=31​[4100+24100−1​2×4100−22×4100+1​]​ 5.3 一些特殊矩阵 5.3.1 正交矩阵 若 αβ=0\\alpha\\beta=0αβ=0，则称 α,β\\alpha,\\betaα,β 正交，而正交向量组是线性无关组的充分不必要条件。如果每个向量都是单位向量，则是单位正交组。 Schmidt 单位正交化：待补充 如果 nnn 阶实矩阵 A\\mathbf AA 的列向量是单位正交组，那么其是正交矩阵，判定正交矩阵的充要条件是 AA⊤=E\\mathbf A\\mathbf A^{\\top}=\\mathbf EAA⊤=E。 若 A,B\\mathbf A,\\mathbf BA,B 是正交矩阵，那么 det⁡A=1 或 −1\\det \\mathbf A=1\\ 或\\ -1detA=1 或 −1，AB\\mathbf A \\mathbf BAB 是正交矩阵。用正交矩阵作为相似因子做正交变换称为正交变换。 5.4 实对称矩阵的相似对角化 * 5.5 Jordan 标准型 6. 相似矩阵及二次型 7. 线性空间 8. 试卷选做"},{"title":"微积分 A1","path":"/wiki/calculus/1.html","content":"主要用于复习，不具有参考价值。 1. 前置知识 邻域：U(A,δ)=(a−δ,a+δ),U˚(A,δ)=(a−δ,a)∪(a,a+δ)U(A,\\delta)=(a-\\delta,a+\\delta),\\mathring{U}(A,\\delta)=(a-\\delta,a)\\cup(a,a+\\delta)U(A,δ)=(a−δ,a+δ),U˚(A,δ)=(a−δ,a)∪(a,a+δ)。 夹逼定理：给定三个数列 xn,yn,zn{x_n},{y_n},{z_n}xn​,yn​,zn​，若满足： ∃K,s.t.⁡nK,yn≤xn≤zn\\exist K,\\operatorname{s.t.} nK,y_n\\le x_n\\le z_n∃K,s.t.nK,yn​≤xn​≤zn​， lim⁡n→∞yn=lim⁡n→∞zn=a\\lim\\limits_{n\\to\\infty}y_n=\\lim\\limits_{n\\to\\infty}z_n=an→∞lim​yn​=n→∞lim​zn​=a， 则 lim⁡n→∞xn=a\\lim\\limits_{n\\to\\infty}x_n=an→∞lim​xn​=a。 两个重要极限： lim⁡x→0sin⁡xx=1\\displaystyle \\lim_{x\\to 0} \\frac{\\sin x}{x}=1x→0lim​xsinx​=1； lim⁡x→∞(1+1x)x=e\\displaystyle \\lim_{x\\to\\infty}\\left(1+\\frac 1 x\\right)^x=ex→∞lim​(1+x1​)x=e。 2. 导数与微分 2.1 求导与微分 2.2 微分中值定理 拉格朗日中值定理：f(x)f(x)f(x) 在 [a,b][a,b][a,b] 连续，在 (a,b)(a,b)(a,b) 可导，那么 ∃ξ∈(a,b),i.e.⁡f′(ξ)=f(b)−f(a)b−a\\exist \\xi\\in (a,b),\\operatorname{i.e.}f(\\xi)=\\dfrac{f(b)-f(a)}{b-a}∃ξ∈(a,b),i.e.f′(ξ)=b−af(b)−f(a)​。 2.3 弧微分 3. 不定积分 4. 定积分 5. 空间解析几何"},{"title":"杂项内容","path":"/wiki/oi-note/1-100.html","content":"曼哈顿与切比雪夫距离转化 曼哈顿距离是指 x,yx,yx,y 坐标的差的和，而切比雪夫距离指的是差的最大值。 从曼哈顿距离转化成切比雪夫距离，令 xi′=xi+yi,yi′=xi−yix_i=x_i+y_i,y_i=x_i-y_ixi′​=xi​+yi​,yi′​=xi​−yi​，反着转的时候反过来解一下二元一次方程组就行。 例题 [EC Online 2025 I] Moving on the Plane Portal. 首先转成切比雪夫，然后两维独立了。然后坐标范围很小，于是直接枚举最后点走到的坐标范围。然后你发现 KKK 更小，甚至可以直接枚举位置。注意会算重，于是改为钦定最小坐标，把没有点走到最小坐标的东西减去就好了。代码。"},{"title":"二分与倍增","path":"/wiki/oi-note/1-1.html","content":"两者的本质均基于单调性，寻找题目中具有单调性的函数关系，然后施展二分或者倍增。二分答案可以用来解决分数规划问题，三分法可以求解单峰/谷函数。同时，二分上界不确定的内容的最佳方式是倍增，通过先倍增到上界，再倍增答案来解决。 二分 一种二分写法 通过 l = r 之类的方法的二分笔者认为有些过于诡异，这里给出我自己的二分实现方式（我记得当时是在 B 站学的，但是出自哪个视频忘了）。 Luogu P2249int L = 0, R = n + 1;while (L + 1 != R) int mid = L + R 1; if (a[mid] = x) R = mid; else L = mid;if (a[R] == x) cout R ;else cout -1 ; 01 分数规划 用来求一个分式的极值，也就求一组 wi={0,1}w_i=\\{0,1\\}wi​={0,1}，最大化或者最小化： ∑ai×wi∑bi×wi\\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i} ∑bi​×wi​∑ai​×wi​​ 我们一般使用二分答案来解决这个问题。以最大值为例： ∑ai×wi∑bi×wimid⟹∑ai×wi−mid×∑bi×wi0⟹∑wi(ai−mid×bi)0\\begin{aligned} \\frac{\\sum a_i\\times w_i}{\\sum b_i\\times w_i}mid\\\\ \\Longrightarrow \\sum a_i\\times w_i - mid\\times \\sum b_i\\times w_i 0\\\\ \\Longrightarrow \\sum w_i(a_i-mid\\times b_i)0 \\end{aligned} ⟹⟹​∑bi​×wi​∑ai​×wi​​mid∑ai​×wi​−mid×∑bi​×wi​0∑wi​(ai​−mid×bi​)0​ 于是排序即可确定 wiw_iwi​ 的值。有些时候会限制 ∑bi×wi\\sum b_i\\times w_i∑bi​×wi​ 的最小值之类的，例题，这时使用背包求解即可。 三分法 三分法可以用于求解单峰函数的极值点。对于常规的三分写法不再赘述，但值得注意的是，对于定义域为整数的实际问题，它们的答案可能真的是单峰的，但此时由于其不满足函数的连续性，会存在一大段平的区间，然后三分就炸了（鬼知道极值点在哪，你需要 O(n)O(n)O(n) 扫过去）。 不要错误的将某些函数视作可以三分，更不要将单峰函数视作凸函数而对导函数二分。单峰的证明是比较困难的，而且有时对于非单峰的问题也比较难找到反例（廊桥分配），要根据实际情况判断。 Luogu P1883 画图可知，两个单谷函数（一次函数的谷点视作在无穷远处）取 max⁡\\maxmax 后，得到的新函数仍然是单谷函数，因此直接三分即可。 但很阴的是，这题要求极值而不是极值点，精度会被 bbb 吃掉，因此 eps 要取小。 double L = 0, R = 1000;while (L + eps R) double Lmid = (L + R) / 2; double Rmid = (Lmid + R) / 2; if (calcF(Lmid) calcF(Rmid)) L = Lmid; else R = Rmid; wqs 二分 O(log⁡n)O(\\log n)O(logn) 倍增 ST 表 ST 表使用倍增结构来实现，支持在末尾插入一个数。大概长这样： f[0][n] = a[n]; // The new Nfor (int j = 1; 1 j = n; ++j) f[j][n - (1 j) + 1] = max(f[j - 1][n - (1 j) + 1], f[j - 1][n - (1 j - 1) + 1]); 在开头插入亦同理。 例题 刷基础 1 [3rd ucup s39] Array Similarity Portal。记录每个数向右跳几次可以到第一个大于等于它的数，倍增地查找答案，然后将这个跳跃次数序列哈希起来比较即可。代码。 刷提升 [AGC020D] Min Max Repetition Portal. 字符串填写的方式不难得出，最小连续长度 k=max⁡{⌈AB+1⌉,⌈BA+1⌉}k=\\max\\left\\{\\left\\lceil\\cfrac{A}{B+1}\\right\\rceil,\\left\\lceil\\cfrac{B}{A+1}\\right\\rceil\\right\\}k=max{⌈B+1A​⌉,⌈A+1B​⌉}。 字符串一定是 (AkB)(A^kB)(AkB) 的一个前缀加上 (ABk)(AB^k)(ABk) 的一个后缀。如何找到分界点？最优情况下分界点一定是一个 AAA，是前后缀公用的。假设分界点之前有 bbb 个 BBB 和 aaa 个 AAA，那么应满足 b≤max⁡{0,⌊a−1k⌋}b\\le \\max\\left\\{0,\\left\\lfloor\\cfrac{a-1}{k}\\right\\rfloor\\right\\}b≤max{0,⌊ka−1​⌋}，也就是 a=A−⌈B−bk⌉+1a=A-\\left\\lceil\\cfrac{B-b}{k}\\right\\rceil+1a=A−⌈kB−b​⌉+1。二分找到最大的 bbb 即可确定一切。代码。 ** [CF1764G] Doremy’s Perfect DS Class G1，G2，G3。给定一个 1∼n1\\sim n1∼n 的排列 ppp（n≤1024n \\le 1024n≤1024，注意 210=10242^{10}=1024210=1024），每次你可以询问 l,r,kl,r,kl,r,k，交互库会返回 ⌊plk⌋,⌊pl+1k⌋,⋯ ,⌊prk⌋\\left\\lfloor\\cfrac{p_l}k\\right\\rfloor,\\left\\lfloor\\cfrac{p_{l+1}}k\\right\\rfloor,\\cdots,\\left\\lfloor\\cfrac{p_r}k\\right\\rfloor⌊kpl​​⌋,⌊kpl+1​​⌋,⋯,⌊kpr​​⌋ 中不同数的个数，需要找到 111 的位置。交互次数分别限制在 30,25,2030,25,2030,25,20 次。 询问能告诉我们什么？好奇怪啊，不知道。尝试从给定的 kkk 值开始分析。k=1k=1k=1 没什么意义，然后尝试从特殊的，比如 k=2,nk=2,nk=2,n 开始分析。k=nk=nk=n 比较好说，只有 nnn 可以被记入答案，可以根据此找出 nnn 的位置。k=2k=2k=2 则可以将数分为两组，在 nnn 为奇数时只有 111 是单独一组，nnn 为偶数时只有 1,n1,n1,n 是单独一组。 从别的地方再想一想，都要求 log⁡\\loglog 级别的询问，不难想到二分。设 solve(l, r) 代表答案在 [l,r][l,r][l,r] 的位置中，我们需要确定 111 在 [l,mid][l,mid][l,mid] 还是 [mid+1,r][mid+1,r][mid+1,r] 里。咦，感觉不太对，不是严格的子问题！但是我们只需要寻找答案在哪里，因此只需要分别答案在 [1,mid][1,mid][1,mid] 还是 [mid+1,n][mid+1,n][mid+1,n] 就好了。 选择从 k=2k=2k=2 入手，x,yx,yx,y 分为一组仅当它们除以二下取整后的值相等。我们可以求出两个区间中在自己区间内没有匹配的数的数量，然后这个数量大的，答案就在那里（因为剩下的每有一个都是成对的）。 nnn 是偶数怎么办呢？我们只需要找到 nnn 就行，不难发现 k=nk=nk=n 可以很好的完成这个任务。当两个区间的值相等时，说明 1,n1,n1,n 各占一个，我们令 k=nk=nk=n，询问其中一个，看 nnn 是否在其中。找到 nnn 的位置之后发现之后的递归不会受到影响（如果 pnmidp_n midpn​mid，我们会递归到 [l,mid][l,mid][l,mid]，必定有 pnmid′p_nmidpn​mid′）。 这个做法可以通过 G2，代码。想过掉 G3，我们需要想方法杀掉那一次多余的询问。 怎么杀？对于 r−l+1=2r-l+1=2r−l+1=2 的情况，使用两次询问有点浪费，我们看能不能只用一次询问杀掉它。核心思想是，充分利用我们之前问出来的信息。当我们递归到 [l,r][l,r][l,r] 时，曾令一个 mid=l−1mid=l-1mid=l−1，也令了一个 mid=rmid=rmid=r，因此我们知道 Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l-1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2)Q(1,l−1,2),Q(1,r,2),Q(l,n,2),Q(r+1,n,2) 的答案。现在 l,rl,rl,r 中一个是 111，一个是和其他数能匹配上的某个奇怪的东西，吗？注意，另一个可能是 nnn，如果我们还没有确定 nnn 的位置，那么通过询问 Q(r,n,n)Q(r,n,n)Q(r,n,n) 或 Q(1,l,n)Q(1,l,n)Q(1,l,n) 将其判掉。 现在再看怎么搞 l,rl,rl,r 一个是 111，另一个是可匹配数。可匹配数只能配在 [1,l−1][1,l-1][1,l−1] 或 [r+1,n][r+1,n][r+1,n]，如果 Q(1,l−1,2)+1=Q(1,r,2)Q(1,l-1,2)+1=Q(1,r,2)Q(1,l−1,2)+1=Q(1,r,2)，那么说明可匹配数的匹配数是开在 [1,l−1][1,l-1][1,l−1] 的（这个数除以二下去整的值与 [1,l−1][1,l-1][1,l−1] 中的某个数撞了），否则开在 [r+1,n][r+1,n][r+1,n]。确定了这一点之后，我们就可以锁定 111 的位置了！以开在 [1,l−1][1,l-1][1,l−1] 为例，如果 Q(1,l−1,2)=Q(1,l,2)Q(1,l-1,2)=Q(1,l,2)Q(1,l−1,2)=Q(1,l,2)，说明 lll 处开可匹配数，与 [1,l−1][1,l-1][1,l−1] 中的某个数匹配，111 就开在 rrr 处。 这样在 r−l+1=2r-l+1=2r−l+1=2 时我们只花费了一次询问，可以通过 G3。代码。"},{"title":"分治","path":"/wiki/oi-note/1-2.html","content":"分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。 仿照分治的结构可以衍生出一大堆静态分治算法。 普通分治 uoj979. 决战库尔斯克 Portal. 首先排序去重。如果选择钦定最小值，发现需要枚举最小值的倍数然后在一段中二分出最大值，但是值域很大，寄了。 那么钦定最大值，最小值可以选择严格比其一半大的，那么答案是差。 考虑小于的部分对大于的部分的影响。发现需要 ai−1ar−amida_i - 1 a_r - a_{mid}ai​−1ar​−amid​，而这一部分的 aia_iai​ 就只有至多两端倍数了，直接二分。 于是分治下去即可，O(nlog⁡Vlog⁡n)O(n\\log V\\log n)O(nlogVlogn)，二分跑不满能过。代码。 二维分治"},{"title":"随机化算法","path":"/wiki/oi-note/1-3.html","content":"有的时候不知道怎么做？或者遇到神秘的提交答案题（有些提交答案是不可做优化题）？可以考虑使用随机化。 随机化有两种，一种是操作次数一定，正确性与进行的轮数有关（模拟退火等）；另一种是期望操作次数，要求数据满足一定条件，否则会 TLE 或者超交互次数。 生成随机数mt19937_64 Rnd(time(0));int rndint(int l, int r) return uniform_int_distribution(l, r)(Rnd);double rnddb(int l, int r) return uniform_real_distribution(l, r)(Rnd);"},{"title":"哈希方法","path":"/wiki/oi-note/1-4.html","content":"序列哈希 集合哈希 树哈希 哈希表 例题 刷基础 [CSP-S 2022] 星战 Portal. 要求所有点的出度都是 111。其实是要维护一个可重集，对于每一条边，都要将这条边的起点加入集合。只有这个集合恰好为 1∼n1\\sim n1∼n 的集合才是合法的。 因此直接使用集合哈希维护，摧毁和修复节点的操作都是加减法可以完成的。代码。 注意这里只能用 sum Hash，xor Hash 是错误的，比如一个点的出度为 333 也会被视作为合法的。 [AMPPZ 2023] Fibonacci Fusion Portal. 首先需要取枚举每一个数，不妨枚举那个比较大的数，发现不同的合法的较小的数最多只有两个。因为斐波那契数想要变大，过两项就会翻倍。这样在大数确定时，和不能翻两倍。 我们要找出比这个大数大的斐波那契数，观察通项公式 fn=15(((1+5)2)n−((1−5)2)n)f_n=\\frac{1}{\\sqrt{5}}\\left(\\left(\\frac{(1+\\sqrt{5})}{2}\\right)^n - \\left(\\frac{(1-\\sqrt{5})}{2}\\right)^n\\right)fn​=5​1​((2(1+5​)​)n−(2(1−5​)​)n)，在 nnn 足够大时可以直接将后面减的那一项放缩掉，便可以直接解出 nnn（两边取自然对数，一个数的自然对数可以通过它的位数估计），然后对这些斐波那契数求解即可。 高精度计算肯定是不行的，我们直接让所有数在对大质数取模意义下计算即可。笔者的实现为了保险采用了双哈希，但感觉没必要，代码。"},{"title":"线性代数","path":"/wiki/oi-note/10-0.html","content":"/wiki/algebra/1.html. 前置知识 行列式求值，枚举主对角线上的位置，通过行消法变换 + 辗转相除将一个行首转化成 000，然后换法变换将这一列底下的东西转成 000。 int sol(void) int f = 1; for (int i = 1; i = n; ++i) for (int j = i + 1; j = n; ++j) while (a[i][i]) int d = a[j][i] / a[i][i]; for (int k = i; k = n; ++k) a[j][k] = (a[j][k] - 1ll * d * a[i][k] % P + P) % P; swap(a[i], a[j]), f = -f; swap(a[i], a[j]); f = -f; int ans = f; for (int i = 1; i = n; ++i) ans = 1ll * ans * a[i][i] % P; return (ans + P) % P;"},{"title":"组合博弈论","path":"/wiki/oi-note/10-2.html","content":"博弈论主要研究一些有竞争或对抗性质的对象，在一定规则下/产生的各种行为。 接下来讨论的所有问题，若没有写出，均默认为两人轮流行动的、完美信息、无随机因素。 通常来讲，无法行动的人会输掉，称为正常博弈，而无法行动却获胜称为反常博弈。 公平组合博弈 引入 我们从 Nim 游戏开始研究。有 nnn 堆石子，每人每次可从任意一堆石子里取出正整数枚石子扔掉，谁不能动谁就输了。 我们将每个状态视作一个节点，那么博弈情况就可以刻画成一张有向图。不难发现，异或和为 000 时先手必败。 大部分的公平组合游戏都可以转换为有向图游戏，对于状态 xxx 和它的 kkk 个后继状态 y1,⋯ ,yky_1,\\cdots,y_ky1​,⋯,yk​，定义 SG 函数为： SG⁡(x)=mex⁡{SG⁡(y1),SG⁡(y2),…,SG⁡(yk)}\\operatorname{SG}(x)=\\operatorname{mex}\\{\\operatorname{SG}(y_1), \\operatorname{SG}(y_2), \\ldots, \\operatorname{SG}(y_k)\\} SG(x)=mex{SG(y1​),SG(y2​),…,SG(yk​)} 对于由 nnn 个有向图游戏组成的组合游戏，当且仅当 ⊕SG⁡(s)≠0\\oplus \\operatorname{SG}(s) e 0⊕SG(s)=0 的时候，先手必胜，称之为 P 态（previous player）。也就是说，SG⁡(x)=0\\operatorname{SG}(x)=0SG(x)=0 是必败态，称之为 N 态。 SG 定理：一个游戏的 SG 值是其所有子游戏的 SG 值的异或和，这可以说明 Nim 游戏结论的由来。 Anti-SG 定理 如果游戏的 SG 值为 000，那么所有子游戏的 SG 值都不超过 111 时先手必胜； 如果游戏的 SG 值不是 000，那么至少有一个子游戏的 SG 值超过 111 时先手必胜。 模板。 Colon Principle 针对树形结构的博弈，我们假定一次操作可以删除一条边，然后保留根节点所在的子树。不能操作者输掉。 首先对于一条长度为 xxx 的链，其 SG 值为 x−1x-1x−1。一棵树可以分解成若干个子问题，每个子问题都是根节点的一棵子树加上根节点本身。 如果一棵子树的 SG 值为 xxx，那么其可以等效为一个长度为 x+1x+1x+1 的链。也就是说，新搞一个点连到树根上，这棵树的 SG 值会加 111。 因此不难计算。模板，代码。 常见公平游戏 超现实数理论 非公平组合博弈"},{"title":"分块","path":"/wiki/oi-note/11-1.html","content":"Problemset 刷提升"},{"title":"概述","path":"/wiki/oi-note/12-1.html","content":"广义来说，所有问题都属于构造类问题——它们都需要构造解（bushi）。 此类题目中也有较多 ad-hoc 题，需要我们从多个角度思考，发挥自己的想象力。 我们不能对于每道题都枚举所有套路逐一试错，而需要具体情况具体分析。不应当完全依靠猜或试找出来，而是主要通过线索推断出来。它们包括但不限于： 特殊的题目条件、数据范围 特殊性质、部分分 必然性、充分性 模型的观察与转化 打表的结果 注意在做此类题目时，要避免自己陷入思维死局。"},{"title":"问题的分析","path":"/wiki/oi-note/13-1.html","content":"常见套路 正难则反 [Chengdu Regional 2025] K-Coverage Portal。如果直接枚举删除哪条线段，然后求解把它放在哪，可能不是很好做。不妨直接扔进去一条新的线段，不断移动它，然后看删除哪个线段最优。维护删除所有线段的贡献 deltaidelta_ideltai​，每次移动线段只会对一个连续段的线段的 deltadeltadelta 造成改变。代码。 操作的转化 [qoj962] Thanks to MikeMirzayanov Portal. 操作好像不是很方便，但是可以用两次操作实现对每一段分别排序。于是问题就可以分治下去了（因为段之间互不影响），我们只需要对 01 排序，这是容易的，O(log⁡n)O(\\log n)O(logn) 即可完成。注意不要每次操作后直接全局翻转使得你的常数乘二。代码。 例题 刷基础 [Ptz Winter 2020 Day3] Disjoint LIS Portal. 看上去非常 NP，"},{"title":"你需要注意的事情","path":"/wiki/oi-note/13-100.html","content":"否则我们无法成功收尸。 1. 策略性问题 想题之前检查有没有看错题。 太会做检查看没看错，太不会做检查看没看做。 做题之前检查看的数据范围，写完之后再检查一遍（比如输入是否是自然数而不是正整数？）。"},{"title":"并查集","path":"/wiki/oi-note/2-0.html","content":"拆点 即某教材中的“扩展域”并查集。反对这种恶意恐吓萌新的叫法。 CF776D。所有灯都恰好由两个开关控制，那么给每个开关拆成是否按下的两个点，并查集检查是否有矛盾即可。代码。"},{"title":"树状数组","path":"/wiki/oi-note/2-1.html","content":"又称 Fenwick 树、二叉索引树（BIT）。支持维护前缀后缀的信息。 概述 树状数组将序列拆分成了恰好 nnn 个区间，对于每一个前缀求解都可以拆成 log⁡p\\log plogp 个区间进行求解，而且自带一个卡不掉的 1/21/21/2 的常数，随机数据下则为 1/41/41/4 的常数！我们通过 lowbit⁡\\operatorname{lowbit}lowbit 来支持树状数组的工作。 一个显式的树状数组 ratio:1415/735 模板，区间和我们可以用前缀和相减来求解，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64; int n, m; int a[500005]; i64 C[500005]; void add(int x, int k) for (; x = n; x += x -x) C[x] += k; i64 sum(int x) i64 r = 0; for (; x; x -= x -x) r += C[x]; return r; int main(void) scanf(%d%d, n, m); for (int i = 1; i = n; ++i) scanf(%d, a + i), add(i, a[i]); while (m--) int op, x, y; scanf(%d%d%d, op, x, y); if (op == 1) add(x, y); else printf(%lld , sum(y) - sum(x - 1)); return 0;"},{"title":"线段树","path":"/wiki/oi-note/2-2.html","content":"线段树是一种功能强大的二叉数据结构，可以维护半群上的信息（满足结合律）。 对于一般情况，我们使用堆式线段树来存储线段树；对于空间开不下的情况，我们使用动态开点来存储线段树。 延迟标记 这个东西不只被用在线段树上，但从线段树结构基本可以介绍出它的大部分应用。以下问题都可以直接使用多元标记来处理： 区间最大子段和：维护前缀后缀最大子段和、区间和和答案即可； 区间平方和：不难根据区间和计算出新的区间平方和； 区间加等差数列单点求和：每个点维护一个 ddd，代表其加上的是 d×id\\times id×i，其中 iii 是下标，然后再维护一个区间加标记即可。 [CF446C] DZY Loves Fibonacci Numbers.区间加斐波那契数列，区间求和。 将广义斐波那契数列的前两项作为标记打在线段树中，合并时直接加起来就可以。再加上斐波那契数列的求和公式：∑i=1nfi=fn+2−f2\\sum_{i=1}^{n}f_i=f_{n+2}-f_{2}∑i=1n​fi​=fn+2​−f2​，和便可以直接计算。代码。 双半群模型 例题 刷基础 1 [2023 钉耙编程 1] Easy problem I Portal。如果一个数发生过 ai←x−aia_i\\leftarrow x-a_iai​←x−ai​，那么以后就会一直这样。搞两棵线段树分别维护即可。代码。 [Luogu P5278] 算术天才⑨与等差数列 Portal. 发现条件非常严苛，因此可以考虑哈希之类的方法，这里不做赘述。 一段区间可以重排为等差数列，当且仅当满足（d=0d=0d=0 先特判掉）： max⁡−min⁡=d×(len−1)\\max -\\min =d\\times (len-1)max−min=d×(len−1)； gcd⁡i=lr−1(ai+1−ai)=d\\gcd_{i=l}^{r-1}(a_{i+1}-a_i)=dgcdi=lr−1​(ai+1​−ai​)=d； 序列中没有重复的元素。 用线段树维护即可。第三条可以使用 set、map 维护一个数最左边的出现位置，然后用线段树维护这个值的最小值，如果这个数小于 lll，那么一定没有重复元素。代码。"},{"title":"平衡树","path":"/wiki/oi-note/2-3.html","content":"平衡树是一种二叉数据结构，满足所谓的“BST 性质”： 空树是 BST； 若 BST 的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值； 若 BST 的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值； BST 的左右子树均为 BST； BST 集合是满足 1、2、3、4 的最小二叉树集。 笔者通常使用 FHQ 来实现平衡树。 例题 刷基础 I [2023 钉耙编程 1] Easy Problem II Portal。维护权值平衡树，找到比 xxx 大、小的分别打标记，打完之后依然满足平衡树的性质。用分块来支持区间操作即可。代码。 刷综合 [Ynoi E2015] 人人本着正义之名 Portal. 首先看一看操作 3∼63\\sim 63∼6 是个什么东西。 将 [l,r−1][l,r-1][l,r−1] 中的数 aia_iai​ 同时变为 aia_iai​ 与 ai+1a_{i+1}ai+1​ 按位或的值？简单，就是所有极长 000 段最右边一个 000 变成 111。 搞一个平衡树，打一个标记表示左右端点的移动量。只有两个问题： 如何保证区间极长？区间染色时向左右拓展一下即可。 如何保证没有空区间？区间数量是 O(n+m)O(n+m)O(n+m) 的，维护最短 01 区间长度，暴力找，然后将其左右区间合并即可。 本质上不难，但代码比较壮观，需要使用指针实现平衡树进行卡常，代码。"},{"title":"扫描线","path":"/wiki/oi-note/2-4.html","content":"对于一个高维空间的坐标限制，我们称之为 BBB 维正交范围问题，我们可以利用扫描线将其降维。也就是说，扫描线维护一维，数据结构维护另一维。 差分处理 如果维护的信息可以差分，那么直接差分掉。比如矩形面积并问题，静态区间内不同数个数问题。将问题转化为矩形操作，然后扫描线维护。 此问题的基础形态是二维数点：平面上有 nnn 个点 (i,ai)(i,a_i)(i,ai​)，每次查询一个矩形内的点的个数。此矩形是一个 4-side 的矩形，可以通过差分的方式将其转化为 3-side，然后再扫描线维护一下变成 2-side，这样就成了一个平凡的单点修改区间查询的问题。 也就是说，差分和扫描线是我们的降维手段，最后一个 2-side 的问题就是平凡的，使用合适的数据结构（区间修改单点查询，单点修改区间查询，区间修改区间查询）维护即可。 这是二维数点的模板，其转化成单点加查询区间和。 矩形面积并 模板。转化成网格图上去做，扫描线扫描矩形的竖线，转化成区间加查询全局 000 的数的个数，因此维护区间最小值（对于全局来说必然是 000）和最小值个数即可，使用动态开点线段树可以很方便地写出来。 #include bits/stdc++.husing namespace std;typedef long long i64; const int N = 1e5 + 5;const int I = 1e9 + 2;int n;int b[N * 2], xs[N * 2];int stot;struct Scanning_Line int x, y, _y, val; Scanning_Line(int x = 0, int y = 0, int _y = 0, int val = 0) : x(x), y(y), _y(_y), val(val) bool operator (const Scanning_Line a) const return x a.x; S[N * 2];// 查区间 0 的数的个数// 区间最小值，区间最小值的个数struct Node int mn, mncnt; Node(int mn = 0, int mncnt = 0) : mn(mn), mncnt(mncnt) friend Node operator+ (const Node a, const Node b) Node c; c.mn = min(a.mn, b.mn); if (a.mn == c.mn) c.mncnt += a.mncnt; if (b.mn == c.mn) c.mncnt += b.mncnt; return c; T[N * 70];int tag[N * 70];int ls[N * 70], rs[N * 70];int tot = 1;inline void maketag(int o, int x) tag[o] += x; T[o].mn += x;inline void pushdown(int o) if (!tag[o]) return; maketag(ls[o], tag[o]); maketag(rs[o], tag[o]); tag[o] = 0;void update(int o, int l, int r, int x, int y, int k) if (x = l r = y) return maketag(o, k); int mid = l + r 1; if (!ls[o]) ls[o] = ++tot; rs[o] = ++tot; T[ls[o]] = Node(T[o].mn, mid - l + 1); T[rs[o]] = Node(T[o].mn, r - mid); tag[o] = 0; else pushdown(o); if (x = mid) update(ls[o], l, mid, x, y, k); if (mid y) update(rs[o], mid + 1, r, x, y, k); T[o] = T[ls[o]] + T[rs[o]];int main(void) ios::sync_with_stdio(0); cin n; for (int i = 1; i = n; ++i) int x, y, _x, _y; cin x y _x _y; --_x, --_y; S[++stot] = Scanning_Line(x, y, _y, 1); S[++stot] = Scanning_Line(_x + 1, y, _y, -1); sort(S + 1, S + stot + 1); for (int i = 1; i = stot; ++i) xs[i] = S[i].x; int m = unique(xs + 1, xs + stot + 1) - (xs + 1); i64 ans = 0; T[1].mncnt = I + 1; for (int i = 1, j = 0; i = m; ++i) if (i 1) ans += 1ll * (xs[i] - xs[i - 1]) * (I + 1 - T[1].mncnt); while (j stot S[j + 1].x == xs[i]) ++j, update(1, 0, I, S[j].y, S[j]._y, S[j].val); cout ans ; return 0; [SDOI2009] HH 的项链 二维扫描线 本质上是莫队，不在本文中介绍。"},{"title":"简单树形问题","path":"/wiki/oi-note/3-1.html","content":"树链剖分 每次跳重链即可完成树上 K 级祖先问题，而且通常比长链剖分快。 树上启发式合并 本质上是枚举每个节点时，直接枚举子树来计算答案的一种暴力。但是由启发式合并，我们可以最后枚举重儿子的信息，然后直接保留，这样就可以在统计父亲答案时不再重新枚举重儿子的信息。 void dfs(int x, bool keep) for (int y : T1.G[x]) if (y != T1.fa[x] y != T1.son[x]) dfs(y, 0); if (T1.son[x]) dfs(T1.son[x], 1); for (int y : T1.G[x]) if (y != T1.fa[x] y != T1.son[x]) for (int i = T1.dfn[y]; i = T1.dfn[y] + T1.sz[y] - 1; ++i) ... for (int i = T1.dfn[y]; i = T1.dfn[y] + T1.sz[y] - 1; ++i) add(T2.dfn[T1.idx[i]], 1); add(T2.dfn[x], 1); if (!keep) for (int i = T1.dfn[x]; i = T1.dfn[x] + T1.sz[x] - 1; ++i) add(T2.dfn[T1.idx[i]], -1); 例题 [北京市赛 2025] 最近公共祖先 Portal. LCA 问题显然考虑枚举 LCA 是什么，于是在第一棵树上启发式。当枚举到一个新的节点时，如果它在第二棵树上是 LCA 的儿子，那么要统计此时第二棵树上 LCA 的子树中被“激活”了多少个节点，减去枚举节点所对应的小子树内的被激活的节点。代码。 [Nanjing Regional 2025] Cyan White Tree Portal. 需要在 LCA 处统计信息不难考虑启发式合并。强制令 c≥wc\\ge wc≥w，那么只需要在线段树上查询一个后缀最大值即可。 唯一的问题是在保留重儿子信息时，需要将其加上当前节点的信息。也就是说，区间修改然后平移。但是是全部平移，因此直接在线段树上打 tag 然后记一个偏移量 delta 即可。代码。"},{"title":"树分治","path":"/wiki/oi-note/3-2.html","content":"点分治 例题 [qoj837] Giant Penguin Portal. 图上做这个有点过于恐怖了，先考虑树上。 求一条从某个关键点出发的路径的贡献，那么点分治，一定是某个关键点走到分治中心，然后再从分治中心走到某个点。 抓一棵生成树出来，那么对于每个分治点最多只有 kkk 条边跨越它，经过这些边也可以视作跨越的分治点。因此直接对最多 2k+12k+12k+1 个点跑 BFS 即可，代码。"},{"title":"组合计数","path":"/wiki/oi-note/4-1.html","content":"到处都能见到它的身影，它是一切数数题的基础。 概念基础 基本定义与一些常见公式与方法。 排列数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照一定的顺序排成一列，方案个数记作 AnmA_{n}^{m}Anm​，有 Anm=n!(n−m)!A_{n}^{m}=\\cfrac{n!}{(n-m)!}Anm​=(n−m)!n!​。 一个有限集合 SSS 到自身的双射称为 SSS 的一个置换，集合 S=a1,⋯ ,anS={a_1,\\cdots,a_n}S=a1​,⋯,an​ 的置换可以表示为： f=(a1,a2,…,anap1,ap2,…,apn)f=\\begin{pmatrix}a_1,a_2,\\dots,a_n\\\\ a_{p_1},a_{p_2},\\dots,a_{p_n} \\end{pmatrix} f=(a1​,a2​,…,an​ap1​​,ap2​​,…,apn​​​) 是将 aia_iai​ 映射为 apia_{p_i}api​​，这样 ppp 是 1⋯n1\\cdots n1⋯n 的一个排列，SSS 上的所有置换的数量为 n!n!n!。 置换的过程可以使用有向图来理解，连边 i→pii\\rightarrow p_ii→pi​，就是所有点移动 111 的距离。置换中形成一个环的称为置换环，对于大小为 1,21,21,2 的置换环，原排列和置换显然是一样的。 对于两个置换 f,gf,gf,g 的乘积记作 f∘gf\\circ gf∘g，代表先通过 fff 的映射，再通过 ggg 的映射。 一个排列中的逆序对个数，也叫做反序数，如果是偶数就是偶排列，奇数则是奇排列。 对于一个排列 1,⋯ ,n1,\\cdots,n1,⋯,n，如果将任意两个数 i,ji,ji,j 交换，其它数保持不动，就会得到一个新的排列，那么这样一个变换叫做对换，用 (i,j)(i,j)(i,j) 表示。 组合数 从 nnn 个不同元素中，任取 mmm（m⩽nm\\leqslant nm⩽n）个元素按照任意的顺序组成一个集合，方案个数记作 (nm)\\binom n m(mn​)。组合数同时也是二项式系数，当 m0m0m0 时，组合数没有定义。 (nm)=n!(n−m)!m!=nm‾m!(nm)=(n−1m)+(n−1m−1)\\binom n m = \\frac{n!}{(n-m)!m!}=\\frac {n^{\\underline m}} {m!}\\\\ \\binom n m = \\binom {n-1} m + \\binom {n-1}{m-1} (mn​)=(n−m)!m!n!​=m!nm​​(mn​)=(mn−1​)+(m−1n−1​) 组合数有以下性质 / 恒等式： (nm)=(nn−m)\\dbinom n m = \\dbinom n {n - m}(mn​)=(n−mn​)； (nk)=n−k+1k(nk−1)\\dbinom{n}{k}=\\cfrac{n-k+1}{k}\\dbinom{n}{k-1}(kn​)=kn−k+1​(k−1n​)，常被用来递推组合数； (nr)(rk)=(nk)(n−kr−k)\\dbinom{n}{r}\\dbinom{r}{k}=\\dbinom{n}{k}\\dbinom{n-k}{r-k}(rn​)(kr​)=(kn​)(r−kn−k​)； 吸收恒等式：(rk)=rk(r−1k−1)\\dbinom{r}{k}=\\dfrac{r}{k}\\dbinom{r-1}{k-1}(kr​)=kr​(k−1r−1​)，当二项式外有一个无用的系数时，我们可以将它“吸收”进二项式系数。 下指标求和（行求和）：∑i=0n(ni)=2n\\displaystyle \\sum_{i=0}^{n}\\binom{n}{i}=2^ni=0∑n​(in​)=2n，相当于是二项式定理中 a=b=1a=b=1a=b=1。注意这个东西是很特殊的完整一行，一般的行求和是无法快速计算的。它还有变式： ∑i=0n(−1)i(ni)=0\\displaystyle \\sum_{i=0}^{n}(-1)^i\\binom{n}{i}=0i=0∑n​(−1)i(in​)=0，这是二项式定理中 a=1,b=−1a=1,b=-1a=1,b=−1； ∑i=0ni×(ni)=n2n−1\\displaystyle \\sum_{i=0}^{n}i\\times \\binom{n}{i}=n2^{n-1}i=0∑n​i×(in​)=n2n−1，因为 m×(nm)=n×(n−1m−1)m\\times \\dbinom{n}{m}=n\\times \\dbinom{n-1}{m-1}m×(mn​)=n×(m−1n−1​)。 上指标求和（列求和）：∑i=0n(im)=(n+1m+1)\\displaystyle \\sum_{i=0}^{n}\\binom{i}{m}=\\binom{n+1}{m+1}i=0∑n​(mi​)=(m+1n+1​)，可以看作是枚举第 m+1m+1m+1 个数的位置 i+1i+1i+1。 对角线求和：∑i=0n(m+ii)=(m+n+1n)\\displaystyle\\sum_{i=0}^{n}\\binom{m+i}{i}=\\binom{m+n+1}{n}i=0∑n​(im+i​)=(nm+n+1​)，反复利用 Cnm=Cn−1m+Cn−1m−1C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}Cnm​=Cn−1m​+Cn−1m−1​ 即可证明。 范德蒙德卷积：∑i=0k(ni)(mk−i)=(n+mk)\\displaystyle \\sum_{i=0}^k\\binom{n}{i}\\binom{m}{k-i}=\\binom{n+m}{k}i=0∑k​(in​)(k−im​)=(kn+m​)。从组合意义上很容易证明（枚举 nnn 和 mmm 中选的个数），常用于合并组合数，考虑它的推论： ∑i=1n(ni)(ni−1)=(2nn−1)\\displaystyle \\sum_{i=1}^n\\binom{n}{i}\\binom{n}{i-1}=\\binom{2n}{n-1}i=1∑n​(in​)(i−1n​)=(n−12n​)，证明很简单，因为 (ni−1)=(nn−i+1),(2nn−1)=(2nn+1)\\dbinom{n}{i-1}=\\dbinom{n}{n-i+1},\\dbinom{2n}{n-1}=\\dbinom{2n}{n+1}(i−1n​)=(n−i+1n​),(n−12n​)=(n+12n​)； ∑i=0n(ni)2=(2nn)\\displaystyle\\sum_{i=0}^n\\binom{n}{i}^2=\\binom{2n}{n}i=0∑n​(in​)2=(n2n​)，证明基本同理； ∑i=0m(ni)(mi)=(n+mm)\\displaystyle\\sum_{i=0}^m\\binom{n}{i}\\binom{m}{i}=\\binom{n+m}{m}i=0∑m​(in​)(im​)=(mn+m​)，这个也是网格图路径计数方案。 Lucas 定理。若 ppp 是质数，则 (nm) mod p=(⌊n/p⌋⌊m/p⌋)⋅(n mod pm mod p) mod p\\displaystyle\\binom{n}{m}\\bmod p = \\binom{\\left\\lfloor n/p \\right\\rfloor}{\\left\\lfloor m/p\\right\\rfloor}\\cdot\\binom{n\\bmod p}{m\\bmod p}\\bmod p(mn​)modp=(⌊m/p⌋⌊n/p⌋​)⋅(mmodpnmodp​)modp，常用于 ppp 较小的情况。 组合数奇偶性公式。(nm)≡1(mod2) ⟺ n m=m\\displaystyle \\binom{n}{m}\\equiv 1 \\pmod 2 \\iff n\\ \\ \\ m=m(mn​)≡1(mod2)⟺n m=m，使用 Lucas 定理来证明，需保证不出现 (01)\\dbinom{0}{1}(10​)。 Kummer 定理。(n+mn)\\dbinom{n+m}{n}(nn+m​) 中质因子 ppp 的次数为 n+mn+mn+m 在计算时 ppp 进制意义下的进位次数，等价于 (nm)\\dbinom n m(mn​) 中质因子 ppp 的次数等于在计算 n−mn-mn−m 时 ppp 进制意义下的借位次数。其中 ppp 是素数。 上指标翻转。(nk)=(−1)k(k−n−1k)\\displaystyle \\binom n k = (-1)^k\\binom{k-n-1}{k}(kn​)=(−1)k(kk−n−1​)。 多重组合数。是指先选 n1n_1n1​，再选 n2n_2n2​，以此类推。有（∑ni=n\\sum n_i = n∑ni​=n）： (nn1,…,nk)=n!∏i=1kni!\\binom{n}{n_1,\\dots,n_k}=\\frac{n!}{\\prod_{i=1}^k n_i!} (n1​,…,nk​n​)=∏i=1k​ni​!n!​ 组合方法。在小学学过一些常用的组合方法。 捆绑法插空法插板法nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子关系特别好，它们一定要站在一块。那么有多少种排列方法？我们把这 mmm 只兔子看作一只大兔子，那么总共就有 n−m+1n-m+1n−m+1 只兔子，排列方案数是 (n−m+1)!(n-m+1)!(n−m+1)!，然而大兔子里面也有 m!m!m! 中方法，那么总方法数就是 (n−m+1)!m!(n-m+1)!m!(n−m+1)!m!。这就是捆绑法。nnn 只兔子参观大连市第二十四中学，其中 mmm 只兔子有着不共戴天之仇，它们一定要不能站在一块。那么有多少种排列方法？我们先把 n−mn-mn−m 只兔子给排列好，有 (n−m)!(n-m)!(n−m)! 种方法。这些兔子之间有 (n−m+1)(n-m+1)(n−m+1) 个空（算最左和最右），再把这些不共戴天的兔子放到这些空里，有 An−m+1mA_{n-m+1}^{m}An−m+1m​ 个方法。总方案数就是 (n−m)!×An−m+1m(n-m)!\\times A_{n-m+1}^{m}(n−m)!×An−m+1m​。这就是插空法。james1 要将 nnn 个相同的胡萝卜分给 mmm 只兔子，他秉持雨露均沾的原则，每只兔子至少分到 111 根胡萝卜，有多少种方案？我们先介绍隔板法（插板法），是指在 nnn 个元素的 n−1n-1n−1 个空中插入 kkk 个板，可以把 nnn 个元素分为 k+1k+1k+1 组。我们把这 nnn 个胡萝卜排成 111 行，当中就有 n−1n-1n−1 个空。现在往里面插入 m−1m-1m−1 个板，就可以将胡萝卜分为 mmm 组，正好可以分给 mmm 只兔子，而且由于不存在在同一个地方插两个板的情况，所以正好每一只兔子都能至少分到 111 根胡萝卜。那么答案就是 (n−1m−1)\\dbinom{n-1}{m-1}(m−1n−1​)。实际上这个问题相当于求不定方程 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的正整数解的数量。如果他是个大魔王（不可能，绝对不可能），有的兔子可能 111 根胡萝卜都得不到，那么有多少种方案？同样的方法，如果允许有兔子分到 000 根胡萝卜，我们只需要再加上 mmm 根胡萝卜，就相当于刚才的问题了。答案是 (n+m−1m−1)=(n+m−1n)\\dbinom{n+m-1}{m-1}=\\dbinom{n+m-1}{n}(m−1n+m−1​)=(nn+m−1​)。这个问题本质上是要求 x1+x2+⋯+xm=nx_1+x_2+\\cdots+x_m=nx1​+x2​+⋯+xm​=n 的自然数解的数量。 经典问题 介绍一些经典问题。 树的拓扑序计数 对于一个 nnn 个点的树，其拓扑序数量为 n!∏szu\\dfrac{n!}{\\prod sz_u}∏szu​n!​。 证明采用归纳法： ans=(n−1szv1,szv2,⋯ ,szvk)∏szvi!∏w∈subtree⁡(vi)szw=(n−1)!szv1!szv2!⋯szvk!×∏szvi!×n∏szu=n!∏szu\\begin{aligned} ans=\\binom{n-1}{sz_{v_1},sz_{v_2},\\cdots,sz_{v_k}}\\prod \\frac{sz_{v_i}!}{\\prod_{w\\in \\operatorname{subtree}(v_i)}sz_w}\\\\ =\\frac{(n-1)!}{sz_{v_1}!sz_{v_2}!\\cdots sz_{v_k}!}\\times \\prod sz_{v_i}! \\times \\frac{n}{\\prod sz_u}\\\\ =\\dfrac{n!}{\\prod sz_u} \\end{aligned} ans​=(szv1​​,szv2​​,⋯,szvk​​n−1​)∏∏w∈subtree(vi​)​szw​szvi​​!​=szv1​​!szv2​​!⋯szvk​​!(n−1)!​×∏szvi​​!×∏szu​n​=∏szu​n!​​ 常见计数数列 错排数 指 pi≠ip_i e ipi​=i 的排列个数，有 fn=(n−1)(fn−1+fn−2)f_n=(n-1)(f_{n-1}+f_{n-2})fn​=(n−1)(fn−1​+fn−2​)。因为我们要用恰好一次操作将 nnn 放进错位排列里，因此只有这两种转移。"},{"title":"容斥原理","path":"/wiki/oi-note/4-2.html","content":"概述 容斥原理是非常重要的计数原理： ∣⋃i=1nSi∣=∑m=1n(−1)m−1∑aiai+1∣⋂i=1mSai∣\\left|\\bigcup_{i=1}^{n}S_i\\right|=\\sum_{m=1}^n(-1)^{m-1}\\sum_{a_ia_{i+1} }\\left|\\bigcap_{i=1}^mS_{a_i}\\right| ​i=1⋃n​Si​​=m=1∑n​(−1)m−1ai​ai+1​∑​​i=1⋂m​Sai​​​ 集合的交集可以使用补集容斥原理来求解： ∣⋂i=1nSi∣=∣U∣−∣⋃i=1nSi‾∣\\left|\\bigcap_{i=1}^{n}S_i\\right|=|U|-\\left|\\bigcup_{i=1}^n\\overline{S_i}\\right| ​i=1⋂n​Si​​=∣U∣−​i=1⋃n​Si​​​ 容斥原理最经典的用处是“至少”与“恰好”之间的转化，实际上是一个子集反演的过程。子集反演是针对集合交并的容斥，可以在恰好是某个集合和至多/至少是这个集合反演。 我们先来看与至多是这个集合的反演。现在有其元素满足某种条件的集合 AAA。定义 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 代表 S⊆AS\\subseteq AS⊆A 时的答案。 钦定选了 SSS 这个集合中的子集 TTT，有 g(S)=∑T⊆Sf(T)g(S)=\\sum_{T\\subseteq S}f(T)g(S)=∑T⊆S​f(T)，这时有 f(S)=∑T⊆S(−1)∣S∣−∣T∣g(T)f(S)=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}g(T)f(S)=∑T⊆S​(−1)∣S∣−∣T∣g(T)。使用容斥原理不难感性理解。 类似的，如果 f(S)f(S)f(S) 代表 S=AS=AS=A 时的答案，g(S)g(S)g(S) 表示 A⊆SA\\subseteq SA⊆S 时的答案，有 g(S)=∑S⊆Tf(T)g(S)=\\sum_{S\\subseteq T}f(T)g(S)=∑S⊆T​f(T)，反演得 f(S)=∑S⊆T(−1)∣T∣−∣S∣g(T)f(S)=\\sum_{S\\subseteq T}(-1)^{|T|-|S|}g(T)f(S)=∑S⊆T​(−1)∣T∣−∣S∣g(T)。 这是容斥原理的代数形式，它是我们用容斥原理解决问题的基础。因为在钦定时，一个“有两个元素满足条件”的东西会在“至少有一个元素满足条件”的东西计算时计算两次，也就因此成了一个子集反演的形式。"},{"title":"图的相关概念","path":"/wiki/oi-note/5-1.html","content":"一张图 GGG 由点集 VVV 和边集 EEE 构成。我们用 d(v)d(v)d(v) 代表节点 vvv 的度数，如果 d(v)=∣V∣−1d(v)=|V|-1d(v)=∣V∣−1，则称 vvv 为支配点。如果每个点的度数都是 kkk，则该图为 k−k-k−正则图。 子图 对一张图 G=(V,E)G = (V, E)G=(V,E)，若存在另一张图 H=(V′,E′)H = (V, E)H=(V′,E′) 满足 V′⊆VV \\subseteq VV′⊆V 且 E′⊆EE \\subseteq EE′⊆E，则称 HHH 是 GGG 的子图，记作 H⊆GH \\subseteq GH⊆G。 若对 H⊆GH \\subseteq GH⊆G，满足 ∀u,v∈V′\\forall u, v \\in V∀u,v∈V′，只要 (u,v)∈E(u, v) \\in E(u,v)∈E，均有 (u,v)∈E′(u, v) \\in E(u,v)∈E′，则称 HHH 是 GGG 的导出子图。点集为 V′(V′⊆V)V(V \\subseteq V)V′(V′⊆V) 的导出子图称为 V′VV′ 导出的子图，记作 G[V′]G \\left[ V \\right]G[V′]。 若 H⊆GH \\subseteq GH⊆G 满足 V′=VV = VV′=V，则称 HHH 为 GGG 的生成子图/支撑子图。 如果一张无向图 GGG 的某个生成子图 FFF 为 k−k-k−正则图，则称 FFF 为 GGG 的一个 k−k-k−因子。 如果有向图 G=(V,E)G = (V, E)G=(V,E) 的导出子图 H=G[V∗]H = G \\left[ V^\\ast \\right]H=G[V∗] 满足 ∀v∈V∗,(v,u)∈E\\forall v \\in V^\\ast, (v, u) \\in E∀v∈V∗,(v,u)∈E，有 u∈V∗u \\in V^\\astu∈V∗，则称 HHH 为 GGG 的一个闭合子图。也就是说，图内部是闭合的，不存在一个点在导出子图内，可以通过原图的一条边连到一个不在导出子图内的点。 特殊的图 对于无向简单图，所有本来在图上的边都不在，本来不在的都在，那么这个图就是原无向图的补图。 对于有向图，每条边的方向取反，得到的图就是原图的反图。 特殊集合 一些特殊的点和边的集合有着特殊的意义，这里我们介绍一些常见的。 支配集 对于无向图，如果一个点集的点可以连接到原图的所有点，那么这个点集为原图的支配集。 最小支配集是 NPH 的，我们通常使用 O(2n)O(2^n)O(2n) 的枚举算法来求解支配集。 独立集 就是任意两点不相邻的点集。对于树和二分图我们有高效做法，但是一般图上，这个问题是 NPH 的。 匹配 对于图 G=(V,E)G=(V,E)G=(V,E)，若 E′∈EE\\in EE′∈E 且 E′EE′ 中任意两条边都没有公共端点，且 E′EE′ 中没有自环，那么 E′EE′ 是 GGG 的一个匹配，也称为边独立集。如果一个点被匹配的边连接了，那么它就是被匹配的，否则就是不被匹配的。 边数最多的称为最大匹配，如果边带权，那么权重之和最大的匹配称为图的最大权匹配。 如果一个匹配在加入任何一条边后都不再是一个匹配，那么这个匹配就是极大匹配，最大匹配一定是极大匹配。 如果所有点都被匹配了，那么这个匹配是完美匹配。如果在一个匹配中只有一个点不被匹配，那么该匹配为准完美匹配。 对于一个匹配 MMM，若一条路径以非匹配点为起点，每相邻两条边中的一条在匹配中而另一条不在匹配中，那么这条路径称为交替路径；一条非匹配点终止的交替路径称为增广路径。 点覆盖 如果所有边都至少有一个端点在这个点集中，那么这个点集被称为点覆盖集。 点覆盖集一定是支配集，但是极小点覆盖集不一定是极小支配集（考虑一个三元环）。 点覆盖集拥有以下性质： 一个点集是点覆盖的充要条件是其补集是独立集。 一张图的任何一个匹配的大小都不超过其任何一个点覆盖的大小。 边覆盖 当前边集满足任何一个点都至少是其中一条边的一个端点，那么这个边集称为边覆盖集。 如果知道了最大匹配，那么将所有非匹配点都连一条边加入最大匹配，那么就得到了一个最小边覆盖。同理，如果知道了最小边覆盖，那么将有公共点的边删去到只剩一条就得到了最大匹配。 团 一个图的子点集 V′VV′ 中任意两个不同的顶点都相邻，则称 V′VV′ 是图 GGG 的一个团。团对应的导出子图是完全图。说白了最大团就是最大完全子图。 显然地，最大团等于补图的最大独立集。 求解一个图的最大团是 NPH 的，可以使用最大团搜索算法（在暴力枚举的基础上加一个不可能成为答案的最优性剪枝）来解决规模较小的图的问题。 例题 你可能会问：这里为什么有题呢？嗯，主要是建立在图结构上的一些奇奇怪怪的问题。 刷基础 I [3rd ucup s8] Challenge Matrix Multiplication Portal。考虑针对题目条件的势能的做法。每次找到一条路径然后删除这条路径上的所有边，使得起点出度减一，终点入度减一，因此找到这条路径之后暴力做即可，时间复杂度 O(60(n+m))O(60(n+m))O(60(n+m))。代码。 [CF1810E] Monsters Portal. 如果直接做的话，考虑一个被一个大点分割成两部分的图，这样左半部分和右半部分都是跑满的。 但实际上，如果一个出生点可以从另一个出生点走过来，那么这个出生点就没必要重新计算了。我直觉感觉这玩意儿是 O(nlog⁡n)O(n\\log n)O(nlogn) 的，但是这不对。 设 D(x)D(x)D(x) 表示 xxx 为出生点可以走到的点集。假设 u∈D(x),D(y)u\\in D(x),D(y)u∈D(x),D(y)，而且 ∣D(x)∣∣D(y)∣|D(x)| |D(y)|∣D(x)∣∣D(y)∣，那么 yyy 能够走到 xxx 但是 xxx 不能走到 yyy。以中间那个阻止 xxx 继续前进的点分割，yyy 必然有不小于 xxx 的规模，因此 2∣D(x)∣≤∣D(y)∣2|D(x)|\\le |D(y)|2∣D(x)∣≤∣D(y)∣。因此任意一个点最多只会被计算 log⁡n\\log nlogn 个有效出生点计算到。证得 O(nlog⁡2n)O(n\\log^2 n)O(nlog2n)。代码。"},{"title":"生成树问题","path":"/wiki/oi-note/5-2.html","content":"例题 刷基础 [4th ucup s1] Yet Another MST Problem Portal. 仿照 Kruskal 算法的流程，按照边权从小到大考虑，找不存在 mexmexmex 的区间，将它们合并。注意到合并后得到的新区间可以视作两区间的交集，因此直接做即可。代码。"},{"title":"连通性问题","path":"/wiki/oi-note/5-3.html","content":"有向图的强连通性 例题 [ICPC 2024 Hangzhou] Fuzzy Ranking Portal. 每个排序关系依次连边，然后 SCC 缩点，一个点对在同一个 SCC 里视作合法的。 然后如何查询？不难猜测 SCC 编号一定是形如一段一段的连续段，没有属于同一个 SCC 却是断开的。使用反证法，假定存在一个排名其 SCC 编号依次是 1 2 2 1，那么对于四个学校来说，有 1 2 3 4（初始的），根据这个信息有 2 3, 1 4，但是 1 4 3 2，说明 222 和 444 在一个 SCC 里，矛盾。 因此直接做即可。代码。"},{"title":"最短路问题","path":"/wiki/oi-note/5-4.html","content":"概述 对于无权图（01 带权），可以使用 BFS 求解最短路。 对于多源最短路，可以使用 Floyd 算法，也就是通过 nnn 轮 DP 来求解最短路。 对于单源最短路，可以使用 Dijkstra 和 SPFA。Dijkstra 基于贪心的思想，每次寻找当前最短的路来走，正确性基于边权非负；SPFA 则通过 O(nm)O(nm)O(nm) 的迭代来更新最短路，进而可以判断负环的存在性。 Johnson 通过将边改造为 (u,v,w+du−dv)(u,v,w+d_u-d_v)(u,v,w+du​−dv​) 来实现，边权是三角形不等式来满足 ≥0\\ge 0≥0，建立超级源点跑 SPFA 即可。 #include bits/stdc++.husing namespace std; typedef long long i64; const int N = 3e3 + 5; const int INF = 1e9; int n, m, cnt[N]; vectorpairint, i64 G[N]; i64 d[N], h[N]; bool vis[N], inq[N]; void Dijkstra(int s) fill(d, d + n + 1, INF); memset(vis, 0, sizeof vis); #define pil pairint, i64 priority_queuepil, vectorpil, greaterpil q; q.emplace(d[s] = 0, s); while (!q.empty()) int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto [v, w] : G[u]) if (d[v] d[u] + w) q.emplace(d[v] = d[u] + w, v); void SPFA(int s) fill(d, d + n + 1, INF); d[s] = 0; queueint q; q.push(s); inq[s] = 1; while (!q.empty()) int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : G[u]) if (d[v] d[u] + w) d[v] = d[u] + w; cnt[v] = cnt[u] + 1; if (cnt[v] n + 1) cout -1 , exit(0); if (!inq[v]) q.push(v), inq[v] = 1; int main(void) ios::sync_with_stdio(0); cin n m; while (m--) int u, v, w; cin u v w; G[u].emplace_back(v, w); for (int i = 1; i = n; ++i) G[0].emplace_back(i, 0); SPFA(0); for (int u = 1; u = n; h[u] = d[u], ++u) for (auto [v, w] : G[u]) w += d[u] - d[v]; for (int i = 1; i = n; ++i) Dijkstra(i); i64 ans = 0; for (int j = 1; j = n; ++j) if (d[j] == INF) ans += 1ll * j * INF; else ans += j * (d[j] + h[j] - h[i]); cout ans ; return 0; 如果我们要求的是最短简单路径（有负环），那么它是一个 NPC 问题。 差分约束 根据三角形不等式进行连边，然后用 SPFA 判断负环。 值得注意的是，如果使用 SPFA 求最短路，那么得到的是字典序最大的解。对于字典序最小的解，只需要将约束条件统统变为 xi−xj≥yx_i-x_j\\ge yxi​−xj​≥y，然后跑最长路，有正环时无解（就是边的方向和权值都取反）。 [省选联考 2021 A 卷] 矩阵游戏。答案的构造是容易的，然后需要调整这个答案，让每一行和列依次 +1,−1+1,-1+1,−1，然后错开，直接差分约束即可。代码。 斯坦纳树 如果给定 nnn 个点，试求连接此 nnn 个点，总长最短的直线段连接系统，并且并且任意两点都可以通过系统中的直线段组成的折线连接起来，此问题被称为斯坦纳树问题。遗憾的是，这是一个 NPH 问题。 最小斯坦纳树。给定一个 nnn 个点 mmm 条边无向图 G=(V,E)G=(V,E)G=(V,E)，再给定包含 kkk 个节点的点集 SSS，选出 GGG 的连通子图 G′=(V′,E′)G=(V,E)G′=(V′,E′)，要求：S⊆V′S \\subseteq VS⊆V′，E′EE′ 中所有边的权值和最小。你需要求出这个最小权值和，n≤100,m≤500,k≤10n\\le 100,m\\le 500,k\\le 10n≤100,m≤500,k≤10。 并不是直接将 SSS 连接起来就是最小的，可能需要借助剩下的 n−kn-kn−k 个点。这种问题可以使用状压 DP 来解决： 设 f(i,S)f(i,S)f(i,S) 表示以 iii 为根的一棵树，包含集合 SSS 中所有点的最小边权值和。有转移：f(i,S)←min⁡{f(i,T)+f(i,S−T)},f(i,S)←min⁡{f(j,S)+w(i,j)}f(i,S)\\leftarrow\\min\\{f(i,T)+f(i,S-T)\\},f(i,S)\\leftarrow\\min\\{f(j,S)+w(i,j)\\}f(i,S)←min{f(i,T)+f(i,S−T)},f(i,S)←min{f(j,S)+w(i,j)}。前者可以使用子集 DP 实现，后者可以跑一个最短路（由于图很难特殊构造而且规模很小，所以实际上更建议 SPFA）。代码。 Peach Blossom Spring，注意并不要求完全联通，最后子集和并一下即可。 平面图最小割 如果图 GGG 能画在平面 SSS 上，即除顶点处外无边相交，则称 GGG 可平面嵌入 SSS，GGG 为可平面图或平面图。画出的没有边相交的图称为 GGG 的平面表示或平面嵌入。 平面图可以转为对偶图，对偶图的最短路等于原平面图的最小割。给 GGG 的每个面搞一个点，两个面的公共边可以确定一条与其方向垂直的边。给源点和汇点连线可以将原图分成两个部分，跑最短路即可。 注意左侧和下侧，上侧和右侧分别是同一个点，从右上到左下的最短路即为左上到右下的最小割。模板，代码。 同余最短路 模板。这是一个最短路的变式问题。可以用于求解在某个范围内有多少重量可以由若干物品的完全背包凑出，就是多少数值可以由一些给定的数 bib_ibi​ 由 ∑aibi(ai≥0)\\sum a_i b_i(a_i\\ge 0)∑ai​bi​(ai​≥0) 得到。 我们可以发现，如果 xxx 可以被表示出，那么 x+kai(k0)x+ka_i(k0)x+kai​(k0) 就可以被表示出。因此我们找一个最小的 a1a_1a1​，然后连 j→(j+ai) mod a1j\\rightarrow (j+a_i)\\bmod a_1j→(j+ai​)moda1​ 的长度为 aia_iai​ 的边，然后我们从 000 开始跑最短路。由于这里图的形态不太能特殊构造，因此使用 SPFA 往往会跑的更快。最后求出的 fif_ifi​ 代表最小的能被凑出的数，满足 fi mod a1=if_i\\bmod a_1 =ifi​moda1​=i。代码。 答案的求解十分容易。[0,r][0,r][0,r] 的答案数量为： ∑i=0a1−1max⁡{0,⌊r−fia1⌋+1}\\sum_{i=0}^{a_1-1}\\max\\left\\{0,\\left\\lfloor\\frac{r-f_i}{a_1}\\right\\rfloor+1\\right\\} i=0∑a1​−1​max{0,⌊a1​r−fi​​⌋+1} 但为什么要使用最短路呢？实际上这东西是体积模 mmm 意义下的完全背包，如果重复经过一个点，那么可以选择 mgcd⁡(vi,m)−1\\frac{m}{\\gcd(v_i,m)}-1gcd(vi​,m)m​−1 个这类物品。也就是说，会在大小为 mmm 的环上形成 gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m) 个子环。 那么在每个子环上转两圈即可统计到所有转移，时间复杂度 O(nm)O(nm)O(nm)。代码。 [THUPC 2023] 背包。完全背包，但是 V≥1011V\\ge 10^{11}V≥1011。 如果我们将密度最大的物品选做基准物品，那么其它物品的选择可以替换为若干基准物品，这样可以最大化贡献。设基准物品体积为 www，贡献为 mmm。 设 fif_ifi​ 代表最大的贡献，满足 V mod m=iV\\bmod m=iVmodm=i。最终权值为 fi+V−V′mwf_i+\\frac{V-V}{m}wfi​+mV−V′​w，因此要最大化 V−V′mV-\\frac{V}{m}V−mV′​，因此贡献应该是 fp+ci−p+vimwf_p+c_i-\\frac{p+v_i}{m}wfp​+ci​−mp+vi​​w。 可以发现每个 fif_ifi​ 对应的物品个数一定是不超过 vvv 的，因此这一部分总容积不超过 v2≤Vv^2\\le Vv2≤V，不存在误判成有解的情况。代码。 删边最短路 模板。给定一张带权无向图，每个询问独立，将一条边的边权改变，询问当前 1∼n1\\sim n1∼n 的最短路。 求出 1,n1,n1,n 的最短路树 T1,TnT_1,T_nT1​,Tn​。如果改的边不是最短路上的边的答案是好算的，否则，我们要算出强制不经过一条边的新的最短路。 我们可以证明，一定可以枚举一条边 (u,v)(u,v)(u,v)，然后 1→u,v→n1\\rightarrow u,v\\rightarrow n1→u,v→n 走的都是最短路。 我们需要保证 T1,TnT_1,T_nT1​,Tn​ 上 1∼n1\\sim n1∼n 的最短路是相同的一条，否则无法计算。 求出 p1ip1_ip1i​ 代表 T1(1→i)T_1(1\\rightarrow i)T1​(1→i) 与更新路径的最后一个交点（在最短路树上跳，第一个到的最短路上的点，就是 iii 与 nnn 的 LCA），pnipn_ipni​ 同理。 这样维护先修改再单点查询的区间 ckmin 即可。代码。 显然，这种做法并不能在有向图上成立，因为不在最短路上的边可能不止一条。但是，走的路径依然满足中间只有一段不在最短路上的路径。 k 短路 先建出一棵以 ttt 为根的最短路树 TTT，xxx 到 ttt 的最短路径为 dxd_xdx​。设 s→ts\\rightarrow ts→t 的路径上不在 TTT 中的当前选择的路径的边集为 P′PP′，s→ts\\rightarrow ts→t 上的所有边为 PPP，那么满足： 将一条边 eee 的代价定义为 Δe=w−(du−dv)\\Delta e = w-(d_u-d_v)Δe=w−(du​−dv​)，那么 LP′=ds+∑e∈P′ΔeL_{P} = d_s + \\sum_{e\\in P} \\Delta eLP′​=ds​+∑e∈P′​Δe； 将 PPP 和 P′PP′ 中所有边按照 s→ts\\rightarrow ts→t 经过的顺序依次排列，那么对于 P′PP′ 中相邻的边 e1,e2e_1,e_2e1​,e2​，那么 ve1=ue2v_{e_1}=u_{e_2}ve1​​=ue2​​ 或者 ue2u_{e_2}ue2​​ 是 ve1v_{e_1}ve1​​ 在 TTT 上的祖先。 对于每一个合法的 P′PP′，有且仅有一个 PPP 与之对应。因为可以根据 P′PP′ 还原在 TTT 上选择了什么。 也就是说，我们现在要求满足性质 222 的第 kkk 小 LpL_pLp​。 我们记录最后一条边和当前 LpL_pLp​ 的值即可表示 P′PP′。初始我们将 111 所有在 TTT 上的祖先的所有的边中 Δe\\Delta eΔe 最小的一条边加入小根堆，然后扩展时只有两种选择： 删掉 P′PP′ 结尾的那条边，换成第二大的边； 从 P′PP′ 的结尾开始到 TTT 的路径上，选择最小的边加入。 已知我们开始的描述路径的方式是不漏的，而且我们相当于枚举了所有的待替换边是否进行替换，因此这么做是正确的。 时间复杂度 O(mlog⁡m+klog⁡k)O(m\\log m+k\\log k)O(mlogm+klogk)，模板，代码。 kkk 短路问题能够高效解决，得益于我们只需要一个点即可描述能够被替换的边，如果要输出 kkk 短路的方案，那么就只能做到 O(k(n+m)log⁡m+klog⁡k)O(k(n+m)\\log m+k\\log k)O(k(n+m)logm+klogk) 了。 例题 刷基础 I [Shenyang Regional 2025] The Bond Beyond Time Portal。x,yx,yx,y 不相邻是容易解决的。相邻时需要将两个点引到一个环上转圈，因此需要求最小环。数据范围很小，因此直接暴力删边求最短路以求最小环即可。代码。 [ZJCPC2025] Challenge NPC III Portal。相当于与是同色点之间的最短路应该大于 kkk，于是对每个颜色都跑多起点最短路，在反图上也跑一遍，就可以求出距离，需要记录次短路防止起点终点相同。代码。 刷综合 [THUSCH2017] 巧克力 Portal. 如果颜色数比较少的话直接用斯坦纳树做，但是颜色数很多，钦定的可能也很多。 kkk 很小，因此考虑将所有颜色随机映射到 [0,k)[0,k)[0,k)，然后求最小斯坦纳树即可求出最小的巧克力个数 www。这 kkk 个点被分配到不同的颜色时答案合法，正确概率是 k!/kkk!/k^kk!/kk。随机化做 200200200 次即可。 然后二分出中位数，将小于等于二分值的权值都设为 inf−1inf-1inf−1，大于的都设为 inf+1inf+1inf+1，然后最小斯坦纳树要 ≤w×inf\\le w\\times inf≤w×inf（infinfinf 设置为一个不会影响斯坦纳树选择的巧克力数的一个数即可）。代码。"},{"title":"前置知识","path":"/wiki/oi-note/7-1.html","content":"我们记字符集为 Σ\\SigmaΣ，字符串是由若干字符集中的元素构成的序列。 字符串哈希 即序列哈希，快速比较两个序列的相等情况。一般来讲我们采用 bbb 进制方式的哈希，即 f(s)=∑i=1lsi×bl−if(s)=\\sum_{i=1}^{l}s_i\\times b^{l-i}f(s)=∑i=1l​si​×bl−i。 inline u64 q(u64 *f, int l, int r) return f[r] - f[l - 1] * p[r - l + 1]; 最小表示法 模板，目的是求一个循环同构的字符串的最小字典序。 #include bits/stdc++.husing namespace std;const int N = 1e7 + 5;int n;char a[N];int getmin(void) int i = 0, j = 1; while (i n j n) int k = 0; while (k n a[(i + k) % n] == a[(j + k) % n]) ++k; if (a[(i + k) % n] a[(j + k) % n]) i += k + 1; else j += k + 1; if (i == j) ++i; return min(i, j);int main(void) ios::sync_with_stdio(0); cin.tie(0); cin n a; int v = getmin(); for (int i = 0; i n; ++i) cout a[(i + v) % n]; cout ; return 0;"},{"title":"状态设计","path":"/wiki/oi-note/6-1.html","content":"动态规划是 OI 最重要的部分之一。从学习与做题的角度来说，主要分为设计状态与优化两部分。其中前者更多的是做题和总结方法与套路，甚至需要一定的灵感；而后者相对吃经验。 值得注意的是，很多题目都要求我们在设计算法以前先将题目进行一定的转化，从而将一个不熟悉的模型转化为我们更容易把握的模型。这一点在动态规划的题目中体现的尤为明显。 在阅读本文之前，你应该对动态规划有基本的了解。 线性 DP 在线性结构上枚举每一维度进行转移的 DP。 [CF1810G] The Maximum Prefix。较复杂，见原题面。 直接做怎么做？设 fi,j,kf_{i,j,k}fi,j,k​ 表示前 iii 个数，当前前缀和为 jjj，最大前缀和为 kkk，然后枚举填什么刷表转移对于每个状态是 O(1)O(1)O(1) 的，虽然能做，但是状态数炸了。 需要合并无效状态。同时记录前缀和和最大前缀和有些冗余，从这里入手。考虑对于一段后缀，如果它本身的最大前缀和是 000，那么它不会对前面的贡献产生影响，这时可以直接确定排除掉这段后缀的前缀的答案，也就是题目所求。 设 fi,jf_{i,j}fi,j​ 代表考虑前 iii 个数，且满足 [i+1,n][i+1,n][i+1,n] 的最大前缀和为 jjj 的期望答案，答案是 fi,0f_{i,0}fi,0​。那么转移： 如果 j0j0j0，可以以 pip_ipi​ 的系数（第 i+1i+1i+1 位填 111）转移到 fi+1,j−1f_{i+1,j-1}fi+1,j−1​，1−pi1-p_i1−pi​ 的系数（第 i+1i+1i+1 位填 −1-1−1）转移到 fi+1,j+1f_{i+1,j+1}fi+1,j+1​。 如果 j=0j=0j=0，那么第 i+1i+1i+1 位一定是 −1-1−1，此时可以转移到 fi+1,0f_{i+1,0}fi+1,0​ 和 fi+1,1f_{i+1,1}fi+1,1​。 代码。 背包 背包的变种很多，且都比较简单。基本模型：01 背包、完全背包、多重背包、分组背包、方案数背包的撤回（将转移的东西减去即可）。 区间 DP 图上 DP 一般的图上 DP 建立在 DAG 结构上。 树上背包 * [福建省队集训 2019] 最大权独立集问题 Portal. 好题！如果你之前没怎么学明白，这道题能让你对树形背包的理解加深不少。 删点相当于什么？当前这个点的信息会走到与它连接的未被删去的点，也就是给边定向。那么不难发现问题相当于给边定向，然后每个点的权值是 ai×∣i能到达的点的个数∣a_i\\times |i 能到达的点的个数|ai​×∣i能到达的点的个数∣。 因此设 fx,if_{x,i}fx,i​ 代表连 fax→xfa_x \\to xfax​→x，xxx 可到达子树内（含本身）的 iii 个点（它不会到达子树外面的点）；gx,ig_{x,i}gx,i​ 代表连 x→faxx\\to fa_xx→fax​，xxx 可到达子树外的 iii 个点（在转移时，它的父亲不会关心它能到达子树中的几个点）。 现在考虑计算 xxx 点的答案。比如说要算 ggg，能根据其孩子的 ggg 信息来确定吗？不太方便，因为孩子的 ggg 和当前 xxx 选择了多少个孩子的 fff 是有关的。不一定不能做，总之不太方便。 本身 xxx 点还是要计算贡献的，因此我们不妨直接钦定其能走到树上的 jjj 个节点，然后关系到这个信息填进哪个 f,gf,gf,g 值，因此设 hi,jh_{i,j}hi,j​ 代表走到 iii 个子树内的点，总共能走到 jjj 个点的代价。算出 hhh 数组后不难求出 fx,gxf_x,g_xfx​,gx​。转移就不难了。 qoj14416 只是把 min⁡\\minmin 改成 max⁡\\maxmax，代码。 父亲向子树转移 [Nanjing Regional 2024] Topology Portal. 设状态为考虑子树内的信息是很奇怪的事情，因为你不知道外部的拓扑序是怎么排的。 因此设 fx,if_{x,i}fx,i​ 代表删除 xxx 子树内的所有节点（不含 xxx）之后，使得 xxx 的拓扑序为 iii 的拓扑序个数。转移的时候从父亲转移到儿子，每次考虑除了 yyy 以外 xxx 的所有儿子。代码。 换根 DP 如果我们需要对所有点都当作根进行一次树形 DP，那么我们可以使用换根 DP 来处理。 [AMPPZ 2023] Routing K-Codes Portal. 不难观察出只有二叉树是有答案的。其实就是根节点一定填 111（填 000 则删掉这个点），然后左右儿子一个填 2i2i2i 另一个填 2i+12i+12i+1，树形 DP 可以完成。 由于转移途中不止有加减法而且 DP 数组不止一个，换根可能很麻烦。推荐一种非常美观的换根写法：在第二次 DFS 时记录一个 Node 类型代表父亲的答案。重载 Node 类型的加法即可很方便的完成换根。 代码。 例题 [Jinan Regional 2024] DFS Order 2 Portal. 还是只能考虑父亲向子树转移，fx,if_{x,i}fx,i​ 表示 xxx 节点在 DFS 序中的 iii 号位置，然后转移到孩子。考虑在转到儿子之前，应该先遍历了一些其它儿子，然后再遍历完目标儿子之后再回来遍历其它孩子，是一个树形背包的形式，然后要乘上一些阶乘。 写起来挺爽。 代码。 状压 DP 与轮廓线 DP 动态 DP 其它 DP 一些杂项内容 插入法 数位 DP 一般的数位 DP 直接采用记忆化搜索实现即可。 手机号码，代码如下： #include bits/stdc++.husing namespace std;typedef long long i64;int num[15];int f[11][11][11][2][2][2];i64 dp(int p, int p1, int p2, bool unlim, bool d, bool _4, bool _8) if (_4 _8) return 0; if (p == 0) return d; if (unlim f[p][p1][p2][d][_4][_8] != -1) return f[p][p1][p2][d][_4][_8]; i64 res = 0; int mx = unlim ? 9 : num[p]; for (int i = 0; i = mx; ++i) res += dp(p - 1, i, p1, unlim || (i mx), d || (i == p1 i == p2), _4 || (i == 4), _8 || (i == 8)); if (unlim) f[p][p1][p2][d][_4][_8] = res; return res;i64 calc(i64 n) memset(f, 0xff, sizeof f); for (int i = 1; i = 11; ++i, n /= 10) num[i] = n % 10; i64 res = 0; for (int i = 1; i = num[11]; ++i) res += dp(10, i, -1, i num[11], 0, i == 4, i == 8); return res;int main(void) i64 l, r; cin l r; cout calc(r) - calc(l - 1) ; return 0; 例题 刷基础 1 只有 NOIP 难度。 [CSP-S 2024] 染色 Portal. 设 fif_ifi​ 代表考虑前 iii 位的答案。只有 lstailst_{a_i}lstai​​ 可以与 aia_iai​ 匹配，如果要匹配，中间一大段都要染成同一个颜色，计算这一段有多少贡献，从 flstai+1f_{lst_{a_i} + 1}flstai​​+1​ 转移过来。 记录前缀某一段的贡献即可快速计算任意一段有多少贡献。代码。 [2023 钉耙编程 1] Mr. Liang play Card Game Portal。很有合并的感觉！考虑区间 DP，最后你会将区间合到只剩一张牌，于是设一个四维状态就可以直接转移。代码。 刷提升 1 比较有趣。 [Ptz 2020 Summer Day4] Ternary String Counting Portal. O(n4)O(n^4)O(n4) 直接 fi,x,y,zf_{i,x,y,z}fi,x,y,z​ 记录每一个字符出现的位置，O(n3)O(n^3)O(n3) 记录前两个不同字符的出现位置。都需要前缀和优化。 状态数还是过多了，我们需要寻找一个方式简化。先把转移写出来（对于状态 f(i,j,k)f(i,j,k)f(i,j,k)，表示当前考虑到第 iii 位，与这一位不同的数字上一次出现的位置分别位 j,kj,kj,k，并且 jkjkjk）： f(i+1,i,k)←+f(i,j,k)f(i+1,i,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,k)←+f(i,j,k)； f(i+1,i,j)←+f(i,j,k)f(i+1,i,j)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,i,j)←+f(i,j,k)； f(i+1,j,k)←+f(i,j,k)f(i+1,j,k)\\stackrel{+}\\leftarrow f(i,j,k)f(i+1,j,k)←+f(i,j,k)。 再考虑题目中的限制，实际上就是限制了 dp 过程中 jjj 和 kkk 的取值范围： x=1x=1x=1，则 jljljl； x=2x=2x=2，则 j≥l,klj\\ge l,klj≥l,kl； x=3x=3x=3，则 k≥lk\\ge lk≥l。 考虑优化，看上去第一维什么都不是！将转移分为 iii​ 层，每一层的状态只能从上一层转移过来，第三个转移就是直接从上一层的对应点转移，第一二个转移是对上一层的一列和一行求和。 等价于，每次给出一个矩形，先把矩形外的值全部清零。然后还可以发现，一旦某个值被清零，那么这个值以后永远都是零。并且对于某一行来说，非零的值永远是一段连续区间，而且其位置是单调的。 双指针扫，不重复清零某个行即可。最终时间复杂度 O(n2+m)O(n^2+m)O(n2+m)。代码。"},{"title":"多项式乘法","path":"/wiki/oi-note/8-1.html","content":"假定你拥有高中数学基础。 复数 复数的三角形式可以表示为 a=r(cos⁡θ+isin⁡θ)a=r(\\cos\\theta + i\\sin \\theta)a=r(cosθ+isinθ)。 那么假定 a=r1(cos⁡α+isin⁡α),b=r2(cos⁡β+isin⁡β)a=r_1(\\cos\\alpha + i\\sin \\alpha),b=r_2(\\cos\\beta + i\\sin\\beta)a=r1​(cosα+isinα),b=r2​(cosβ+isinβ)，有 ab=r1r2(cos⁡αcos⁡β−sin⁡αsin⁡β+icos⁡αsin⁡β+icos⁡βsin⁡α)=r1r2(cos⁡(α+β)+isin⁡(α+β))ab=r_1 r_2(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta + i\\cos\\alpha\\sin\\beta + i\\cos\\beta\\sin\\alpha)=r_1r_2(\\cos(\\alpha + \\beta)+i\\sin(\\alpha+\\beta))ab=r1​r2​(cosαcosβ−sinαsinβ+icosαsinβ+icosβsinα)=r1​r2​(cos(α+β)+isin(α+β))，也就是说，模长相乘，辐角相加，即棣莫弗定理。 由复数的三角形式，我们画一个单位圆，以 (1,0)(1,0)(1,0) 为起点，在圆上等间距画出 nnn 个点，这样得到的 nnn 个复数便是 nnn 次单位根，转到的第一个记作 ωn\\omega_nωn​，有 ωnn=1\\omega_n^n =1ωnn​=1。 欧拉公式：eix=cos⁡x+isin⁡xe^{ix}=\\cos x + i\\sin xeix=cosx+isinx。 快速傅里叶变换 设 F(x)=∑i=0n−1ai×xiF(x)=\\sum\\limits_{i=0}^{n-1} a_i\\times x^iF(x)=i=0∑n−1​ai​×xi，那么这是多项式的系数表示法。 由拉格朗日插值可知，我们搞 nnn 个不重复的点也可以确定一个 n−1n-1n−1 次多项式，这是多项式的点值表示法。 FFT 我们现在假定（nnn 为偶数）： F1(x)=a0+a2×x+a4×x2+⋯an−2×xn/2−1F2(x)=a1+a3×x+a5×x2+⋯an−1×xn/2−1F_1(x)=a_0+a_2\\times x + a_4\\times x^2+\\cdots a_{n-2}\\times x^{n/2-1}\\\\ F_2(x)=a_1+a_3\\times x + a_5\\times x^2 +\\cdots a_{n-1}\\times x^{n/2-1} F1​(x)=a0​+a2​×x+a4​×x2+⋯an−2​×xn/2−1F2​(x)=a1​+a3​×x+a5​×x2+⋯an−1​×xn/2−1 那么 F(x)=F1(x2)+xF2(x2)F(x)=F_1(x^2)+x F_2(x^2)F(x)=F1​(x2)+xF2​(x2)。并且： F(ωnk)=F1(ωn2k)+ωnkF2(ωn2k)=F1(ωn/2k)+ωnkF2(ωn/2k)F(ωnk+n/2)=F1(ωn2k)+ωnk+n/2F2(ωn2k)=F1(ωn2k)−ωnkF2(ωn2k)\\begin{aligned} F(\\omega_n^{k})=F_1(\\omega_n^{2k})+\\omega_{n}^k F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_{n/2}^{k})+\\omega_{n}^k F_2(\\omega_{n/2}^{k}) \\end{aligned} \\\\ \\begin{aligned} F(\\omega_n^{k+n/2})=F_1(\\omega_n^{2k})+\\omega_{n}^{k+n/2} F_2(\\omega_n^{2k})\\\\ =F_1(\\omega_n^{2k})-\\omega_{n}^{k} F_2(\\omega_n^{2k}) \\end{aligned} F(ωnk​)​=F1​(ωn2k​)+ωnk​F2​(ωn2k​)=F1​(ωn/2k​)+ωnk​F2​(ωn/2k​)​F(ωnk+n/2​)​=F1​(ωn2k​)+ωnk+n/2​F2​(ωn2k​)=F1​(ωn2k​)−ωnk​F2​(ωn2k​)​ 通过这样的方式，我们可以以 O(nlog⁡n)O(n\\log n)O(nlogn) 的时间复杂度在已知一个多项式的系数表示时求得它的点值表示，在求出两个多项式的点值表示后，我们就可以计算 H(x)=F(x)G(x)H(x)=F(x)G(x)H(x)=F(x)G(x)，进而得到两多项式乘积的点值表示。 IFFT 我们现在要将点值表示转化为系数表示，我们现在得到了 nnn 个点 (ωni,yi=F(ωni))(\\omega_{n}^i,y_i=F(\\omega_{n}^i))(ωni​,yi​=F(ωni​))。 略。 迭代实现 void FFT(int L, Complex *f, int type) // L 表示长度, type = 1 表示 FFT, type = 0 表示 IFFT static int r[N]; for (int i = 1; i L; ++i) r[i] = (r[i 1] 1) + (i 1 ? L 1 : 0); if (i r[i]) swap(f[i], f[r[i]]); for (int d = 1; d L; d = 1) Complex wd(cos(PI / d), sin(PI / d)); // 2d 次单位根 wd.b *= type; // IFFT 单位根取倒数, 相当于沿 x 轴对称 static Complex w[N]; w[0] = Complex(1, 0); for (int j = 1; j d; ++j) w[j] = w[j - 1] * wd; // 用数组记录 0 ~ d-1 次单位根, 减少复数乘法次数 for (int i = 0; i L; i += d 1) for (int j = 0; j d; ++j) Complex x = f[i | j], y = w[j] * f[i | j | d]; f[i | j] = x + y, f[i | j | d] = x - y; if (type == -1) for (int i = 0; i L; ++i) f[i] = f[i] / L; 三次变两次优化 我们考虑 (f+gi)2=f2−g2+2fgi(f+gi)^2=f^2-g^2+2fgi(f+gi)2=f2−g2+2fgi，因此有 三次变两次。 快速数论变换 将 FFT 的单位根换成原根。 半在线卷积 模板，一般使用 CDQ 分治 + NTT 来解决。我们每次统计 l∼midl\\sim midl∼mid 对 mid+1∼rmid+1\\sim rmid+1∼r 的贡献，写出来之后发现是多项式乘法的形式。 void solve(int l, int r) // if (l == r) return; int mid = l + r 1, L = 1; solve(l, mid); static int a[N], b[N]; while (L r - l + 1) L = 1; for (int i = 0; i L; ++i) a[i] = (l + i = mid ? f[l + i] : 0), b[i] = g[i]; NTT(L, a, 1); NTT(L, b, 1); for (int i = 0; i L; ++i) a[i] = 1ll * a[i] * b[i] % P; NTT(L, a, -1); for (int i = mid + 1; i = r; ++i) f[i] = (f[i] + a[i - l]) % P; solve(mid + 1, r);"},{"title":"拉格朗日插值","path":"/wiki/oi-note/8-4.html","content":"拉格朗日插值是沟通多项式的系数形式与点值形式的重要公式。 事实上，nnn 个点确定唯一的多项式，其最高项次数为 n−1n-1n−1。 一般形式 核心思想是利用点值的可加性。什么意思呢？ 构造一个函数 f(x)f(x)f(x) 经过 P(x1,y1),⋯P(xn,yn)P(x_1,y_1),\\cdots P(x_n,y_n)P(x1​,y1​),⋯P(xn​,yn​)，设第 iii 个点在 xxx 轴上的投影为 Pi′(xi,0)P_i^{\\prime}(x_i,0)Pi′​(xi​,0)。考虑构造 nnn 个函数，使得 fi(x)f_i(x)fi​(x) 的图像经过 {Pj′(xj,0),(j≠i)Pi(xi,yi)\\begin{cases}P_j^{\\prime}(x_j,0),(j eq i)\\\\P_i(x_i,y_i)\\end{cases}{Pj′​(xj​,0),(j=i)Pi​(xi​,yi​)​，则 f(x)=∑i=1nfi(x)f(x)=\\sum_{i=1}^{n}f_i(x)f(x)=∑i=1n​fi​(x)。 设 fi(x)=a∏j≠i(x−xj)f_i(x)=a\\prod_{j e i}(x-x_j)fi​(x)=a∏j=i​(x−xj​)，然后将 PiP_iPi​ 的坐标代入求出 a=yi∏j≠i(xi−xj)a=\\cfrac{y_i}{\\prod_{j e i}(x_i-x_j)}a=∏j=i​(xi​−xj​)yi​​，进而导出： f(k)=∑i=1nyi∏i≠jk−xjxi−xjf(k)=\\sum_{i=1}^n y_i\\prod_{i e j}\\frac{k-x_j}{x_i-x_j} f(k)=i=1∑n​yi​i=j∏​xi​−xj​k−xj​​ 这就是拉格朗日插值表达式。 如果要求出系数，用 O(n2)O(n^2)O(n2) 卷出 F(x)=∏i=1n(x−xi)F(x)=\\prod_{i=1}^n (x-x_i)F(x)=∏i=1n​(x−xi​)，然后对于每个 iii 暴力将 FFF 除掉 x−xix-x_ix−xi​ 算出 F(x)x−xi\\cfrac{F(x)}{x-x_i}x−xi​F(x)​ 的各项系数，再乘 yi∏j≠ixi−xj\\cfrac{y_i}{\\prod_{j e i}{x_i-x_j}}∏j=i​xi​−xj​yi​​ 即可得到 fif_ifi​ 的各项系数，加起来即可。时间复杂度为 O(n2)O(n^2)O(n2)。 #include iostream#include cstdiousing namespace std;const int MOD = 998244353;int poww(int a, int b) int res = 1; for (; b; b = 1, a = 1ll * a * a % MOD) if (b 1) res = 1ll * res * a % MOD; return res;int n, k;int x[2005], y[2005];int main(void) scanf(%d%d, n, k); for (int i = 1; i = n; ++i) scanf(%d%d, x + i, y + i); int ans = 0; for (int i = 1; i = n; ++i) int s1 = y[i], s2 = 1; for (int j = 1; j = n; ++j) if (i != j) s1 = 1ll * s1 * (k - x[j]) % MOD, s2 = 1ll * s2 * (x[i] - x[j]) % MOD; ans = (ans + 1ll * s1 * poww(s2, MOD - 2)) % MOD; printf(%d , (ans % MOD + MOD) % MOD); return 0;"},{"title":"正整数中的数论","path":"/wiki/oi-note/9-1.html","content":"主要是针对素数的研究。 素数与合数 如果一个数 x(x∈N)x(x\\in\\mathbb{N})x(x∈N) 的约数仅有 111 和它本身，那么就称 xxx 是质数（素数），特别地，000 和 111 不是质数，如果一个自然数不是质数，他就是合数。 可以用线性筛在 O(n)O(n)O(n) 的时间内筛出所有质数，用 O(r+(r−l+1)log⁡(r−l+1))O(\\sqrt{r}+(r-l+1)\\log(r-l+1))O(r​+(r−l+1)log(r−l+1)) 的时间筛出区间内的所有质数。 ppp 进赋值序列是刻画正整数的重要方式。可以将正整数表示到 ppp 维空间上。 例题 刷提升 1 [TTPC2022] Many Products Portal. 肯定先把 MMM 质因数分解"},{"title":"模意义下的数论","path":"/wiki/oi-note/9-2.html","content":"基础知识 拉格朗日定理：在模 ppp 意义下，最高次项系数非 000 的 nnn 次多项式至多有 nnn 个根。 线性同余方程组 可以使用 CRT 解决模数互质的情况，exCRT 解决模数不互质的情况。 {x≡a1(modm1)x≡a2(modm2)⋯x≡a3(modm3)\\begin{cases} x\\equiv a_1 \\pmod {m_1}\\\\ x\\equiv a_2 \\pmod {m_2}\\\\ \\cdots\\\\ x\\equiv a_3 \\pmod {m_3}\\\\ \\end{cases} ⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋯x≡a3​(modm3​)​ 模数互质 设 M=∏i=1nmi,Mi=m÷miM=\\prod_{i=1}^{n}m_i,M_i=m\\div m_iM=∏i=1n​mi​,Mi​=m÷mi​，tit_iti​ 是线性同余方程 Miti≡1(modmi)M_it_i\\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​) 的一个解，也就是说 tit_iti​ 是 MiM_iMi​ 模 mim_imi​ 的逆元（显然 Mi⊥miM_i \\perp m_iMi​⊥mi​ 当且仅当 mim_imi​ 两两互质），那么 x=∑i=1naiMiti+kMx=\\sum_{i=1}^{n}a_iM_it_i + kMx=∑i=1n​ai​Mi​ti​+kM，最小非负整数解需要求 ∑i=1naiMiti mod M\\sum_{i=1}^{n}a_iM_it_i\\bmod M∑i=1n​ai​Mi​ti​modM。 i64 CRT(void) // x === a[i] (mod m[i]) i64 ans = 0, x; for (int i = 1; i = n; ++i) M[i] = mm / m[i]; t[i] = inv(M[i], m[i]); ans = (ans + a[i] * M[i] * t[i]) % mm; return (ans % mm + mm) % mm; 模数不互质 考虑如何合并两个方程组。我们先假定一定可以合并，然后看看什么时候合并之后的解是 ∅\\varnothing∅。 假设我们有： {x≡a(modA)x≡b(modB)\\begin{cases} x\\equiv a \\pmod A\\\\ x\\equiv b \\pmod B \\end{cases} {x≡a(modA)x≡b(modB)​ 那么 x=Ak1+a=Bk2+bx=Ak_1+a=Bk_2+bx=Ak1​+a=Bk2​+b，不难使用 exgcd 求出一组合法的 k1,k2k_1,k_2k1​,k2​，则通解为： K1=k1+t×Bgcd⁡(A,B)K2=k2−t×Agcd⁡(A,B)K_1=k_1+t\\times \\frac{B}{\\gcd(A,B)}\\\\ K_2=k_2-t\\times \\frac{A}{\\gcd(A,B)} K1​=k1​+t×gcd(A,B)B​K2​=k2​−t×gcd(A,B)A​ 则 x=A(k1+t×Bgcd⁡(A,B))+a=Ak1+t×lcm⁡(A,B)+ax=A(k_1+t\\times \\frac{B}{\\gcd(A,B)})+a=Ak_1+t\\times \\operatorname{lcm}(A,B)+ax=A(k1​+t×gcd(A,B)B​)+a=Ak1​+t×lcm(A,B)+a，也就是： x≡Ak1+a(modlcm⁡(A,B))x\\equiv Ak_1+a \\pmod{\\operatorname{lcm}(A,B)} x≡Ak1​+a(modlcm(A,B)) i64 exCRT(void) // x === A[i] (mod B[i]) i64 A = 1; LL a = 0; // M 为当前合并的模数，ans 为当前答案 for (int i = 1; i = n; ++i) i64 b = ::A[i], B = ::B[i], x, y, c = b - a; i64 g = exgcd(A, B, x, y); if (c % g != 0) return -1; a = A * ((LL)x * (c / g)) + a; A = A / g * B; a %= A; return (a + A) % A;"},{"title":"欢迎来到 NOI 一轮复习笔记","path":"/wiki/oi-note/index.html","content":"这是什么 原为不知名菜狗 OIer james1BadCreeper 在高二备战 NOI2024 时书写的笔记，现在他要上大学了，于是重新整理并完善了这些内容。 当时的想法很美好，但是受限于水平和执行力，很多内容都没能完成。现在重新将其拾起，能完成多少是多少了。 怎样使用 受限于作者的水平，完全依照本笔记来学习是不妥的。需要学会在网上查找更多的参考文章和向大佬提问。阅读本笔记时要保持警惕，如果发现错误，请及时通过评论区告知笔者，谢谢您的支持。 但是笔者认为这些笔记的选题是很有价值的。如果你在学习对应知识点的时候不知道做什么题，不妨看一看本笔记。 通用规则 以下是笔记的一些符号的含义，与一些不说明的规则： 题目前的星号： *： 不错的题目； **： 相当不错的题目。 P 打头的题号默认是洛谷主题库。"},{"title":"阅读须知","path":"/wiki/pastmemory/index.html","content":"本质上是关于 iznomia 的某种自设，但其相对来说更庞大。会逐步补全，目前的推荐阅读顺序（若是无序列表则代表内容是平行的）： 旧历： 天灾 破碎篇：完美谎言 新历 终界旅行 二次重生 除此之外，《个人档案》可以在您喜欢的时候阅读。 最后，希望您能在阅读之后，优雅地忘记一切。"}]